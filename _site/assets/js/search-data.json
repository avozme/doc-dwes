{"0": {
    "doc": "1 Sistemas gestores de contenido (CMS)",
    "title": "1 Sistemas gestores de contenido (CMS)",
    "content": "# 1. CMS: Sistemas gestores de contenido ## 1.1. Desarrollo web clásico vs CMS Desarrollar sitios web usando HTML, CSS, JavaScript, PHP, etc. tiene muchas ventajas: Permite sacar el máximo partido de las posibilidades de Internet. Nos da un control absoluto sobre el sitio web que estamos desarrollando. Pero también tiene inconvenientes: La creación de un sitio desde cero es un proceso muy largo. Las ampliaciones y actualizaciones del sitio también resultan lentas y costosas. Ambas tareas (creación y actualización) requieren personal altamente cualificado, con conocimientos de todas las tecnologías implicadas (HTML, CSS, PHP, Ajax, etc). Si los inconvenientes superan a las ventajas, es conveniente usar un CMS. Un CMS (Content Management System) es un programa, escrito generalmente en PHP, que se ejecuta en un servidor web y se controla desde un navegador (cliente), permitiéndonos: Crear a través del navegador un sitio web completamente nuevo en muy poco tiempo. Administrar fácilmente todo lo relacionado con el sitio web: usuarios, privilegios, contenido, apariencia, menús, etc. Y todo ello sin tener conocimientos de HTML, CSS, PHP ni el resto de tecnologías (ojo: no es necesario, pero sí conveniente) ## 1.2. Cómo funciona un CMS El CMS guarda el contenido del sitio web en una base de datos. Cuando se solicita una página, un script PHP busca el contenido de esa página en la BD y la genera dinámicamente, enviándola al navegador (cliente). Además, otro conjunto de scripts PHP permiten agregar nuevo contenido, modificar el contenido existente, crear usuarios, gestionar privilegios, etc. Al sitio web en sí se le suele denominar front-end. El front-end es lo que ve el visitante de la web. A las páginas de adminsitración del sitio se les llama back-end o dashboard. El back-end sólo es accesible a algunos usuarios. El CMS necesita, por ello, un control de acceso de usuarios o login. ## 1.3. Tipos de CMS Hay un montón de CMS, y cada uno tiene sus propias características, puntos fuertes y puntos débiles. Podemos clasificarlos según su método de distribución: Código abierto y software libre. Código propietario. Pero suele ser más útil clasificarlos por su funcionalidad: CMS genéricos (para cualquier tipo de sitio web) CMS para blogs. CMS para foros. CMS para wikis. CMS para e-learning (aprendizaje por internet) CMS para e-commerce (comercio electrónico) CMS para publicaciones digitales (periódicos, revistas...) Los CMS actuales son fuertemente incompatibles Cada uno utiliza un interfaz distinto, bases de datos completamente diferentes para almacenar la información, módulos incompatibles, etc. Existen algunas iniciativas para lograr que los servicios desarrollados en un CMS puedan utilizarse en otros, pero todavía están en un estadio muy inicial. Lo que sí existen son familias de CMS relacionados entre sí que pueden compartir algunas características, generalmente porque unos CMS han derivado de otros. ## 1.4. Algunos CMS Los CMS propietarios no han podido competir con los CMS libres. Por ello, han evolucionado hacia soluciones cloud computing completas, como: Microsoft Azure Apple iCloud Google Cloud Platform Amazon Web Services Apache CloudStack Etc. Para blogs: WordPress Calepin Scriptogram Jeckyll Anchor Etc. Para wikis: MediaWiki WikkaWIki DokuWiki Etc. Para foros: phpBB MyBB VBulletin Simple Machines Forum Etc. Para e-learning: Moodle WebCT Mahara Claroline Etc. Para e-commerce: PrestaShop Magento OsCommerce Zen Cart Etc. Otros CMS específicos: eGroupWare: para groupware (desarrollo colaborativo) ownCloud: almacenamiento de archivos. Coppermine: galerías de imágenes. PyASC: galerías de arte. Lista actualizada de CMS en Wikipedia. ## 1.5. Instalación de un CMS IMPORTANTE: la instalación puede diferir notablemente de un CMS a otro. Hay que leer cuidadosamente las instrucciones de instalación, que encontrarás en la web del desarrollador. Pasos que suelen ser habituales en casi todos los CMS: Descargar la última versión del programa de la web del desarrollador. Asegurarse de que el servidor cumple los prerrequisitos para ejectuar el CMS (versión de Apache, PHP, MySQL u otro software necesario) Subir el CMS por ftp al servidor. Crear la base de datos. Lanzar la instalación del CMS. Adapar el archivo de configuración (suele llamarse config.php, config.inc, o algo similar). En los CMS más elaborados este paso no es necesario, pues el programa de instalación se encarga de generar un archivo de configuración válido. A veces, hay que modificar los permisos de algún directorio y/o archivo. Instalar el paquete de idioma español (si está disponible) ## 1.6. Explotación de un CMS IMPORTANTE: la explotación puede diferir notablemente de un CMS a otro. Hay que leer cuidadosamente las instrucciones de uso, que encontrarás en la web del desarrollador. Pasos que suelen ser habituales en casi todos los CMS, una vez realizada la instalación: Asignar una password de alta seguridad al usuario administrador que se crea por defecto. Crear otros usuarios y asignarles privilegios. Editar la página de inicio del sitio web. Cambiar la plantilla (apariencia) del sitio. Instalar módulos de ampliación (si es necesario). Crear el contenido y/o revisar el contenido creado por otros usuarios. ",
    "url": "/cms/",
    "relUrl": "/cms/"
  },"1": {
    "doc": "2 Introducción a PHP",
    "title": "2 Introducción a PHP",
    "content": "# 2. Introducción a PHP ## 2.1. Programación cliente-servidor Desde hace una década, es habitual ejecutar programas remotos a través del navegador de internet Solución CLIENTE - SERVIDOR. El navegador de internet es el programa CLIENTE, que lanza peticiones al SERVIDOR. El SERVIDOR es otra máquina remota, en la que corren los programas SERVIDORES (p.ej: el servidor http es el que nos sirve las páginas web para poder verlas en el cliente) Desde la web se puede así acceder a los recursos del servidor. Por ejemplo, mediante instrucciones SQL puede usarse una BD alojada en el servidor. Esquema CLIENTE – SERVIDOR Ejemplo: servicio www XXX imagen Esquema CLIENTE – SERVIDOR Otro ejemplo de servicio www XXX imagen ## 2.2. Caja de herramientas para programación de aplicaciones web ### 2.2.1. DHTML DHTML y PHP son los lenguajes que nos van a permitir ejecutar programas en el servidor y acceder a sus recursos a través de páginas web. Existen otras posibilidades, como: DHTML con ASP DHTML con JSP DHTML con Python, Ruby, Perl, etc. MySQL / MariaDB es un servidor de bases de datos que nos permitirá conectarnos a ellas y ejecutar sentencias SQL de forma remota al visitar una página web. También hay otras posibilidades, como: SQL Server Oracle PostgreSQL DHTML (Dynamic HTML) no existe como tal, sino que es la conjunción de tres lenguajes: HTML CSS JavaScript DHTML sirve para crear las páginas web por las que navegamos todos los días. Cada uno de sus lenguajes componentes se encarga de hacer una parte del trabajo. Resumiendo, las herramientas que necesitaremos son: HTML CSS JavaScript / jQuery / Ajax PHP u otro lenguaje de script de servidor (Python, Ruby, Perl, etc) Un framework para trabajar con el lenguaje elegido. MySQL / MariaDB u otro SGBD que permita acceso remoto. A continuación introduciremos las herramientas básicas. A lo largo del curso, iremos viendo el resto. ### 2.2.2. HTML HTML = HyperText Markup Language (Lenguaje de Etiquetas de Hipertexto) Es un lenguaje para formatear documentos: Permite definir el tipo de letra, tamaño, formato y color de los textos. Permite insertar imágenes y otro contenido multimedia. Permite crear listas, tablas, enumeraciones... Permite crear enlaces entre secciones del mismo documento, o enlaces con otros documentos (hipertexto) NO es un lenguaje de programación: No permite programar algoritmos. Pero sí permite incrustar otros lenguajes de programación en su interior, aumentando así su potencia. Los trozos de código embebidos dentro de HTML se denominan scripts. En 1990 se crea HTML (procedente de un lenguaje anterior, SGML) junto con la World Wide Web, para formatear los documentos de la www. Se amplía en sucesivas versiones hasta la 3.0, que no consiguió éxito debido a las limitaciones de los navegadores de la época. Comienza la guerra de navegadores: Microsoft y Netscape sacan sus propios “dialectos” de HTML y destrozan en estándar. A partir de HTML 4 se intenta unir las características de los dos, pero el resultado es demasiado complejo. Se hace evidente que hay que hacer una “limpieza” de HTML Así surge XHTML, la versión XML de HTML, mucho más estricta y formal, con menos añadidos pero igual de potente. Versiones actuales de HTML recomendadas: HTML 4.01 transicional: HTML clásico, con todos los elementos del HTML antiguo, aunque se recomiende no usar muchos de ellos) HTML 4.01 estricto: también llamado XHTML, no permite usar los elementos HTML desaprobados, tales como definición de formatos. HTML5: elimina definitivamente los elementos antiguos del lenguaje e incorpora algunos nuevos para completar la asimilación con XML. La especificación para HTML6 (o HTML Next) está actualmente en desarrollo. ### 2.2.3. CSS CSS = Cascade Style Sheet (Hojas de estilo en cascada) Es un lenguaje para la definición de los formatos utilizados en una página web. CSS sólo permite definir el formato (es decir, el aspecto) de la página, no su contenido. Al definir los formatos en otra parte, se pueden reutilizar a lo largo de una o incluso de varias páginas. Si cambiamos la definición CSS del formato, se cambian automáticamente los formatos de todas las páginas que usen esa definición. El objetivo último es separar completamente el formato de la página de su contenido → XHTML. CSS 2.1 se usa con HTML 4. CSS3 se usa con HTML5 y ya se puede considerar soportado universalmente. ### 2.2.4. Javascript JavaScript es un lenguaje interpretado que puede ser incrustado dentro del código HTML de una página web. Todos los navegadores web actuales son capaces de interpretar código JavaScript. El código JavaScript puede interactuar y modificar cualquier parte del documento HTML, por lo que dota a las páginas web de dinamismo e interactividad. JavaScript no es Java, aunque su sintaxis está a medio camino entre C++ y Java. La implementación de JavaScript de cada navegador es distinta, obteniéndose resultados que no siempre son iguales. Por ejemplo: V8 = motor JS de Chrome WebKit = motor JS de Safari Rhino = motor JS de Mozilla Firefox WebKit = motor JS de Microsoft Edge ### 2.2.5. PHP PHP es un acrónimo recursivo. Significa “PHP Hypertext Preprocessor” Es un lenguaje de programación usado generalmente para generar páginas web dinámicas. Es ese caso, aparece embebido en documentos HTML / XHTML. Pero también puede usarse para crear aplicaciones convencionales (usando las extensiones PHP-Qt o PHP-GTK) Permite conectarse con múltiples bases de datos: MySQL, Oracle, Postgres, SQL Server, DB2, etc. También puede conectar por ODBC. Se parece mucho a otros lenguajes 3GL y O.O. (en particular a C/C++), por lo que la curva de aprendizaje para los que ya saben programar es muy corta. Surge en 1995 como extensión de CGI (otro lenguaje para acceso a funciones del servidor) PHP3 (1998) tuvo un gran éxito comercial. PHP4 (2000) es la versión más extendida (por desgracia): la mayoría de los scripts en PHP que circulan por la red están escritos en esta versión obsoleta. PHP5 (2004) tiene soporte para orientación a objetos y una biblioteca de clases bastante bien diseñada. Por lo tanto, desde esta versión PHP pasa de ser un lenguaje estructurado (3GL) a ser un lenguaje orientado a objetos. PHP6 empezó a desarrollarse en 2007 y se canceló en 2014. PHP7 es la última versión (7.4.10 en septiembre de 2020). El mantenimiento de PHP4 ha concluido y el de PHP5 se detuvo en 2018, por lo que todas las nuevas aplicaciones deberían escribirse en PHP7. Lo nuevo en PHP 7: Mejoras importantes de rendimiento. Unificación de la sintaxis de las variables. Declaración de tipos devueltos por los métodos. Declaración de tipos escalares (integer, float, string y boolean) Clases anónimas. Reemplazo de antiguos errores internos de PHP por excepciones manejables en tiempo de ejecución. Operador de comparación Etc Pros Completamente libre y abierto. Muy eficiente. Ejecutable en (casi) cualquier servidor. Excelente documentación. Curva de aprendizaje baja si ya sabes programar. Entornos de desarrollo abundantes, para todos los gustos. Fácil interoperatibilidad con otros sistemas, en particular con bases de datos. Comunidad muy grande. Sigue siendo líder del mercado de aplicaciones web. Cons Fallos de diseño (corregidos en su mayoría a partir de PHP 5), como: Los métodos para acceso a bases de datos cambian según el SGBD usado. Nombres de funciones inconsistentes. No es completamente orientado a objetos. Tipado confuso y, a veces, impredecible. Grandes (e incompatibles) cambios entre versiones. Pérdida lenta pero imparable de cuota de mercado (en favor de Python) Pésima relación señal/ruido en la web: ¡hay demasiados malos desarrolladores en PHP! Lenguajes script de cliente Son lenguajes que se ejecutan en la máquina cliente. El servidor web envía al cliente una página HTML con código en otro lenguaje en su interior. El navegador del cliente ejecuta ese código en su máquina JavaScript es un lenguaje de cliente Lenguajes script de servidor Son lenguajes que se ejecutan en la máquina servidor. El servidor web ejecuta el script, cuya salida es un fichero en HTML. Ese fichero HTML es enviado a la máquina cliente, que lo interpreta y visualiza. Puede contener en su interior scripts de cliente. PHP es un lenguaje de servidor Los scripts de servidor pueden acceder a los recursos ubicados en el servidor: bases de datos, ficheros, etc. ### 2.2.6. MariaDB MariaDB es un gestor de bases de datos relacional multiusuario y multiplataforma. Permite mútiples conexiones remotas. El software libre. Existen librerías para acceder a MariaDB desde muchos lenguajes: C/C++, Java, PHP, Perl, Pascal... Además, hay drivers ODBC. Está muy extendida en aplicaciones web, generalmente en combinación con PHP. Cuenta un un interfaz gráfico programado en PHP, llamado PHPMyAdmin, que se ejecuta en el navegador web. MySQL surgió como un proyecto OpenSource en Suecia en 1995. El objetivo era lograr un SGBD rápido y fiable que cumpliera con el estándar SQL. Las primeras versiones (que se denominaron mSQL) eran muy ineficientes. La popularización de PHP y su ganancia en eficiencia a partir de la versión 3 la han hecho muy popular en la actualidad. Tras su adquisición por Oracle, se intentó relegar al segmento medio-bajo en el mercado de los SGBD y surgió un fork: MariaDB. Versión más reciente (agosto 2020): MariaDB 10.5.5 ## 2.3. Sintaxis de PHP El código PHP se escribe incrustado dentro de un documento de texto mediante estas etiquetas: La sintaxis clásica se ha desechado en PHP 7: Este archivo debe tener extensión .php. El servidor ejecuta el código PHP que encuentre dentro del archivo, mientras que el código HTML es enviado al cliente sin modificar. Comentarios en PHP: // Comentario de una línea # Comentario de una línea /* Comentario de una o varias líneas */ Operadores: son iguales que los de C/C++: Asignación: $a = 3; Comparación: ==, =, !=, , etc. Operadores aritméticos: +, -, *, /, %... Operadores lógicos: &&, ||, ! Etc. Variables El identificador siempre debe empezar por $ No es necesario declararlas: al inicializarlas queda especificado el tipo. En PHP 7 pueden indicarse los tipos predefinidos (int, float, string...) Ejemplos: $a = 4; // Variable entera (PHP 5) int $a = 4; // Variable entera (PHP 7) $media = 52.75; // Variable real $texto = \"Hoy es lunes\"; // Variable string Variables asignadas por referencia (&): Cuando una variable se asigna a otra usando el operador &, ambas pasan a compartir el mismo espacio de memoria. A partir de ahora, un cambio en una de las dos provoca un cambio en la otra. $a = &$b; // a y b son “la misma” variable Cambio de tipo en las variables Cualquier variable puede cambiarse de tipo con la función setType: $a = “10”; // a es una cadena setType($a, “integer”); // a se convierte a entero Los tipos predefinidos en PHP son: integer (entero) double (real) bool (booleano) string (cadena) array (pues eso) Arrays Los arrays en PHP son colecciones de variables del mismo o de distinto tipo identificadas por un índice. Ejemplos: $a[1] = \"lunes\"; $a[2] = \"martes\"; $a[3] = \"miércoles\"; Lo habitual es que el índice sea un número entero, pero puede no serlo (array asociativo): $a[\"ESP\"] = \"España\"; $a[\"FRA\"] = \"Francia\"; $a[\"POR\"] = \"Portugal\"; Condicionales if (condición) { acciones-1; } else { acciones-2; } Bucle mientras while (condición) { acciones; } Bucle repetir do { acciones; } while (condición); Bucle para El bucle para controlado por contador es idéntico a C/C++ for (inicialización; condición; incremento) { acciones; } Hay una variedad muy interesante: el bucle foreach para recorrido de arrays asociativos: foreach ($array as $índice=>$variable) { acciones; } El bucle foreach se repite una vez para cada valor guardado en el array. Ese valor se asigna a la variable en cada repetición. Funciones y procedimientos (¡sólo en PHP4!) Los subprogramas (funciones y procedimientos) se escriben en PHP con la misma palabra: function. Las funciones deben devolver un valor en su última línea con return. Los procedimientos no. Los parámetros de la función en PHP siembre se pasan por valor. Si un procedimiento tiene que devolver varios valores, lo hará en un return con un array, como veremos en los ejercicios. Ejemplo: function calcular_iva($base, $porcentaje) { $total = $base * $porcentaje /100; return $total; } Clases y objetos (¡solo en PHP5 y PHP7!) class miClase { // Declaración de propiedades (atributos) public $var = 'soy una variable de clase'; // Declaración de métodos public function mostrarVar() { echo $this->var; } private function resetVar() { $this->var = ''; } } // ------------------------------------ $miObjeto = new miClase(); $miObjeto->mostrarVar(); Ámbito de las variables: paso de parámetros por la URL (1) Las variables de una función/clase/método PHP son locales, es decir, sólo están disponibles en esa función/clase/método. Si se definen variables fuera de una función, serán globales a todo el fichero actual, pero no pueden usarse en scripts ubicados en otros ficheros. Para compartir variables entre scripts diferentes, se usa habitualmente la URL (o dirección): El código PHP ubicado en “página.php” puede recuperar el valor de las variables $variable1, $variable2, etc. Ámbito de las variables: paso de parámetros por la URL (2) La forma de acceder a las variables recibidas a través de la URL es con el array del sistema $_GET, que se indexa con el nombre de las variables: Ejemplo: \"; ?> Salida de datos Recuerda que PHP se ejecuta dentro de un navegador web. Por lo tanto, su salida debe poder verse en el navegador. El navegador web sólo puede mostrar páginas escritas en código HTML, por lo que PHP debe producir como salida código HTML o XHTML válido. Ejemplo (observa el uso de “echo” para producir la salida): esto en negrita\" ?> Entrada de datos a través de formulario (1) Como PHP se ejecuta dentro de HTML, sólo puede recibir datos a través del navegador web. Y sólo hay una forma de introducir datos en una página web: a través de un formulario. Ejemplo: supongamos que hemos definido en HTML este sencillo formulario: Nombre Apellidos Entrada de datos a través de formulario (2) El formulario se verá en el navegador más o menos así: XXX captura Entrada de datos a través de formulario (3) Al pulsar sobre “Enviar”, se ejecutará el script destino.php. Ese script recibirá dos variables HTML llamadas nombre y apellido, con el valor que el usuario haya introducido en el formulario. Para acceder a las variables HTML, se usa el array del sistema $_POST, indexándolo con el nombre de la variable: \" ?> Observa que $_POST es una variable semejante a $_GET. Puedes utilizar una u otra según el method que hayas establecido en tu formulario HTML. La variable $_REQUEST sirve tanto para POST como para GET. Por eso será la que nosotros usaremos preferentemente en nuestros programas. ## Interacción entre MariaDB y PHP Interacción de PHP con MySQL o MariaDB MySQL es un SGBD profesional, por lo que la interacción con él busca ser eficiente y segura, pero no necesariamente fácil. Hay básicamente tres métodos de utilizar MySQL: A través de la línea de comandos: Iniciamos una sesión en MySQL con: $ mysql -u nombre_usuario -p contraseña Y luego tenemos a nuestra disposición montones de comandos para hacer cosas con la base de datos, incluyendo cualquier instrucción válida en SQL. A través de un interfaz gráfico como PHPMyAdmin: Es un conjunto de scripts en lenguaje PHP que proporcionan un interfaz aceptablemente cómodo para trabajar con MySQL. Es el método más utilizado para ejecución interactiva de SQL. A través de un programa escrito en PHP o algún otro lenguaje con posibilidad de acceso a MySQL. Este método de acceso será el que nosotros practicaremos a continuación. Acceso a MySQL con PHP4 El modo en que se accedía a bases de datos en PHP4 era mediante bibliotecas de funciones diferentes para cada SGBD. Este tipo de codificación está obsoleta y se desaconseja su uso. Ya no tiene soporte oficial, por lo que no se resolverán futuros problemas de seguridad o estabilidad. Lo mostramos aquí para que sepáis lo que NO se debe hacer. Encontraréis mucho código de esta naturaleza en la red que DEBE SER EVITADO. Acceso a MySQL con PHP4 PHP4 utiliza una biblioteca de funciones PHP cuyo nombre empieza por mysql_. Por ejemplo, para insertar un registro en una BD MySQL: Consultas SQL con PHP4 (1/2) La ejecución de consultas (SELECT) produce la devolución de un conjunto de registros. Esos regisotrs se manejan en PHP con un cursor. Observa cómo se hace en este ejemplo: ... continúa en la pág. siguiente ... Consultas SQL con PHP4 (2/2) ... viene de la pág. anterior ... | Nombre | Teléfono | . | '.$registro[\"nombre\"].' | '; echo ' | '.$registro[\"telefono\"].' | . '; } mysql_free_result($result) ?> Otras funciones importantes para trabajar con MySQL en PHP4 (1/2) mysql_connect(\"URL\", \"user\", \"password\"); Conecta con MySQL. En la URL hay que poner la dirección completa dónde se encuentra el servidor funcionando (ejemplos: “localhost”, “219.39.21.23”, “http://miservidor.com”, “/home/user”, etc.) mysql_select_db(\"nombre_base_de_datos\"); Abre una base de datos de las que MySQL tenga disponibles. mysql_close($variable_bd); Cierra la conexión con MySQL. La $variable_bd nos la devolvió mysql_connect(). Es aconsejable hacerlo antes de que termine el programa. Otras funciones importantes para trabajar con MySQL en PHP4 (2/2) mysql_query(\"sentencia-SQL\"); Ejecuta el código SQL especificado. Pueden introducirse en su interior variables PHP (siempre precedidas del símbolo $). Si es un SELECT, el resultado debe asignarse a una variable. mysql_fetch_array($variable); Procesa la variable donde se guardó el resultado de un SELECT. Cada llamada devuelve un registro completo, que debe asignarse a su vez a otra variable. Con esa variable podemos acceder a cada uno de los campos, indexándola por el nombre del campo (ver ejemplo anterior). mysql_affected_rows(); Devuelve el número de registros afectados por la última operación SQL (válido para INSERTE, UPDATE y DELETE) mysql_num_rows(); Como la anterior, pero para SELECT Acceso a MySQL con PHP5 y PHP7 Desde PHP5 se utiliza una biblioteca de clases para acceder a los diferentes SGBDs. Este tipo de codificación es la que se recomienda en la actualidad. Todos los nuevos desarrollos deberían usar las bibliotecas de clases y prescindir de las viejas librerías de funciones. Todos los desarrollos antiguos deberían migrarse a PHP7 por razones de seguridad, compatibilidad y eficiencia. ¡Cuidado! Mucho código de ejemplo de PHP que circula por la red es PHP4 y DEBE SER EVITADO. Acceso a MySQL con PHP5 / PHP7 Por ejemplo, para insertar un registro en una BD MySQL: query(\"INSERT INTO clientes (nombre,telefono) VALUES ('$nombre','$telefono')\"); ?> Aviso para navegantes PHP5/7 proporciona varios mecanismos para acceder a bases de datos (¡demasiadas formas de hacer lo mismo!): La extensión mysqli en su forma procedimental. Es idéntica a la de PHP4, pero cambiando la palabra “mysql” por “mysqli”. Por ejemplo, mysql_connect() cambia a mysqli_connect(). Apta para programadores perezosos y anticuados, que no quieren pasarse a la POO. La extensión mysqli en su forma orientada a objetos. Es la que nosotros recomendamos. Los ejemplos que estamos mostrando usan esta forma. La extensión PDO. Se trata de una clase genérica que permite acceder a cualquier gestor de bases de datos mediante el mismo conjunto de métodos. En funcionalidad y rendimiento es idéntica a mysqli. Consultas SQL con PHP5 y PHP7 (1/2) La ejecución de consultas (SELECT) produce la devolución de un conjunto de registros. Esos registros se manejan en PHP con un cursor. Observa cómo se hace en este ejemplo: connect_error){ die(\"Error en la conexion : \".$db->connect_error); } //Ejecutamos la consulta SQL $result=$db->query(\"SELECT * FROM Clientes\"); ?> ... continúa en la pág. siguiente ... Consultas SQL con PHP5 y PHP7 (2/2) ... viene de la pág. anterior ... | Nombre | Teléfono | . fetch_array()) { echo ' | '.$registro[\"nombre\"].' | '; echo ' | '.$registro[\"telefono\"].' | . '; } $db->free($result); // Libera memoria usada por cursor $db->close(); // Cierra la conexión con el servidor ?> ",
    "url": "/php/",
    "relUrl": "/php/"
  },"2": {
    "doc": "3 Cookies, sesiones y seguridad",
    "title": "3 Cookies, sesiones y seguridad",
    "content": "# 3. Cookies, sesiones y seguridad ## 3.1. Autenticación mediante ACL Casi todas las aplicaciones web incluyen un subsistema de autenticación de usuarios (ACL = Access Control Login). Ese subsistema suele estar basado en este diseño de base de datos: XXX esquema ## 3.2. Cookies Las cookies son variables que se guardan en el ordenador del cliente. Sintaxis: bool setcookie ( string $name [, string $value [, int $expire = 0 [, string $path [, string $domain [, bool $secure = false [, bool $httponly = false ]]]]]] ) Ejemplo: setcookie(\"TestCookie\", $value, time()+3600); Para acceder al valor de una cookie: $_COOKIE[\"NombreCookie\"]; Ejemplo: echo \"La cookie TestCookie vale \".$_COOKIE[\"TestCookie\"]; ## 3.3. Sesiones Las sesiones sirven para guardar variables en el servidor. Esas variables sólo son accesibles para el cliente que creó esa sesión. Sintaxis: session_start(); $_SESSION[\"variable\"] = $valor; Algunas funciones para manejar sesiones: // Abre una sesión o la retoma si ya estaba abierta session_start(); // Cierra una sesión abierta y destruye sus variables session_destroy(); // Devuelve el ID de la sesión session_id(); // Destruye todas las variables de sesión session_unset(); ## 3.4. Sesiones, cookies y seguridad Cookies y variables de sesión se usan a menudo para controlar la seguridad de la aplicación web. Por ejemplo, tras el login, el ID del usuario puede almacenarse en: Una cookie. Si existe esa cookie, significa que el login ha sido correcto y la aplicación puede continuar. Una variable de sesión. Si existe tal variable, el login ha sido correcto. Cuando el usuario abandona la aplicación, el programa debe destruir la cookie o cerrar la sesión. ¡Ningún método es completamente seguro! Las cookies pueden rastrearse o modificarse en el ordenador del cliente. Además, algunos clientes las tienen desactivadas. ¡No te puedes fiar de ellas! Las variables de sesión, en principio más seguras, pueden ser atacadas capturando el ID de sesión. El método más seguro, y el más complicado de programar, es el que combina: Cookies y/o variables de sesión. Variables guardadas en una tabla de la BD. ## 3.5. Técnicas de ataque frecuentes ### 3.5.1. Captura de ID de sesión El ID de sesión se pasa entre páginas de forma transparente a través de cookies o de la URL (con POST). Un atacante puede leer el ID de sesión en el paquete http y acceder a las variables de sesión. Solución: Combinar las variables de sesión con cookies o con entradas en la base de datos. No confiar en variables de sesión para información sensible. ### 3.5.2. Inyección de SQL Se inserta código SQL en campos de formulario. Este código actúa sobre la BD, dando información al atacante sobre su estructura y contenido, o permitiéndole destruir datos. Soluciones: Usar filtros de SQL (MySQLi incluye algunos, como real_scape_string()) Utilizar usuarios de MySQL sin privilegios destructivos (¡root solo en fase de desarrollo!) Filtrar los datos de entrada de los formularios. ### 3.5.3. XSS (cross site scripting) Se inyecta código JavaScript a través de la URL, de un formulario o de algún otro elemento externo. Ese código JS redirecciona a otra página o tiene algún otro efecto indeseado. Soluciones Filtrar todos los datos externos. Usar listas blancas de datos válidos. ### 3.5.4. CSRF (cross site request forgery) Consiste en que un usuario accede a partes no permitidas de la aplicación insertando datos maliciosos en la URL o en un formulario. Soluciones: Utilizar POST en lugar de GET para no dar pistas. Generar tokens únicos para cada petición. Filtrar los datos de entrada. ### 3.5.5. DT (directory transversal) El atacante accede a ficheros fuera del directorio público (htdocs o public_html) mediante rutas relativas (../../ejemplo.php) Sucede cuando la página que se va a cargar se envía como un parámetro en la URL (index.php?page=ejemplo.php) Soluciones: Filtrar el formato de las páginas enviadas por la URL, o tener una lista de páginas válidas. ### 3.5.6. RFI (remote file inclusion) Consiste en acceder al sistema de ficheros del servidor mediante inyección de código malicioso en la URL o en un formulario (por ejemplo, con el comando exec de SQL) Soluciones: Filtrar datos de entrada. Tener una lista de páginas válidas. ",
    "url": "/cookies-sesiones-seguridad/",
    "relUrl": "/cookies-sesiones-seguridad/"
  },"3": {
    "doc": "4 Arquitectura MVC",
    "title": "Listado de Artículos",
    "content": "| Fecha | Titulo | . fetch_array()) { echo \"\"; echo \" | \".$fila['fecha'].\" | \"; echo \" | \".$fila['titulo'].\" | \"; echo \" . \"; } echo \"\"; $db->close(); ?> ### 4.5.2. Primera mejora: controlador + vista Dividir el código en: Un controlador. Una vista. query('SELECT fecha, titulo FROM articulo'); $articulos = array(); while ($fila = $resultado->fetch_array()) { $articulos[] = $fila; } $db->close(); ?> include('vista.php'); ?> ",
    "url": "/mvc/",
    "relUrl": "/mvc/"
  },"4": {
    "doc": "4 Arquitectura MVC",
    "title": "Listado de Articulos",
    "content": "| Fecha | Titulo | . | | . ### 4.5.3. Segunda mejora: modelo, vista y controlador Dividir el código en: Un controlador. Una vista. Un modelo. // Este es el controlador (solo realiza una acción) include('articulos.php'); // En este archivo estará el modelo $articulos = Articulos::getAllArticulos(); require('vista.php'); // En este archivo estará la vista query('SELECT fecha, titulo FROM articulo'); $articulos = array(); while ($fila = $resultado->fetch_array()) { $articulos[] = $fila; } $db->close(); return $articulos; } } ?> ",
    "url": "/mvc/",
    "relUrl": "/mvc/"
  },"5": {
    "doc": "4 Arquitectura MVC",
    "title": "Listado de Articulos",
    "content": "| Fecha | Titulo | . | | . ### 4.5.4. Tercera mejora: añadiendo capa de abstracción de datos Dividir el código en: Un controlador. Una vista. Un modelo en dos capas: Capa de abstracción de datos. Capa de acceso a datos. class DbAbstract { private $db; function crearConexion($servidor, $usuario, $clave, $dbname) { $db = new mysqli($servidor, $usuario, $clave, $dbname); } function cerrarConexion() { if ($db) $db->close(); } function consulta($consulta) { $res = $db→query($consulta); $resArray = array(); if ($res) { $resArray = $res->fetch_all(); } return $resArray; } ...etc… (añadimos cualquier función que acceda directamente a MySQL) } include \"DbAbstract.php\"; class Articulos { public function getAllArticulos() { $db = new dbAbstract(); $db->crearConexion('localhost', 'usuario', 'clave','dbName'); $articulos = $db->cosulta('SELECT fecha, titulo FROM articulo'); $db->cerrarConexion(); return $articulos; } } ### 4.5.5. Cuarta mejora: transformación en clases y objetos reutilizables Implementar el código siguiendo el paradigma de orientación a objetos. Crear clase Controlador. Crear clase Vista. $controlador = new Controlador(); $controlador->main(); include (\"Vista.php\"); include (\"Articulos.php\"); class Controlador { public function main() { $estado = (isset($_REQUEST['do']) ? $_REQUEST['do'] ; \"formLogin\"); switch ($estado) { case \"formLogin\": ... case \"checkLogin\": ... case \"showAllArticles\": $articulos = Articulos::getAllArticulos(); Vista::show(\"showAllArticles\"); break; case \"...etc…\": ... } } } ",
    "url": "/mvc/",
    "relUrl": "/mvc/"
  },"6": {
    "doc": "4 Arquitectura MVC",
    "title": "Listado de Articulos",
    "content": "| Fecha | Titulo | . | | . crearConexion('localhost', 'usuario', 'clave','dbName'); $articulos = $db->cosulta('SELECT fecha, titulo FROM articulo'); $db->cerrarConexion(); return $articulos; } } class DbAbstract { private $db; function crearConexion($servidor, $usuario, $clave, $dbname) { $db = new mysqli($servidor, $usuario, $clave, $dbname); } function cerrarConexion() { if ($db) $db->close(); } function consulta($consulta) { $res = $db→query($consulta); $resArray = array(); if ($res) { $resArray = $res->fetch_all(); } return $resArray; } ...etc… (añadimos cualquier función que acceda directamente a MySQL) } ",
    "url": "/mvc/",
    "relUrl": "/mvc/"
  },"7": {
    "doc": "4 Arquitectura MVC",
    "title": "4 Arquitectura MVC",
    "content": "# 4. Arquitectura MVC ## 4.1 Arquitecturas FÍSICAS multinivel (multitier) Arquitectura en 2 niveles: XXX esquema Arquitectura en 3 niveles: XXX esquema ## 4.2 Arquitecturas LÓGICAS multicapa (multilayer) Ventajas: Desarrollos paralelos en cada capa Aplicaciones robustas (encapsulamiento) Matenimiento más sencillo Más flexibilidad para añadir módulos Más escalabilidad para aumentar rendimiento ### 4.2.1. Esquema Modelo-Vista-Controlador (MVC) XXX esquema Arquitectura en 3 capas Es una generalización del patrón MVC. XXX esquema Hay que decidir qué componentes hay, sus funciones, y en qué capa y qué nivel físico encaja cada uno. ### 4.2.2. Otras arquitecturas multicapa Modelo de capas mejorado con una capa de entidades XXX esquema ### 4.2.3. Características de las arquitecturas multicapa Funcionalidades transversales presentes en todas las capas: Seguridad Escalabilidad Rendimiento Comunicaciones Control de calidad ## 4.3. Arquitecturas orientadas a los servicios (SOA) Permiten comunicar sistemas diferentes mediante protocolos bien definidos en XML. XXX esquema Los estudiaremos en un tema posterior. ## 4.4. Patrones de software Los patrones de software: Soluciones comprobadas a problemas comunes en el desarrollo de software. Características de un patrón: Debe haber sido comprobado en otros sistemas. Debe ser fácilmente reutilizable. Debe ser aplicable a diferentes circunstancias. Debe estar bien documentado. ### 4.4.1. Documentación típica de un patrón de software: Nombre. Problema que resuelve. Contexto en el que es aplicable. Fuerzas, objetivos y restricciones. Solución que propone. Ejemplos. Contexto resultante. Exposición razonada. Otros patrones relacionados. ### 4.4.2. Tipos de patrones: De arquitectura (p. ej: MVC) De diseño De creación de objetos De estructura de clases De comportamiento De dialectos De interacción o interfaz de usuario De análisis De dominio ### 4.4.3. Ejemplo de patrón: el patrón Singleton Ejemplo de patrón: el patrón Singleton Algunos recursos en una aplicación son de tal naturaleza que sólo puede existir una instancia de ese tipo de recurso. Por ejemplo, la conexión a la base de datos a través de un manejador de base de datos. A veces interesa compartir un manejador de base de datos para que el resto de recursos no tengan que conectarse y desconectarse continuamente de la BD, y sólo debería existir una instancia de ese manejador. El patrón Singleton cubre esta necesidad. Un objeto es “singleton” si la aplicación puede generar una y sólo una instancia del mismo. _handle =& DB::Connect( $dsn, array() ); } public function handle() { return $this->_handle; } } print( \"Handle = \".DatabaseConnection::get()->handle().\"\\n\" ); print( \"Handle = \".DatabaseConnection::get()->handle().\"\\n\" ); ?> ## 4.5. El patrón MVC en la práctica Mostrar lista de artículos de un blog ### 4.5.1. Código monolítico query('SELECT fecha, titulo FROM articulo'); ?> ",
    "url": "/mvc/",
    "relUrl": "/mvc/"
  },"8": {
    "doc": "5 Laravel",
    "title": "5 Laravel",
    "content": "# 5. Laravel Laravel es un framework PHP MVC diseñado para agilizar el desarrollo de aplicaciones web. En los últimos años ha tenido una gran penetración en la industria. Empezaremos por aprender qué es un framework PHP MVC, qué frameworks existen y en qué circunstancias resulta interesante utilizar una de estas herramientas para desarrollar una aplicación. Dedicaremos el resto del tema a estudiar todas las peculiaridades de Laravel para aprender a desarrollar aplicaciones con este poderoso framework. ",
    "url": "/laravel/",
    "relUrl": "/laravel/"
  },"9": {
    "doc": "6 Servicios web",
    "title": "6 Servicios web",
    "content": "# 6. Servicios web TODO ",
    "url": "/servicios-web/",
    "relUrl": "/servicios-web/"
  },"10": {
    "doc": "7 Ajax",
    "title": "7 Ajax",
    "content": "# 7. Ajax TODO ",
    "url": "/ajax/",
    "relUrl": "/ajax/"
  },"11": {
    "doc": "8 Otras tecnologías",
    "title": "8 Otras tecnologías",
    "content": "# 8. Otras tecnologías TODO ",
    "url": "/otras-tecnologias/",
    "relUrl": "/otras-tecnologias/"
  },"12": {
    "doc": "5.1 Frameworks PHP MVC",
    "title": "5.1 Frameworks PHP MVC",
    "content": "## 5.1. ¿Qué es un framework? Un framework es un conjunto estandarizado de prácticas de programación para resolver un problema concreto. El framework proporciona una serie de clases, librerías y otros componentes para facilitar el desarrollo ágil, seguro y escalable de nuevas aplicaciones. Un framework MVC PHP es un tipo de framework concreto, destinado a servir de base para desarrollar aplicaciones en PHP con arquitectura MVC. ### 5.1.1. ¿Realmente necesito un framework para desarrollar una aplicación web? No, pero en ciertas ocasiones es muy conveniente. Hay programadores pro-frameworks y anti-frameworks. Los programadores anti-frameworks realmente acaban desarrollando su propio framework después de varias aplicaciones MVC. Para decidir si necesitas un framework o no, tienes que conocer antes cómo funcionan y qué ventajas e inconvenientes presentan. Usar un framework tiene ciertas ventajas, como: * Reutilización del trabajo ya hecho (no reinventar la rueda). * Extensa documentación. * Separación en capas. * Seguimiento de buenas prácticas de programación. * Escalabilidad y mantenimiento. * Desarrollo más rápido. Pero también tiene algunos inconvenientes: * A veces pueden limitar el desarrollo. * Curva de aprendizaje costosa (más en unos frameworks que en otros) * Puede llegar a implicar más trabajo, dependiendo del proyecto. * Preferencias personales: algunos programadores solo se sienten cómodos si todo el código es suyo. * Ocultan gran parte del funcionamiento de la aplicación: no son aptos para aprender a programar. En resumen: la idea es que, al usar un framework, solo te centras en desarrollar lo importante. El resto (lo que ya estaba desarrollado) no te quita tiempo. ### 5.1.2. ¿Qué framework escoger? Existen multitud de frameworks MVC PHP. Estos son algunos de gran implantación actual: * Symfony: el más extendido desde hace alos. * Laravel: el que tiene un crecimiento más rápido. * CodeIgniter: el más sencillo, aunque su implantación en la industria el menor. * Otros framworks MVC PHP importantes son Zend Framework, Yii o CakePHP. Puedes pasar el resto de tu vida leyendo en foros y en blogs, descargando e instalando varios frameworks para desecharlos a los dos días, esperando a que salga una nueva versión o un framework nuevo... No hay respuesta a la pregunta: ¿qué framework es mejor? Además, el framework por sí sólo puede no ser suficiente para un desarrollo completo, y probablemente harán falta otros componentes como: * Librerías del lado del servidor (pear, pChart, doctrine...) * Librerías del lado del cliente (jQuery, vue.js, bootstrap...) ",
    "url": "/laravel/1",
    "relUrl": "/laravel/1"
  },"13": {
    "doc": "5.10 Migraciones",
    "title": "5.10 Migraciones",
    "content": "## 5.10. Migraciones ### 5.10.1. ¿Qué son las migraciones? Las migraciones constituyen una especie de control de versiones para la base de datos de la aplicación. Permiten crear y modificar tablas de la BD con independencia del SGBD que estemos usando. Con las migraciones no solo podrás reconstruir la base de datos en menos de lo que tarda en decirse \"Von Neumann\" (algo muy práctico cuando estás en fase de desarrollo), sino que podrás parchear la base de datos de una aplicación en producción en un tiempo record y con riesgo cero. Solo el que ha tenido que parchear la base de datos de una aplicación en producción antes de la existencia de las migraciones sabe la tranquilidad de espíritu que esto produce y la cantidad de problemas embarazosos que te quita de encima. Antes de empezar, recuerda que, para que cualquier operación sobre la base de datos funcione, debes tener bien configurados estas variables de entorno del archivo .env de Laravel: ``` DB_HOST=localhost DB_DATABASE=mi-base-de-datos DB_USERNAME=mi-usuario-de-BD DB_PASSWORD=mi-password-de-BD ``` ### 5.10.2. Crear tablas mediante las migraciones Si, por ejemplo, quisiéramos crear las migraciones de una tabla llamada Clients, los pasos a seguir serían: **Paso 1**: Inicializar el sistema de migraciones de Laravel (si ya lo hemos hecho antes, nos dará un error al intentar hacerlo otra vez): ``` $ php artisan migrate:install ``` **Paso 2**: Crear la migración para la tabla Clients: ``` $ php artisan make:migration create_clients_table ``` Esto generará un fichero en /database/migrations cuyo nombre contendrá un timestamp. Algo como /database/migrations/20201226072434createclientstable.php Si editas ese fichero, verás dos métodos: * up() → se ejecuta cuando se lanza la migración. * down() → se ejecuta cuando se cancela la migración. **Paso 3**: Editar el fichero /database/migrations/createclientstable.php: En el método up() tienes que indicar las columnas que tendrá la tabla. Por ejemplo: ```php public function up() { Schema::create('clients', function (Blueprint $table) { $table->bigIncrements('id')->index();// UNSIGNED BIGINT AUTOINC. $table->string('name',75)->unique(); // VARCHAR $table->text('address')->nullable(); // TEXT $table->integer('level'); // INT $table->date('brith_date'); // DATE // La siguiente línea crea campos created_at y updated_at. Si la borras // esos campos no existirán en tu tabla $table->timestamps(); }); } public function down() { Schema::drop('clients'); } ``` **Paso 4**: Lanzar las migraciones. ``` $ php artisan migrate ``` Esto creará las tablas que no se hayan creado aún. Es decir, si una migración ya se ha lanzado con anterioridad, no se vuelve a ejecutar para no perder los datos que pudieran existir en esas tablas. **Paso 5**: Revertir las migraciones (si es necesario) Si necesitas revertir la creación de todas las tablas: ``` $ php artisan migrate:rollback ``` Para revertir solo el último paso en la creación de tablas: ``` $ php artisan migrate:rollback --step=1 ``` Para dejar la BD a su estado original (vacía): ``` $ php artisan migrate:reset ``` ¡Cuidado! Estas acciones son destructivas. Pero, por supuesto, hay una forma de modificar una tabla sin borrarla y volver a crearla. ### 5.10.3. Modificar tablas mediante migraciones Si necesitas modificar una tabla que ya existe (por ejemplo, para añadir o eliminar campos), tienes dos opciones: 1. Modificar la migración original (en la que se crea la tabla) para añadir o eliminar el campo afectado. Esto te obligará a lanzar la migración de nuevo y, por lo tanto, la tabla se reconstruirá y todos los datos que pudiera contener se perderán. 2. Crear una nueva migración en la que únicamente se haga la modificación de la tabla, sin tocar el resto. Esto respetará los datos que la tabla ya pudiera contener. Como es lógico, la opción 2 será la que preferiremos si la aplicación ya está en producción y necesitamos modificar la estructura de la base de datos. En cambio, durante el desarrollo, puede ser más simple utilizar la opción 1. Supongamos que queremos añadir un campo \"email\" a la tabla \"Clients\" del apartado anterior. Si optas por la opción 2, es decir, por crear una nueva migración que se encargue de hacer esa modificación en la tabla sin alterar sus datos, la forma de proceder es la siguiente: **Paso 1**. Crear la migración: ``` $ php artisan make:migration add_email_to_clients --table=clients ``` (Nota: puedes asignar el nombre que quieras a las migraciones, pero Laravel aconseja utilizar las convenciones que ves en estos ejemplos para simplificarnos la vida) **Paso 2**: Editar la migración /database/migration/add_email_to_clients.php para añadir, en el método up(), el campo nuevo; y, en el método down(), especificaremos qué hay que hacer en caso de que se fuerce un rollback de esta migración: ```php public function up() { Schema::table('clients', function (Blueprint $table) { $table->string('email')->after('address'); }); } public function down() { Schema::table('clients', function (Blueprint $table) { $table->dropColumn('email'); }); } ``` ### 5.10.4. Otras operaciones en las migraciones Las migraciones pueden usarse para cualquier otra operación sobre la estructura de la base de datos, como: * Cambiar tipos de columnas. * Cambiar atributos de columnas (null, unique, default...) * Cambiar o asignar claves primarias y ajenas. Las migraciones construídas de este modo nos permitirán reproducir la base de datos en cualquier servidor o actualizarla en cualquier momento sobre una aplicación en producción sin necesidad de programar parches o exportar la BD a un archivo SQL para importarlo en otro servidor. Más info en: [https://laravel.com/docs/8.x/migrations](https://laravel.com/docs/8.x/migrations) ### 5.10.5. Seeding El seeding es una técnica adicional a la de las migraciones que permite cargar con datos las tablas de la base de datos. Es muy práctico en estos supuestos: * Si quieres tener un conjunto de datos de prueba en tu base de datos de desarrollo (esa que destrozas periódicamente cuando haces pruebas). Con un solo comando, tendrás la base de datos reconstruída como si no hubieras ejecutado un \"DELETE * FROM users\" sin querer. * Si necesitas cargar algunos datos mínimos en algunas tablas para que la aplicación, una vez desplegada en un servidor de producción, funcione (por ejemplo, para crear un usuario administrador en la tabla \"Users\" o para crear algunas entradas en una tabla \"Options\") Para crear un seeder (por ejemplo, para la tabla users), sigue estos pasos: **Paso 1**. Ejecuta el comando: ``` $ php artisan make:seeder UsersTableSeeder ``` **Paso 2**. Editar el seeder /database/seeds/UsersTableSeeder.php y añade algo como esto al método up() (por supuesto, modifica el código para adaptarlo a tu tabla y a tus datos): ```php public function run() { Users::truncate(); // Opativo: vacía la tabla antes de rellenarla DB::table('users')->insert([ 'name' => 'Stephen Falken', 'address' => ' Oregon 97, Goose Island', 'email' => 'sfalken@norad.com', 'brith_date' => '1932-09-03', ]); } ``` **Paso 3**. Ejecuta este comando para lanzar el seeder y que los datos se carguen en tu tabla: ``` $ php artisan db:seed --class=UsersTableSeeder ``` Esto cargará un solo registro en la tabla users. Si quieres más, solo tienes que crear nuevas líneas insert() en el método up(). ### 5.10.5. Automatizar el seeding Lanzar los seeders de uno en uno puede ser muy tedioso. Puedes lanzar varios seeders con un solo comando si haces lo siguiente: **Paso 1**. Edita el fichero /database/seeds/DatabaseSeeder.php **Paso 2**. Añade a la función run() una línea como esta por cada seeder que quiera ejecutar automáticamente: ```php $this->call(UsersTableSeeder::class); ``` **Paso 3**. ¡Y listo! Al ejecutar el comando db:seed de Artisan, sin indicar la clase, se lanzarán todos los seeders que hayas aladido a run(): ``` $ php artisan db:seed ``` ### 5.10.6. Lista de comandos superútiles para manejar migraciones ``` $ php artisan migrate → Lanza todas las migraciones. ``` ``` $ php artisan make:migration --create= → Crea una migración para la tabla indicada. ``` ``` $ php artisan make:migration --table= → Modifica una migración para la tabla indicada. ``` ``` $ php artisan migrate:rollback → Retrocede UN paso en todas las migraciones. ``` ``` $ php artisan migrate:rollback --step= → Retrocede N pasos en todas las migraciones. ``` ``` $ php artisan migrate:reset → Deshace todas las migraciones que se hayan ejecutado hasta ahora. ``` ``` $ php artisan migrate:refresh → Reset + migrate en un solo comando. ``` ``` $ php artisan migrate:refresh --seed → Reset + migrate + seed en un solo comando. ``` ``` $ php artisan migrate:fresh → Elimina todas las tablas y lanza todas las migraciones. ``` ``` $ php artisan migrate:fresh --seed → Elimina todas las tablas, lanza todas las migraciones y todos los seeders. ``` ",
    "url": "/laravel/10",
    "relUrl": "/laravel/10"
  },"14": {
    "doc": "5.11 Usando la BD con Eloquent",
    "title": "5.11 Usando la BD con Eloquent",
    "content": "## 5.11. Usando la BD con Eloquent ### 5.11.1. ¿Qué es Eloquent? Eloquent uno de los componentes de Laravel que permiten al desarrollador manipular los datos de la BD sin rebajarse a escribir sucio SQL. Eloquent es un ORM (Object-Relational Mapping), es decir, una librería que mapea los objetos de nuestra aplicación con una BD relacional. Sí, lo has entendido bien: podrás manejar los datos de tu base de datos como si fueran objetos de tu aplicación. Y, cuando los modifiques, borras o crees, se ejecutará el código SQL necesario (sin que tú te enteres) para traducir esas operaciones en sentencias para la base de datos. Te lo muestro con un ejemplo. Imagina que tenemos una tabla Articles(id, title, body). Con Eloquent, usar esa tabla desde un controlador es tan fácil como hacer algo así: ```php $art = Article::find('7'); // Buscamos un artículo por su id echo $art->title; // Accedemos a los campos de ese artículo $art->body = \"Texto del cuerpo\"; // Modificamos los campos del artículo $art->save(); // Guardamos la modificación en la BD ``` ### 5.11.2. Mola. ¿Cómo puedo usar Eloquent en mi aplicación? Tienes que crear un modelo. ¿Qué te creías? Pero con Artisan es así de fácil: ``` $ php artisan make:model ``` Por ejemplo: ``` $ php artisan make:model Article ``` El modelo se creará en /app/Article.php Nota: si creas el modelo con la opción -m, se creará atomáticamente su migración, lo cual resulta tremendamente práctico: ``` $ php artisan make:model Article -m ``` Ya tienes tu modelo. Si no puedes contener tu curiosidad insaciable y lo abres, verás un archivo bastante decepcionante con este aspecto: ```php ', 100)->get(); // Select con where Article::where('id', '>', 100)->take(10)->get(); // Select con where y take Article::max('id'); // Último id asignado ``` ### 5.11.5. Inserciones y borrados con Eloquent Podemos usar Eloquent para insertar un nuevo artículo desde nuestro controlador: ```php $art = new Article; $art->title = 'Los Chitauri invaden Nueva York'; $art->body = 'Bla, bla, bla'; $art->save(); ``` Si los datos del artículo vienen de un formulario, fíjate en lo alucinantemente fácil que es recoger todos esos datos, crear un objeto Article con ellos y guardar el artículo en la BD: ```php public function store(Request $request) { Article::create($request->all()); // Esto es una ASIGNACIÓN MASIVA de las que hablábamos más arriba!! return ; } ``` Ojo: solo los campos que hayas indicado como \"fillables\" en el modelo se podrán asignar al artículo de este modo. Mira el apartado 5.11.3 si no sabes de qué estamos hablando. Y, por supuesto, también podemos modificar y borrar artículos de la base de datos: ```php $art = Article::find(18); // MODIFICAR $art->body = 'Nuevo cuerpo'; $art->save(); $art = Article::find(13); // BORRAR $art->delete(); ``` ### 5.11.6. Lista de los métodos más útiles de Eloquent * all() → Recupera todos los registros de una tabla. * where(\"campo\", valor) → Aplica claúsula where. * orderBy(\"campo\", \"asc|desc\") → Aplica claúsula order by. * get() → Recupera registros seleccionados. Se suele usar con where y/o order by: * Ciudades::where(\"ciudad\", \"Madrid\")->orderBy(\"id\", \"asc\")->get(); * first() → Recupera el primer registro. * latest() → Recupera el último registro. * find(valor) → Busca registros con ese valor en el campo id. * findOrFail(valor) → Lanza un error 404 si no encuentra el registro. * count(), max(), min()… → Utiliza funciones de agregado de SQL. * save() → Inserta o actualiza registros. * update() → Actualiza registros. * delete() → Elimina registros. ### 5.11.7. Relaciones entre tablas con Eloquent Las relaciones entre tablas también se pueden manejar con Eloquent sin necesidad de andar con INNER JOIN y otros miembros de su nutrida familia. Aunque te parezca al principio que definir las relaciones entre tablas con Eloquent necesita mucho trabajo previo, te garantizo que después te alegrarás de haberlo hecho. Porque las relaciones, una vez definidas, se comportan como consultas y se puede operar con ellas como si lo fueran. En los siguientes ejemplos, vamos a suponer que tenemos estas tablas: * usuarios(id#, nombre, passwd) * emails(id#, email, usuario_id) → Relación 1:1 con usuarios * articulos(id#, titulo, texto, idUsuario) → Relación 1:N con usuarios * roles(id#, nombre) → Relación N:N con usuarios ATENCIÓN: en la tabla “artículos” hemos usado a propósito un nombre no estándar para la clave ajena. La convención de Laravel es usuario_id, como en la tabla “emails”. #### 5.11.7.1. Relaciones 1:1 (usuarios emails) Para definir un relación 1:1 con Eloquent debes hacer lo siguiente: **Paso 1**. En el modelo de la tabla maestra (class Usuario, en nuestro ejemplo) añadimos este método: ```php public function email() { return $this->hasOne('App\\Email'); } ``` **Paso 2**. En el modelo de la tabla relacionada (class Email) añadimos este método: ```php public function usuario() { return $this->belongsTo('App\\Usuario'); } ``` A partir de ahora, se puede recuperar el email de un usuario (o a la inversa) de forma tan sencilla como esta: ```php $email = Usuario::find(1)->email; $user = Email::all()->first()->user; ``` #### 5.11.7.2. Relaciones 1:N (usuarios artículos) Si tienes una relación 1:N (como la que hay entre las tablas de usuarios y artículos de nuestro ejemplo), para definirla en Eloquent tienes que hacer esto: **Paso 1**. En el modelo de la tabla maestra (class Usuario), añade este método: ```php public function articulos() { return $this->hasMany('App\\Articulo', 'idUsuario'); } // ATENCIÓN: hemos tenido que indicar el nombre de la clave foránea // (idUsuario) porque no habíamos respetado la convención de Laravel // (usuario_id) al crear la tabla de artículos ``` **Paso 2**. En el modelo de la tabla relacionada (class Articulo), añade este otro método: ```php public function usuario() { return $this->belongsTo('App\\Usuario'); } ``` Y listo. Ya puedes recuperar los artículos a partir del usuario o a la inversa. Por ejemplo: ```php $articulos = Usuario::find(1)->articulos; foreach ($articulos as $articulo) { // Procesar cada artículo } ``` #### 5.7.11.3. Relaciones N:N (usuarios roles) Si lo que tienes es una relación con cardinalidad N:N (como la que hay entre usuarios y roles en nuestro ejemplo), los pasos a seguir para construirla con Eloquent son estos: **Paso 1**. En el modelo de una de las tablas (class Usuario) añadimos este método: ```php public function roles() { return $this->belongsToMany('App\\Rol'); } ``` **Paso 2**. En el modelo de la otra tabla (class Rol) añadimos este método: ```php public function usuarios() { return $this->belongsToMany('App\\Usuario'); } ``` Ahora, ya se pueden recuperar los roles a partir del usuario o a la inversa. Por ejemplo: ```php $roles = Usuario::find(1)->roles; foreach ($roles as $rol) { // Procesar cada rol } ``` #### 5.7.11.4. Insertar, modificar y borrar en relaciones N:N Insertar, modificar y borrar en relaciones N:N implica escribir datos (normalmente, ids) en la tabla intermedia o tabla pivote. Ese proceso también se puede automatizar con Eloquent. Lo vemos con un ejemplo entre nuestras tablas usuarios y roles. **Para insertar** un usuario y sus roles se usa el método attach(): ```php public function store(Request $r) { $user = new User($r→all()); $user->roles()→attach($r->roles); $user->save(); } ``` **Para actualizar** un usuario y sus roles se usa el método sync(): ```php public function update(Request $r, $id) { $user = User::find($id); $user->fill($r->all()); $user->roles()->sync($r->roles); $user->save(); } ``` **Para eliminar** un usuario y sus roles se usa el método detach(): ```php public function destroy($id) { $user = User::find($id); $user->roles()->detach(); $user->delete(); } ``` #### 5.7.11.5. Problemas frecuentes en relaciones N:N Eloquent supondrá que el nombre de la tabla de la relación se ha formado con los nombres de las dos tablas maestras en snake case y ordenadas alfabéticamente. Por ejemplo, en la relación N:N entre “usuarios” y “roles”, Eloquent supondrá que existe una tabla llamada “roles_usuarios”. Si no es así, la relación fallará. Se puede indicar otro nombre de tabla al definir la relación. Por ejemplo, en el modelo de usuarios (class Usuario): ```php public function roles() { return $this->belongsToMany('App\\Rol', 'usuarios_roles'); } ``` También se pueden indicar los nombres de las claves foráneas si no siguen la convención de Laravel (usuario_id, rol_id, etc) ```php public function roles() { return $this->belongsToMany('App\\Rol', 'usuarios_roles', 'id_usuario', 'id_rol'); } ``` ¿Te has fijado en que hemos creado un método para acceder a la tabla relacionada, pero estamos usando un atributo en su lugar? ```php public function articulos() { return $this->hasMany('App\\Articulo'); } public function loQueSea() { $arts = Usuario::find(1)->articulos; // articulos, no articulos() } ``` Pues bien, el atributo articulo es un “atributo virtual” creado por Eloquent. Pero el método articulos() también existe, y puede usarse como una consulta, extendiéndola como necesitemos. Por ejemplo: ```php $arts = Usuario::find(1)->articulos()->where('titulo','foo')->first(); ``` ",
    "url": "/laravel/11",
    "relUrl": "/laravel/11"
  },"15": {
    "doc": "5.12 Usando la BD con QueryBuilder",
    "title": "5.12 Usando la BD con QueryBuilder",
    "content": "## 5.12. Usando la BD con QueryBuilder ### 5.12.1. ¿Qué es y cómo se utiliza QueryBuilder? Eloquent permite usar la BD de forma simple y elegante en la mayor parte de las circunstancias. Aún así, puede haber situaciones en las que queramos un acceso de más bajo nivel a la BD. Para eso existe QueryBuilder. El grado de abstracción de QueryBuilder es mucho menor que el de Eloquent. Es decir, estaremos CASI escribiendo SQL, sin llegar a hacerlo. Algunos ejemplos de uso te darán una pista de qué tipo cosas se pueden hacer con QueryBuilder: ```php $users = DB::table(\"users\")->get(); $users = DB::table(\"users\")->where(\"name\", \"=\", \"Ana\")->first(); $users = DB::table(\"users\")->where(\"edad\", \">=\", 18)->orderBy(\"apellidos\"); $maxId = DB::table(\"users\")->max(\"id\"); $existe = DB::table(\"users\")->where(\"id\", \"=\", $id)->exists(); $users = DB::table(\"users\")->select(\"nombre, apellidos as apell\")->get(); ``` En la documentación oficial encontrarás una referencia completa de todas las funciones de QueryBuilder, pero con estas que ves en el ejemplo puedes construir prácticamente cualquier consulta sencilla. El resultado de estas consultas es bastante intuitivo: o bien un dato simple (como el $maxId, que es un entero) o bien un objeto de tipo Collection. Las colecciones de Laravel tienen un montón de métodos útiles para procesarlas y puedes echarle un vistazo a la documentación oficial para ello, pero la mayor parte de las veces basta con hacer un foreach sobre la variable para ir accediendo a cada uno de los elementos, que se comportarán como objetos del tipo adecuado. Por ejemplo, para acceder a todos los registros de la tabla de usuarios: ```php $users = DB::table(\"users\")->get(); foreach ($users as $user) { echo $user->name; echo $user->email; ...etc... } ``` ### 5.12.2. Ventajas de QueryBuilder sobre SQL Como ves, QueryBuilder te permite construir sentencias SQL sin necesidad de escribir SQL. La ventaja de esto es triple: 1. No tendremos que depurar nuestros errores sintácticos en SQL, con el ahorro de tiempo que eso conlleva. 2. El SQL generado será 100% compatible con el gestor de base de datos que estemos utilizando. Si escribimos SQL en crudo, tendremos que adaptarlo al dialecto de nuestro gestor de base de datos. Y, si cambiamos de gestor, habrá que revisar todas las sentencias SQL para adaptarlas de nuevo. Todo esto lo evita QueryBuilder, puesto que hace esa adaptación por nosotros. 3. Es imposible que suframos un ataque por inyección de SQL, puesto que QueryBuilder no lo permitirá. ### 5.12.3. Relaciones entre tablas con QueryBuilder Las relaciones entre tablas se manejan con joins, como en SQL, solo que escritos al estilo QueryBuilder. Para hacer un INNER JOIN, puedes usar como referencia este ejemplo: ```php $users = DB::table('users') ->join('contacts', 'users.id', '=', 'contacts.user_id') ->join('orders', 'users.id', '=', 'orders.user_id') ->select('users.*', 'contacts.phone', 'orders.price') ->get(); ``` Por supuesto, también puedes hacer LEFT JOIN y RIGHT JOIN: ```php $resultado = DB::table('A')->leftJoin('B'...); $resultado = DB::table('A')->rightJoin('B'...); ``` ### 5.12.3. SQL crudo Por último, QueryBuilder también te permite escribir SQL crudo, si es que alguna vez lo necesitas. Eso sí, deberías valorar muy bien para qué narices quieres escribir SQL crudo. ¿Estás seguro de que eso que intentas hacer no se puede lograr más fácilmente con Eloquent o con QueryBuilder? Además, tendrás que extremar las precauciones ante un posible ataque por inyección de SQL. Si aún así no te he convencido, puedes ejecutar tu SQL así: ```php $resultado = DB::raw('escribe-aquí-tu-sentencia-SQL'); ``` ",
    "url": "/laravel/12",
    "relUrl": "/laravel/12"
  },"16": {
    "doc": "5.13 Sesiones con Laravel",
    "title": "5.13 Sesiones con Laravel",
    "content": "## 5.13. Sesiones con Laravel Como es lógico, Laravel también proporciona su propio sistema de manejo de variables de sesión, y este resulta mucho más seguro y poderoso que el estándar de PHP. En esta sección vamos a ver cómo funciona y qué posibilidades nos ofrece. ### 5.13.1. Drivers de sesión Las sesiones de configuran en /config/sessions.php, y una de las cosas que debes configurar ahí es el \"driver\", es decir, el tipo de manejador que quieres que manipule las sesiones. El driver por defecto es ***files***. Es el más sencillo y funcionará en casi cualquier servidor. En producción, Laravel recomienda usar otros drivers llamados ***memcached*** o ***redis*** porque son más rápidos. Ambos son daemons del sistema programados para esta tarea. Obviamente, el servidor debe soportarlos para que puedas usarlos. Si necesitas seguridad adicional, sin duda tu driver es ***database***. Esto almacenará dos copias de cada variable de sesión: una en un fichero y otra en una tabla especial de la base de datos. Si un atacante consiguiera manipular una de las dos variables, Laravel cerrará la sesión automáticamente y el atacante se quedará con un palmo de narices. Eso sí, este sistema es el más lento de todos porque requiere un acceso a la base de datos para cada petición al servidor. ### 5.13.2. Persistencia de las variables de sesión Laravel maneja dos tipos de variable según su persistencia: * Variables flash: solo duran una petición y luego se autodestruyen. * Variables de sesión convencionales: existen hasta que las destruimos expresamente. #### 5.13.2.1. Variables flash Son variables de sesión que solo duran una petición y luego se autodestruyen. Se usan típicamente para enviar feedback al usuario. Te lo muestro con un ejemplo. En el controlador: ```php return ('login/form')->with('mensaje', 'Usuario no reconocido'); ``` En la vista: ```php @if (session('mensaje')) {% raw %}{{ session('mensaje'); }}{% endraw %} @endif ``` #### 5.13.2.2. Variables de sesión convencionales Las variables de sesión convencionales se manejan con la clase Session, que tiene un montón de métodos estáticos para crear variables, destruirlas, consultarlas, etc. Los métodos más útiles son: * **put()** -> almacena una variable de sesión: ```php Session::put('nombre-variable', 'valor'); ``` * **push()** -> elimina una variable de sesión: ```php Session::push('nombre-variable'); ``` * **get()** -> devuelve el valor de una variable de sesión: ```php $v = Session::get('nombre-variable'); $v = Session::get('nombre-variable', 'valor-por-defecto'); ``` * **all()** devuelve todas las variables de sesión en un array: ```php $a = Session::all('nombre-variable', 'valor'); ``` * **flush()** elimina todas las variables de sesión: ```php Session::flush(); ``` * **flash()** crea manualmente una variable de sesión de tipo flash: ```php Session::flash('nombre-variable', 'valor'); ``` ### 5.13.3. Autenticación #### 5.13.3.1. Laravel Breeze Laravel proporciona un Starter Kit llamado ***Breeze*** que viene con todo el código necesario para crear un sistema de autenticación completo y seguro: * Login e inicio de sesión * Registro de usuarios * Recuperación de contraseña olvidada * Confirmación de registro mediante email * Etc. Para instalar Laravel Breeze: ``` $ composer require laravel/breeze --dev $ php artisan breeze:install $ npm install $ npm run dev ``` Laravel Breeze crea automáticamente varias rutas en /routes/auth.php, entre ellas: ```php Routes::get(\"/login\") → Para mostrar el formulario de login Routes::post(\"/login\") → Para procesar el formulario de login Routes::post(\"/logout\") → Para cerrar la sesión Routes::get(\"/register\") → Para mostrar el fomulario de registro Routes::post(\"/register\") → Para procesar el formulario de registro ``` También se crean varios controladores como LoginController y RegisterContoller: están en App/Http/Controllers/Auth. Y se crean varias vistas, como auth/login.blade.php, register.blade.php y layouts/app.blade.php (la plantilla que usarán login y register) Por último, se crea una vista HOME de ejemplo (dashboard.blade.php) a la que llegamos después de hacer login. Esa vista HOME la puedes cambiar en /app/providers/RouteServiceProvider.php ¡Y listo! Solo nos queda adaptar estas vistas y controladores a nuestras necesidades. #### 5.13.3.1. Autenticación y vistas: cómo generar código dependiendo del tipo de usuario En las vistas, tenemos un par de directivas de Blade muy útiles relacionadas con las sesiones. ```php @auth ... // Este código se ejecuta si existe un usuario logueado @endauth @guest ... // Este código se ejecuta si NO existe usuario logueado @endguest ``` Además, podemos acceder a los datos del usuario mediante la clase Auth: ```php Auth::user() → Devuelve el usuario actualmente logueado o null si no hay ninguna sesión abierta. Auth::check() → Devuelve true si el usuario actual está logueado. ``` (Más métodos de Auth en https://laravel.com/docs/8.x/authentication) #### 5.13.3.2. Autenticación y middlewares: cómo proteger los controladores Los middlewares son componentes software de Laravel que capturan y filtran todas las peticiones HTTP que llegan a la aplicación. Están ubicados en App/Http/Middleware. Hay dos middlewares relacionados con la autenticación en Laravel: Authenticate (alias \"auth\") y RedirectIfAuthenticated (alias \"guest\"). Los alias se definen en App/Http/Kernel.php. Podemos usar estos middlewares en el constructor de nuestros controladores para protegerlos en todo o en parte: ```php public function __construct() { // Solo usuarios logueados podrán acceder a este controlador: $this->middleware(\"auth\"); // Solo usuarios logueados podrán acceder a los métodos create() y edit(): $this->middleware(\"auth\")->only(\"create\", \"edit\"); // Solo usuarios logueados podrán acceder al controlador excepto a show(): $this->middleware(\"auth\")->except(\"show\"); } ``` El middleware auth también puede usarse en el enrutador, para proteger todo el controlador, así: ```php Route::get('/ruta-a-proteger', 'Controlador@metodo')->middleware('auth'); ``` ",
    "url": "/laravel/13",
    "relUrl": "/laravel/13"
  },"17": {
    "doc": "5.14 Helpers de Laravel",
    "title": "5.14 Helpers de Laravel",
    "content": "## 5.14. Helpers de Laravel ### 5.14.1. ¿Qué son los helpers? Un helper es un componente del framework diseñado para facilitar alguna tarea típica en el desarrollo de una aplicación web. Por ejemplo: el helper url('ruta') genera una ruta absoluta para referenciar cualquier componente de la aplicación: ```html Volver ``` Generará este código: ```html Volver ``` Eso permite que la ruta sea correcta en cualquier servidor, sin necesidad de modificar el código fuente. El uso de los helpers es optativo: el programador/a debe decidir si le resultan útiles o no. Los helpers van cambiando mucho de una versión a otra de Laravel, por lo que te recomiendo que eches un vistazo a la documentación oficial para saber qué helpers están disponibles en tu versión de Laravel. Puedes encontrar una lista completa de helpers en: https://laravel.com/docs/X.x/helpers (sustituye X.x por tu versión de Laravel) ### 5.14.2. Algunos helpers útiles de Laravel #### 5.14.2.1. url helper ```html Volver ``` Generará este código: ```html Volver ``` Eso permite que la ruta sea correcta en cualquier servidor, sin necesidad de modificar el código fuente. #### 5.14.2.2. route helper Es parecido a url(), pero sirve para routas con nombre en el enrutador. Por ejemplo, si en el enrutador tenemos una ruta como esta: ```php Route::get(\"mi-ruta\", \"metodo@mi-controlador\")->name(\"nombre-ruta\"); ``` ...podemos referirnos a ella como: ```html Texto ``` ...o como: ```html Texto ``` La segunda forma es la mejor: permite cambiar la dirección que ve el usuario sin modificar el código fuente. #### 5.14.2.3. request helper Proporciona acceso a información sobre la petición (GET, POST o la que sea) con la que se cargó la página: * **request()->url()** → Devuelve un string con la ruta actual (completa). * **request()->path()** → Devuelve un string con la ruta actual (solo desde la raíz de la aplicación, sin http ni el nombre del servidor). * **request()->is(\"ruta\")** → Devuelve true si \"ruta\" coincide con la ruta actual. Admite wildcards (símbolos * y ?). * **request()->input(\"campo\")** → Devuelve el valor de \"campo\" (enviado desde formulario). * **request()->all()** → Devuelve un array con todos los campos. * **request()->has(\"campo\")** → Devuelve true si en la petición existe un campo con el nombre indicado. * **request()->isMethod(\"método\")** → Devuelve true si la petición se hizo por el método indicado (POST, GET, PUT, etc). El helper Request puede usarse en las vistas (como request()->url(), por ejemplo) o inyectarse en las funciones del controlador como una variable, así: ```php public function mi-función(Request $request) ``` #### 5.14.2.4. redirect helper Muy útil cuando queremos redirigir al usuario hacia otra URL o acción (por ejemplo, para evitar que al pulsar F5 se reenvíen los datos de un formulario). Admite varias formas: ```php return redirect('user/login'); return redirect()->action('LoginController@login'); return back(); ``` #### 5.14.2.5. auth helper Como vimos en la sección de sesiones y autenticación, este helper permite saber si existe algún usuario autenticado en la aplicación. auth()->user() devuelve el usuario autenticado (como un objeto) o null si nadie ha hecho login. Con el objeto User podemos acceder a todos los datos del usuario: ```php $user = auth()->user(); Bienvenido/a, {% raw %}{{ $user->name }}{% endraw %}. Este es su emial: {% raw %}{{ $user->email }}{% endraw %} ``` #### 5.14.2.6. errors helper Se utiliza para conocer y mostrar los errores ocurridos en la validación de un formulario (v. apartado de validación de formularios). La variable $errors está disponible en todas las vistas gracias a que un Middleware (ShareErrorsFromSession) la inyecta automáticamente. Algunos métodos útiles son: * **$errors->all()** → devuelve un array con todos los errores detectados. * **$errors->any()** → devuelve true si se ha detectado algún error. * **$errors->first(\"campo\")** → devuelve el primer error de todos los que puedan afectar al campo indicado. ",
    "url": "/laravel/14",
    "relUrl": "/laravel/14"
  },"18": {
    "doc": "5.15 Flujo de trabajo típico con Laravel",
    "title": "5.15 Flujo de trabajo típico con Laravel",
    "content": "## 5.15. Flujo de trabajo típico con Laravel Lo que vas a encontrar aquí es solo un posible flujo de trabajo con Laravel, es decir, una propuesta del orden en el que debes hacer las cosas para desarrollar una aplicación con este framework. No es el único flujo de trabajo posible, y sin duda no es el mejor, pero puede resultarte útil en tus primeros desarrollos, como si alguien te llevara de la mano a lo largo de un camino sinuoso. Más adelante, cuando vayas adquiriendo experiencia, tú mismo/a crearás tu propio flujo de trabajo ideal. El flujo que te propongo tiene los siguientes pasos (los cuatro primeros son solo para aplicaciones nuevas): 1. Instalar y configurar nueva aplicación. 2. Crear modelos (se supone que ya tendrás la BD diseñada). 3. Crear migraciones y seeders. 4. Lanzar las migraciones y seeders para crear y poblar la BD. 5. Crear en el enrutador las entradas de la funcionalidad que vas a programar. 6. Crear el controlador (si no existe) para la funcionalidad que vas a programar. 7. Crear las funciones del controlador necesarias. 8. Crear las funciones del modelo necesarias (si no existen ya). 9. Crear las vistas necesarias. 10. Probar. 11. Repetir los pasos 5-10 para cada funcionalidad adicional. ",
    "url": "/laravel/15",
    "relUrl": "/laravel/15"
  },"19": {
    "doc": "5.16 Laravel y Vue.js",
    "title": "5.16 Laravel y Vue.js",
    "content": "## 5.16. Laravel y Vue.js ",
    "url": "/laravel/16",
    "relUrl": "/laravel/16"
  },"20": {
    "doc": "5.17 Aspectos avanzados de Laravel",
    "title": "5.17 Aspectos avanzados de Laravel",
    "content": "## 5.17. Aspectos avanzados de Laravel TODO ### 5.17.1. Traducciones TODO ### 5.17.2. Paginación de resultados TODO ### 5.17.3. Páginas de error personalizadas TODO ### 5.17.4. URLs amigables: Routes model bindings TODO ### 5.17.5. Validación avanzada de formularios con form requests TODO ### 5.17.6. Laravel Mix TODO ### 5.17.7. Crear helpers y middlewares TODO ### 5.17.8. Collections TODO ### 5.17.9. Eventos y Listeners TODO ### 5.17.10. Actualizar la versión de Laravel de una aplicación existente sin tirarse por la ventana en el intento TODO ### 5.17.11. Mejora del rendimiento. Caché. TODO ### 5.17.12. Decoradores e interfaces TODO ### 5.17.13. Pruebas con Mockery y Selenium TODO ",
    "url": "/laravel/17",
    "relUrl": "/laravel/17"
  },"21": {
    "doc": "5.2 Características de Laravel",
    "title": "5.2 Características de Laravel",
    "content": "## 5.2. Características de Laravel Laravel es un framework PHP MVC para desarrollo rápido de aplicaciones web. Automatiza muchos procesos habituales y tiene una curva de aprendizaje empinada, pero no tanto como otros frameworks (como Symfony). Desde hace algunos años, Laravel ha experimentado un crecimiento espectacular en el mercado de las aplicaciones web. ### 5.2.1. Ventajas de Laravel 1. Sintaxis simple y elegante. 2. Mapeo objeto-relacional (ORM): Eloquent. 3. Potente sistema de plantillas para vistas: Blade. 4. Reutiliza y moderniza componentes de Symfony. 5. Sencillo y potente. 6. Uso creciente en la industria: alternativa de futuro. 7. Comunidad de usuarios altamente especializada (buena relación señal/ruido… de momento) ### 5.2.2. Inconvenientes de Laravel 1. Instalación, configuración y despliegue complejos, incluso a través de VM. 2. Curva de aprendizaje elevada. 3. Se mueve según los intereses personales de su autor (es obra individual), con actualizaciones muy frecuentes y cambios caprichosos. 4. Inestabilidad de varios de sus componentes: a menudo hay que recurir a fixes. 5. Fuerte dependencia de la consola de comandos y de herramientas de terceros (composer, vagrant, npm...) (Esto solo es un inconveniente para algunas personas) ",
    "url": "/laravel/2",
    "relUrl": "/laravel/2"
  },"22": {
    "doc": "5.3 Instalación de Laravel",
    "title": "5.3 Instalación de Laravel",
    "content": "## 5.3. Instalación de Laravel ### 5.3.1. Instalación en servidor local No es recomendable instalar Laravel de forma nativa en tu servidor local porque requiere una fuerte configuración del servidor. Tendrás que instalar bastante librerías que consumirán recursos de tu máquina sin necesidad, tales como OpenSSL, Mbstring o Tokenizer. También necesitas instalar composer, la herramienta de resolución de dependencias de PHP. Por todo ello, es recomendable optar por la virtualización del servidor mediante Vagrant (Homestead) o Docker. Discutiremos estas dos opciones más adelante. Si, aún así, estás decidido a instalar Laravel de forma nativa en tu servidor local, sigue estos pasos: **Paso 1**. Descarga Laravel. ``` $ composer global require \"laravel/installer\" ``` **Paso 2**. Instala copia de Laravel limpia y lista para usar (hacerlo en un directorio accesible por Apache). Puede requerir añadir el comando laravel al PATH del sistema. ``` $ laravel new ``` Por ejemplo: ``` $ laravel new blog ``` No olvides dar los permisos necesarios a tus archivos y directorios. Los problemas que pueden surgir son múltiples e insospechados, dependiendo de la configuración de tu servidor. Puedes intentar seguir alguna de estas guías: * [Guía para instalar Laravel en localhost en Ubuntu Linux](https://www.howtoforge.com/tutorial/install-laravel-on-ubuntu-for-apache/) * [Guía para instalar Laravel en localhost con Windows y XAMPP:](https://weeklyhow.com/installing-laravel-8-with-xampp/) ### 5.3.2. Instalación de Laravel con máquina virtual Vagrant (Homestead) Vagrant es una herramienta para crear un entorno de desarrollo virtual sin necesidad de instalar componentes en nuestra máquina. Cada entorno de desarrollo se llama Box y hay cientos de ellos. **Homestead** es un Box de Vagrant con todo lo necesario para desarrollar con Laravel sin necesidad de configurar nuestro servidor local. Este Box, creado por los propios desarrolladores de Laravel, puede configurarse para equipararlo al servidor donde se vaya a desplegar la aplicación en el futuro. La instalación de Laravel en Homestead es la forma recomendada para desarrollar proyectos Laravel en un entorno local. La puesta en producción es otra historia, y dependerá de las posibilidades de configuración del servidor. Instalar Laravel con Homestead en tu entorno local puede parecer un proceso largo y complejo, pero no suele dar problemas y la fiabilidad de está solución está garantizada, por lo que es la manera más recomendable. Si deseas instalarlo, sigue estos pasos: **Paso 1**. Instala la última versión disponible de Virtual Box. **Paso 2**. Instala Vagrant y git **Paso 3**. Agrega a Vagrant el box de Homestead: ``` $ vagrant box add laravel/homestead ``` **Paso 4**. Consigue el último código fuente de Laravel: ``` $ git clone https://github.com/laravel/homestead.git ~/Homestead ``` **Paso 5**. Selecciona la rama \"release\" del repositorio de Laravel y lanza el script de inicialización: ``` $ cd Homestead $ git checkout release $ bash init.sh (o init.bat en Windows) ``` **Paso 6**. Edita el archivo Homestead.yaml para configurar tu máquina virtual. **Paso 7**. Edita el archivo hosts (/etc/hosts o C:\\Windows\\System32\\drivers\\etc\\hosts) para añadir esta línea: ``` 192.168.10.10 homestead.test ``` (Cámbiala por la IP que hayas configurado en el archivo .yaml) **Paso 8**. Levanta la máquina virtual Homestead: ``` $ vagrant up ``` (Este comando hay que ejecutarlo desde el directorio Homestead) La primera vez puede tardar un rato mientras crea y configura la VM. **Paso 9**. Prueba en el navegador la dirección: http://homestead.test. El servidor debería responder. **Paso 10**. Prueba a acceder a la VM mediante ssh con el comando: ``` $ vagrant ssh ``` **Paso 11**. En la máquina real, crea el directorio ~/code (o el que esté configurado en el archivo Homestead.yaml). **Paso 12**. En la máquina virtual, ve al mismo directorio ~/code (o el que esté configurado en Homestead.yaml) y actualiza las librerías PHP con composer: ``` $ composer create-project laravel/laravel code --prefer-dist $ composer install ``` ¡Y listo! Tú trabajarás en tu directorio local ~/code y cualquier cambio que hagas se mapeará automáticamente al directorio ~/code en la VM. Mantén una consola abierta en la VM para ejecutar comandos artisan. Ten en cuenta que MySQL estará escuchando en 127.0.0.1:33060 (user “Homestead”, password “secret”, salvo que hayas cambiado la configuración) (¡Ojo! Esto es para conexiones desde fuera de Homestead. Desde el punto de vista de la app, MySQL seguirá estando en localhost:3306) Es posible que necesites generar una clave SSH para conexiones seguras con tu servidor virtual. * [Cómo hacerlo en Linux](https://ekiketa.es/fallo-en-homestead-check-your-homestead-yaml-file-the-path-to-your-private-key-does-not-exist/) * [Cómo hacerlo en Windows 10](https://medium.com/@eaimanshoshi/i-am-going-to-write-down-step-by-step-procedure-to-setup-homestead-for-laravel-5-2-17491a423aa) Más info en [https://laravel.com/docs/8.X/homestead](https://laravel.com/docs/8.X/homestead) ### 5.3.3. Laravel con Docker Docker es una solución de virtualización aún más ligera que Vagrant. Con Docker, se virtualizan solo los componentes software que nuestra aplicación necesita para funcionar, y se ejecutan directamente en la máquina anfitrión. Los componentes se llaman ***images***. Cuando se instancian, pasan de denominarse ***containers***. Hay docker images para todo lo imaginable. Puedes encontrarlas en [https://hub.docker.com](https://hub.docker.com). Aunque Laravel recomienda la virtualización mediante Vagrant, muchos desarrolladores optan por Docker por su mayor simplicidad y eficiencia. Para instalar Laravel mediante Docker para un desarrollo local, sigue estos pasos: **Paso 1**. Instala docker (y, optativamente, docker-compose) en tu servidor. **Paso 2**. Busca una imagen de Laravel en https://hub.docker.com. Por ejemplo, Bitnami (una empresa propiedad de VMWare) tiene imágenes bastante fiables. **Paso 3**. Crea un directorio para tu aplicación web. No importa en qué parte del árbol de directorios local estés. **Paso 4**. En la consola, teclea el comando para crear una copia local de las imágenes necesarias. En el caso de la imagen Laravel de Bitnami, el comando es: ``` $ docker pull bitnami/laravel ``` **Paso 5**. Sigue las instrucciones para el despliegue del contenedor que el desarrollador ha debido colgar en hub.docker.com. En el caso de bitnami, hay que copiar un archivo remoto mediante el comando curl y levantar las imágenes docker con docker-compose. ¡Y listo! Nuestro Laravel estará funcionando con todas sus dependencias resueltas. ",
    "url": "/laravel/3",
    "relUrl": "/laravel/3"
  },"23": {
    "doc": "5.4 Arquitectura, convenciones y configuración de Laravel",
    "title": "5.4 Arquitectura, convenciones y configuración de Laravel",
    "content": "## 5.4. Arquitectura, convenciones y configuración de Laravel ### 5.4.1. Estructura de directorios Después de una instalación limpia de Laravel, nos encotraremos con una estructura típica de directorios. Los más importantes (al menos, para empezar) son estos: **composer.json**: información para composer. **/app**: el código de nuestra aplicación. Modelos. **/app/config**: configuración de la aplicación. **/app/http**: peticiones HTTP, incluyendo los controladores. **/database**: migraciones de la BD. **/plugins**: pues eso. **/public**: directorio de acceso público. Aquí se pueden colocar imágenes, scripts o archivos css. **/resources**: assets (imágenes, css, js), archivos de idioma y vistas. **/storage**: caché, sesiones, vistas compiladas... **/vendors**: librerías de terceros. ### 5.4.2. Convenciones en Laravel Laravel tiene un montón de convenciones que persiguen hacer más sencilla la configuración de la aplicación. Aunque la mayoría no son obligatorias, es recomendable respetarlas para evitar errores de configuración y conflictos con los identificadores. * **Modelos**: Nombres igual que el de la tabla, en singular, en CamelCase y con mayúscula. Ejemplo: RegisteredUser * **Controladores**: como el modelo, pero añadiendo la palabra \"controller\" o \"controlador\". Ejempo: RegisteredUserController * **Métodos**: en camelCase empezando con minúscula. Ejemplo: User::getAll() * **Atributos**: en snake_case empezando con minúscula. Ejemplo: User::first_name * **Variables**: en camelCase empezando con minúscula. Ejemplos: bannedUsers (colección, en plural), articleContent (variable simple, en singular) * **Tablas**: en plural y en snake_case. Ej: registered_users. * **Columnas**: en snake_case, sin referencia al nombre de la tabla. Ejemplo: first_name * **Clave primaria**: id (integer y auto-increment). * **Claves ajenas**: nombre tabla ajena en singlular + id. Ejemplo: article_id * **Timestamps**: created_at y updated_at * **Tablas pivote**: en snake_case, en plural y orden alfabético. Ejemplo: articles_users será el pivote entre articles y users. ### 5.4.3. Variables de entorno. El archivo .env Este archivo contiene todas las variables de entorno que configuran la aplicación, como: * APP_ENV: ¿estamos en desarrollo o en producción? * APP_DEBUG: ¿mostrar errores para depuración? * APP_URL: URL base de la aplicación * DB_CONNECTION, DB_HOST, DB_USERNAME, etc. El archivo example.env contiene una plantilla para que puedas construir tu archivo .env. Simplemente, renombra el archivo example.env y asigna los valores correctos a las variables de entorno. El archivo .env NO debe sincronizarse con git (o con el control de versiones que usemos) porque contiene información sensible. En los archivos de configuración haremos referencia a las variables de entorno. Por ejemplo: en /config/database.php usaremos una expresión así: ``` 'default' => env('DB_CONNECTION', 'mysql') ``` El primer parámetro de env() es la variable de entorno y el segundo es el valor por defecto en caso de que la variable no exista. ### 5.4.4. Archivos de configuración del directorio /config En este directorio encontraremos multitud de archivos que configuran el funcionamiento de Laravel. En principio, no es necesario modificar ninguno, porque las configuraciones básicas se manejan desde el archivo .env. Sin embargo, hay veces que sí necesitaremos acceder a estos archivos y tocar alguna configuración. Los archivos de configuración más importantes que puedes encontrar aquí son: **database.php**: configuración de la conexión a la base de datos. Toma sus valores principales de .env, pero desde aquí podemos cambiar otras cosas, como el controlador (por defecto es MySQL, pero podemos cambiarlo a PostgreSQL, SQLite, etc) **app.php**: nombre de la aplicación, estado (desarrollo, producción...) **session.php**: forma en la que se almacenarán las sesiones (por defecto, en fichero) ",
    "url": "/laravel/4",
    "relUrl": "/laravel/4"
  },"24": {
    "doc": "5.5 Artisan",
    "title": "5.5 Artisan",
    "content": "## 5.5. Artisan: la consola que mola ### 5.5.1. ¿Qué es Artisan y cómo se utiliza? Artisan es una herramienta de consola que automatiza las tareas habituales en Laravel como: * Generar esqueletos de controladores y modelos. * Crear migraciones de bases de datos (para manipular la estructura de las tablas) * Rellenar la BD con datos de prueba. * Hacer el enrutamiento. * Configurar la aplicación. * Crear baterías de pruebas. * Y otro montón de cosas. No te preocupes si aún no entiendes qué significan algunas de estas cosas. Lo iremos viendo todo poco a poco. Lo importante ahora es que comprendas la tremenda utilidad de Artisan en el trabajo cotidiano con Laravel y que aprendas lo básico de su sintaxis. Por ejemplo, para crear un controlador, existen dos maneras: 1. A mano. Nos vamos al directorio /app/Http/Controllers y creamos un archivo llamado, digamos, HolaController.php. Luego lo rellenamos con el esqueleto de un controlador vacío, copiando y pegando de otro controlador existente y eliminando todo lo que no nos haga falta. Este método, obviamente, es lento, farragoso y resulta fácil que comentamos algún error. 2. Con ayuda de artisan. Simplemente, tecleamos este comando en el directorio raíz de nuestra aplicación: ``` $ php artisan make:controller HolaController ``` Y listo. Artisan creará por nosotros el archivo /app/Http/Controllers/HolaController.php y lo rellenará con el esqueleto de un controlador vacío. ### 5.5.2. Artisan y máquinas virtuales Si utilizas Laravel con una máquina virtual (Homestead o Docker), tienes que hacer login en la máquina virtual para poder usar ejecutar los comandos de Artisan. Con Vagrant: ``` $ vagrant ssh ``` Con Docker: ``` $ docker exec -it bash ``` Una vez dentro de la máquina virtual, accede al directorio de tu aplicación y podrás ejecutar cualquier comando de Artisan. ### 5.5.3. Comandos principales de Artisan Si tecleas: ``` $ php artisan list ``` ...obtendrás una lista con todos los comandos de Artisan válidos en tu instalación de Laravel. Esto puede variar según tu versión de Laravel y los componentes que tengas instalados. En un primer momento, necesitarás conocer estos comandos: * php artisan db:migrate --> Para hacer migraciones (crear la estructura de nuestra base de datos). * php artisan db:seed --> Para llenar de datos predefinidos nuestra base de datos. * php artisan make:migration --> Crea una migración (para crear la estructura de la base de datos). * php artisan make:seeder --> Crea un seeder (para rellenar con datos las tablas). * php artisan make:controller --> Para crear un controlador. * php artisan make:model --> Para crear un modelo. * php artisan route:list --> Muestra todas las rutas definidas en el enrutador. ",
    "url": "/laravel/5",
    "relUrl": "/laravel/5"
  },"25": {
    "doc": "5.6 Primeros pasos con Laravel. Hola mundo",
    "title": "5.6 Primeros pasos con Laravel. Hola mundo",
    "content": "## 5.6. Primeros pasos con Laravel: Hola mundo En esta sección vamos a crear nuestra primera aplicación funcional con Laravel: el tradicional \"Hola mundo\". Nos servirá para aprender la dinámica de trabajo con Laravel y para construir un esqueleto de aplicación sobre la que montar algo más grande más adelante. **Crea una clave segura** Ejecuta el comando: ```php php artisan key:generate ``` Esto genera una clave aleatoria y la almacena en el archivo de configuración /.env Es necesaria para hacer conexiones seguras con la aplicación. En versiones recientes de Laravel es obligatorio crearla. **Probando el enrutador** Vamos a empezar probando algo sencillo: capturar una ruta. Edita el archivo /routes/web.php y añade esto: ```php Route::get('/hola', function() { return \"Hola, mundo\"; }); ``` Esto significa que, cuando escribas la ruta \"hola\" en la barra de direcciones del navegador, se ejecutará esta función anónima (también denominadas ***closures***) y, como resultado, se verá el texto \"Hola, mundo\" en la ventana del navegador. Pruébalo en el navegador la dirección: http:///index.php/hola **Enrutar al controlador** Ahora vamos a hacer que la misma ruta de antes provoque la ejecución de una función en un controlador. Edita el enrutador /routes/web.php, sustituye la ruta anterior por esto: ```php Route::get('/hola', 'HolaController@index'); ``` Esto indica al enrutador que, al recibir la ruta \"hola\", se debe ejecutar el método index() del controlador HolaController. Ahora tienes que crear ese controlador: ```php $ php artisan make:controller HolaController ``` Por último edita el controlador /app/Http/Controllers/HolaController.php: ```php public function index() { return \"Hola, mundo\"; } ``` Comprueba que funciona en el navegador: http:///index.php/hola (NOTA IMPORTANTE: desde Laravel 8, para que esto funcione es necesario descomentar la siguiente línea del archivo /app/Providers/RouteServiceProvider.php: // protected $namespace = 'App\\Http\\Controllers'; ) **Cargar una vista en el controlador** Vamos a variar el código anterior para que el método del controlador no produzca la salida HTML directamente, sino que invoque a una vista que genere el HTML. Además, vamos a inyectar en la URL una variable con el nombre del usuario para mostrar cómo se capturan esos valores y cómo se pasan a las vistas. Comenzamos modificando el enrutador /routes/web.php (observa cómo se indica la presencia de una variable en la URL): ```php Route::get('/hola/{nombre}', 'HolaController@show'); ``` Ahora creamos un método show() en el controlador /app/Http/Controllers/HolaController.php ```php public function show($nombre) { $data['nombre'] = $nombre; return view('hola', $data); } ``` Como ves, estamos invocando una vista llamada \"hola\" y le estamos pasando un array con los datos necesarios (el nombre del usuario, en este caso). Esa vista debe crearse en /resources/views/hola.blade.php y puede tener este aspecto: ```html Saludos, {% raw %}{{$nombre}}{% endraw %}. ¿Le apetece una partidita de ajedrez? ``` Puedes probar esta nueva ruta cargando en el navegador la ruta http:///index.php/hola/ProfesorFalken. La respuesta debería ser esta: ``` Saludos, ProfesorFalken. ¿Le apetece una partidita de ajedrez? ``` Recuerda que, desde Laravel 8, el funcionamiento del enrutador ha cambiado. Para conservar compatibilidad hacia atrás, hay que abrir el archivo /app/Providers/RouteServiceProvider.php y descomentar esta línea: ```php // protected $namespace = 'App\\Http\\Controllers'; ``` Hay otras soluciones que [se describen aquí](https://litvinjuan.medium.com/how-to-fix-target-class-does-not-exist-in-laravel-8-f9e28b79f8b4). ",
    "url": "/laravel/6",
    "relUrl": "/laravel/6"
  },"26": {
    "doc": "5.7 Enrutamiento",
    "title": "5.7 Enrutamiento",
    "content": "## 5.7. Enrutamiento Ya sabemos crear una aplicación Laravel simple (como \"Hola, mundo\") y hemos aprendido varias cosas sobre el enrutador. En esta sección, profundizaremos en este componente fundamental de cualquier aplicación web. ### 5.7.1. ¿Qué es el enrutador? El enrutador de Laravel es el componente que captura las URL solicitadas al servidor y las traduce a invocaciones a métodos de los controladores. El enrutador es capaz, además, de mapear fragmentos de la URL a variables PHP que serán inyectadas como parámetros a los métodos del controlador. También puede distinguir el verbo http empleado para solicitar una página al servidor. Es decir, para el enrutador no es lo mismo una solicitud enviada por GET que otra enviada por POST. Incluso admite verbos que aún no están soportados por http, como DELETE o PUT, y que teóricamente van a formar parte de futuras implementaciones del protocolo. ### 5.7.2. Enrutamiento básico Como vimos en el ejemplo del \"Hola, mundo\", hay varias formas de generar una salida HTML desde el enrutador (/routes/web.php). En este código de ejemplo vemos las más básicas: ```php // Forma 1: generar la salida con un closure (función sin nombre) Route::get('/hola', function() { return \"Hola, mundo\"; }); // Forma 2: llamar a un controlador sin pasarle parámetros Route::get('/hola', 'HolaController@show'); // Forma 3: llamar a un controlador pasándole parámetros Route::get('/hola/{nombre}', 'HolaController@show'); // Forma 4: llamar a un controlador con un parámetro optativo Route::get('/hola/{nombre?}', 'HolaController@show'); ``` ### 5.7.3. Rutas con nombre Es MUY recomendable asignar un nombre a las rutas en el enrutador. Esto hace que, más adelante, podamos cambiar la URL de los enlaces sin tener que modificar el código fuente de nuestras vistas. ```php Route::get('/contactame', 'Controlador@contacto')->name('contact'); ``` Internamente, esta ruta se direccionará con la expresión route('contact') (ya veremos exactamente cómo), pero el usuario verá la dirección http://servidor/contactame. En el futuro se puede cambiar la forma en la que lo ve el usuario, pero para el código fuente seguirá siendo route('contact') ### 5.7.4. Verbos http: GET, POST, PUT y DELETE Además de GET, en el enrutador se puede enrutar otras acciones: ```php Route::get(); // Solicitudes habituales Route::post(); // Recepción de datos de formulario (para insert) Route::put|patch(); // Recepción de datos para update Route::delete(); // Recepción de datos para delete Route::match(array('GET','POST'), 'ruta', acción) // Responderá tanto a GET como a POST ``` Los métodos de formulario PUT y DELETE no están soportados aún por http ni por HTML. Hay que emularlos en los formularios así: ```html @method('DELETE') ``` ### 5.7.5. Orden de las rutas El orden de las rutas es importante. Por ejemplo, si pedimos la dirección http:///usuario/crear, estas rutas fallarán: ```php Route::get('usuario/{nombre}', 'UsuarioController@show'); Route::get('usuario/crear', 'UsuarioController@create'); ``` El problema es que tratará de mostrar un contacto con nombre = \"crear\", porque la petición encaja con las dos rutas y el enrutador siempre elegirá la primera ruta que encuentre. La solución pasa por alterar el orden de las líneas en el enrutador: ```php Route::get('usuario/crear', 'UsuarioController@create'); Route::get('usuario/{nombre}', 'UsuarioController@show'); ``` ### 5.7.6. Servidor RESTful Un servidor RESTful es aquel que responde a la [arquitectura REST](https://juanda.gitbooks.io/webapps/content/api/arquitectura-api-rest.html). Típicamente, el enrutador de un servidor RESTful contendrá las 7 operaciones REST para cada recurso accesible desde la red. Por ejemplo, para un recurso llamado \"usuario\", el enrutador tendrá estas 7 entradas: ```php Route::get('user', 'UserController@index')->name('user.index'); Route::get('user/{user}', 'UserController@show')->name('user.show'); Route::get('user/crear', 'UserController@create')->name('user.create'); Route::post('user/{user}', 'UserController@store')->name('user.store'); Route::get('user/{user}/edit', 'UserController@edit')->name('user.edit'); Route::patch('user/{user}', 'UserController@update')->name('user.update'); Route::delete('user/{user}', 'UserController@destroy')->name('user.destroy'); ``` También se puede crear una entrada en el enrutador de este estilo: ```php Route::resource('user'); ``` Esa única ruta engloba a las siete rutas REST. ",
    "url": "/laravel/7",
    "relUrl": "/laravel/7"
  },"27": {
    "doc": "5.8 Vistas y plantillas. Blade",
    "title": "{% raw %}{{$name}}{% endraw %}",
    "content": "Este es el contenido de mi página. @endsection ``` ### 5.8.5. Condiciones en las vistas Blade admite expresiones condicionales para modificar el aspecto de una vista dependiendo del valor de una variable o del estado de la aplicación. En el siguiente ejemplo, el contenido de la vista depende de la variable $day. Controlador: ```php function show() { return view('page',array('name' => 'Manolo','day' => 'Viernes')); } ``` Vista /resources/views/page.blade.php: ```html @extends('layouts.master') @section('title', 'Page Title') @section('sidebar') Esto se añadirá al sidebar del master layout. @endsection @section('content') ",
    "url": "/laravel/8",
    "relUrl": "/laravel/8"
  },"28": {
    "doc": "5.8 Vistas y plantillas. Blade",
    "title": "{% raw %}{{$name}}{% endraw %}",
    "content": "Este es el contenido de mi página. @if ($day == 'Viernes') Hoy me roban el carro . @else Hoy me dedico a cantar . @endif @endsection ``` Observa que esto mismo podría hacerse abriendo y cerrando php (), pero de este modo el código queda mucho más limpio y resulta menos propenso a errores. ### 5.8.6. Bucles en las vistas Igual que existen condiciones, Blade también permite hacer bucles para simplificar la generación de visas. Por ejemplo, en la siguiente vista recorremos un array llamado $bebidas y mostramos su contenido. Controlador: ```php function show() { $bebidas = array('Cerveza','Agua','Zumo'); return view('page',array('name' => 'Manolo','day' => 'Lunes', 'bebidas' => $bebidas)); } ``` Vista /resources/views/page.blade.php: ```html @extends('layouts.master') @section('title', 'Page Title') @section('sidebar') Esto se añadirá al sidebar del master layout. @endsection @section('content') ",
    "url": "/laravel/8",
    "relUrl": "/laravel/8"
  },"29": {
    "doc": "5.8 Vistas y plantillas. Blade",
    "title": "{% raw %}{{$name}}{% endraw %}",
    "content": "Este es el contenido de mi página. @if ($day == 'Viernes') Hoy me roban el carro . @else Hoy me dedico a cantar . @endif ",
    "url": "/laravel/8",
    "relUrl": "/laravel/8"
  },"30": {
    "doc": "5.8 Vistas y plantillas. Blade",
    "title": "Estas son las bebidas disponibles:",
    "content": "@foreach ($bebidas as $bebida) {% raw %}{{$bebida}}{% endraw %} @endforeach @endsection ``` Observa que esto mismo podría hacerse abriendo y cerrando php (), pero de este modo el código queda mucho más limpio y resulta menos propenso a errores. ### 5.8.7. Invocación de funciones PHP Desde una vista Blade se puede invocar cualquier función de PHP sin necesidad de abrirlo y cerrarlo (). Por ejemplo, si necesitamos la función date(), la invocamos así: ```html ",
    "url": "/laravel/8",
    "relUrl": "/laravel/8"
  },"31": {
    "doc": "5.8 Vistas y plantillas. Blade",
    "title": "Ejemplo de llamada a función estándar de PHP",
    "content": "La fecha del servidor es: {% raw %}{{date(' D M, Y')}}{% endraw %} . ``` Esto es mucho más seguro que abrirlo y cerrarlo php () porque filtra posibles ataques XSS. Si alguna vez necesitamos saltarnos la protección contra XSS, debemos usar {% raw %}{!! ... !!}{% endraw %} en lugar de {% raw %}{{ ... }}{% endraw %}. ### 5.8.8. Otras directivas Blade Blade dispone de multitud de directivas para hacer prácticamente cualquier cosa en la vista sin tener que recurrir a PHP. En esta lista mostramos solo las directivas más habituales. - **@section** → Marca el inicio de una sección de contenido. - **@endsection** → Marca el final de una sección. - **@show** → Marca el final de una sección y la muestra. - **@yield('section')** → Muestra el contenido de una sección (si existe, claro). - **@extends('view')** → Hereda de una plantilla padre. - **@parent** → Muestra el contenido de la sección del mismo nombre en la plantilla padre. - **@include('view')** → Incluye una subvista. - **@if | @else | @endif** → Condicional. - **@for | @endfor** → Bucle for clásico. - **@foreach | @endforeach** → Buche foreach. - **@forelse | @empty | @endforelse** → Como foreach, pero con tratamiento de arrays que vienen vacíos. - **@break | @continue** → Para usar en los bucles. - **@switch | @case | @break** → Condicional múltiple. - **@isset($variable) | @endisset** → Comprueba si la variable existe. - **@auth | @endauth** → La sección solo se muestra si hay un usuario autenticado en la aplicación. - **@php | @endphp** → Para añadir código PHP plano. Usar con moderación. - **{% raw %}{{- Comment -}}{% endraw %}** → Comentarios (no serán renderizados). - **{% raw %}{{ $variable }}{% endraw %}** → Equivalente a echo $variable, pero no es necesario abrir y cerrar PHP, y nos protegemos contra inyección de JS. - **{% raw %}{{ $variable ?? texto-por-defecto }}{% endraw %}** → Como el anterior, pero chequea si la variable existe. Si existe, muestra su valor. Si no, muestra texto-por-defecto. - **$loop** → Es una variable muy útil para usar en y/o depurar un foreach. Nos dice si estamos en el primer elemento, en el último, cuántos loops llevamos, etc. ### 5.8.9. Tratamiento de formularios con Blade Blade también facilita el tratamiento de los formularios. En la vista, creamos el formulario (fíjate cómo indicamos la ruta en el action): ```html @csrf Enviar ``` (Recuerda que los métodos PUT y DELETE no existen aún en HTML y que Laravel los simula con un campo oculto en el formulario que se crea con la directiva @method('PUT') o @method('DELETE')) En el enrutador, definimos la ruta \"mi-ruta\" del action del formulario: ```php Route::post('mi-ruta', 'MiControlador@store'); ``` Y, en el controlador, creamos el método store(). Observa cómo recuperamos los datos del formulario a través de la variable $r: ```php public function store(Request $r) { $email = $r->get(\"email\"); $asunto = $r->get(\"asunto\"); ...etc... } ``` Esta es una forma alternativa para el controlador: ```php public function store() { $email = request(\"email\"); $asunto = request(\"asunto\"); ...etc... } ### 5.8.10. Validación de formularios con Blade Otra cosa que Blade facilita muchísimo es la validación de formularios en el lado del servidor. El formulario en nuestra vista quedaría así (observa cómo mostramos los errores -si los hay- con un bucle): ```html @if ($errors->any()) @foreach ($errors->all() as $error) {% raw %}{{ $error }}{% endraw %} @endforeach @endif ...resto del formulario igual... ``` El objeto $errors (disponible en todas las vistas) tiene muchos más métodos útiles que puedes consultar en la documentación de Laravel. Y el controlador quedaría así. Observa cómo definimos varias reglas de validación para campos del formulario: ```php public function store() { request->validate([ 'email' => 'required|email', 'asunto' => 'required' ]); // A partir de aquí, procesar el formulario igual que antes ``` Puedes consultar todas las reglas de validación admitidas en [https://laravel.com/docs/validation](https://laravel.com/docs/validation). Cuando vuelve a cargarse el formulario que contenía un error, suele ser apropiado volver a cargar los datos que el usuario ya había tecleado. A esto se le llama \"repopular\" el formulario, y con Blade se hace así: ```html @if ($errors->any()) @foreach ($errors->all() as $error) {% raw %}{{ $error }}{% endraw %} @endforeach @endif ...resto del formulario igual... ``` ### 5.8.11. Añadir CSS y Javascript a nuestras vistas Laravel ya trae dos archivos (app.css y app.js) basados en Boostrap 4 para empezar a trabajar. Para usarlos, basta con añadir esto a la cabecera de nuestras vistas: ```html | ``` Si queremos añadir reglas CSS, NO debemos editar /public/app.css, porque es un CSS compilado y minimizado con SASS. Lo correcto para añadir nuestro CSS a ese archivo es: 1. Editar /resources/sass/app.css 2. Recompilar este archivo con SASS (o con less o con stylus) ``` $ npm run dev (o también: $ yarn dev) ``` Y, por supuesto, siempre podemos crear nuestro propio CSS y nuestro JS en /public. En ese caso, los archivos no estarían optimizados (tendríamos que hacerlo a mano, si queremos) y serían accesibles de forma pública. El CSS y el JavaScript que vayamos a usar de este modo se pueden colocar en /public/css y /public/js ### 5.8.12. Vistas de error personalizadas Las vistas creadas en /resources/views/errors permiten personalizar fácilmente las pantallas de error HTTP. Por ejemplo, si creas un archivo /resources/views/errors/404.blade.php, esa vista se mostrará cada vez que ocurra un error 404 (página no encontrada) ",
    "url": "/laravel/8",
    "relUrl": "/laravel/8"
  },"32": {
    "doc": "5.8 Vistas y plantillas. Blade",
    "title": "5.8 Vistas y plantillas. Blade",
    "content": "## 5.8. Vistas y plantillas. Blade Blade es un poderoso y sencillo sub-lenguaje que nos permitirá generar plantillas para minimizar el código que necesitamos para nuestras vistas. Las plantillas Blade admiten condiciones y bucles para operar con las variables PHP, de modo que la misma plantilla se comporta de forma diferente con diferentes conjuntos de datos. ¡Y se acabó la pesadilla de abrir y cerrar comillas para concatenar variables a las salidas HTML! Con Blade, ya no será necesario abrir y cerrar php () para operar con las variables del servidor y generar la salida. El código no solo será más limpio y fácil de depurar, sino también más seguro, porque se impiden los ataques con XSS. Además, unas plantillas pueden heredar de otras para reutilizar mejor el código. ### 5.8.1. Master layout El layout es una forma genérica de referirse a un diseño de capas del interfaz de la aplicación. El master layout es el diseño maestro del que derivan todas las vistas. Ese master layout suele almacenarse en un archivo llamado /resources/views/layouts/master.blade.php. Y podría tener, por ejemplo, este aspecto: ```html @yield('Titulo') . @section('sidebar') Este es mi master sidebar. @show @yield('content') . ``` Aquí vemos varias directivas importantes de blade: * @yield('Titulo') --> Esto define una sección llamada 'Título', que en el master layout está vacía. Las vistas que hereden del master layout tendrán que definir cuál es el valor de 'Título', y ese valor aparecerá escrito aquí. * @section('sidebar') --> Esto define una sección llamada 'sidebar' que NO está vacía (contiene el texto \"Este es mi master sidebar\", pero podría contener cualquier otra cosa). Las vistas que hereden del master layout podrán AÑADIR contenido a esta sección. * @show --> Hace que el contenido de la sección se muestre en ese punto del documento. * @yield('content') --> De nuevo, una sección que está vacía en el master layout y cuyo contenido tendrá que definirse en las vistas que hereden de esta. ### 5.8.2. Vistas que heredan del master layout El aspecto de una plantilla que herede del master layout anterior debería ser este: ```html @extends('master') @section('title', 'Titulo de la página') @section('sidebar') Esto se añadirá al master sidebar. @endsection @section('content') Aquí va el contenido de mi página. @endsection ``` * @extends('master') --> Esto indica que esta vista hereda del master layout. * @section('title, 'Título de la página') --> Aquí se define el contenido de la sección 'Título' que en el master layout estaba vacía. * @section('sidebar') --> Aquí añade contenido a la sección 'sidebar', que en el master layout no estaba vacía. * @ensection --> Se emplea cuando el contenido de una sección ocupa varias líneas de código y no es posible escribirlo dentro de la propia directiva. ### 5.8.3. Cómo pasar variables a las vistas Las variables a las vistas deben enviarse empaquetadas en un array. Hay varias formas de lograr esto, todas ellas correctas. Puedes emplear la que te resulte más cómoda o más elegante: ```php return view('vista', array('variable1'=>'valor', 'variable2'=>'valor')); return view('vista', ['variable1'=>'valor', 'variable2'=>'valor']); return view('vista')->with(['variable1'=>'valor', 'variable2'=>'valor']); return view('vista', compact('variable1', 'variable2')); ``` ### 5.8.4. Cómo usar las variables en las vistas Supongamos que tenemos este método en un controlador: ```php function show() { return view('page',array('name' => 'Manolo Escobar')); } ``` La variable $name se puede usar en la vista /resources/views/page.blade.php de este modo: ```html @extends('layouts.master') @section('title', 'Page Title') @section('sidebar') Esto se añadirá al sidebar del master layout. @endsection @section('content') ",
    "url": "/laravel/8",
    "relUrl": "/laravel/8"
  },"33": {
    "doc": "5.9 Controladores",
    "title": "5.9 Controladores",
    "content": "## 5.9. Controladores ### 5.9.1. Cuatro cosas importantes sobre los controladores en Laravel Los controladores en Laravel heredan de la clase Controller. Su nombre debería escribirse en singular, CamelCase y terminando en la palabra Controller. Por ejemplo: UserController, LoginController, ArticleController Cada método del controlador debe terminar en un return. Lo que el método devuelva será convertido automáticamente en una HTTP response 200, excepto si es un array, en cuyo caso se convertirá automáticamente en JSON. Se puede actuar sobre la HTTP response devolviendo esto: ```php return response('contenido', 201) ->header('mi-cabecera', 'contenido') ->header('otra-cabecera', 'más-contenido') ->cookie('mi-cookie', 'valor'); (etc) ``` ### 5.9.2. Tres formas de crear un controlador **Forma 1. Crear un controlador vacío.** Por ejemplo, para crear un controlador para la tabla de usuarios: ``` $ php artisan make:controller UserController ``` **Forma 2. Crear un controlador de tipo resource.** Estos controladores se generan automáticamente con un andamiaje para construir recursos REST. Es decir, la clase ya llevará incorporados los métodos index(), create(), store(), show(), edit(), update() y destroy() del estándar REST. Para crear un controlador así: ``` $ php artisan make:controller UserController --resource ``` No te olvides de de añadir al enrutador (/routes/web.php) las rutas REST para este tipo controlador. Se pueden resumir las siete rutas en esta sola entrada del enrutador: ``` Route::resource('nombreRecurso', 'controlador'); ``` En nuestro ejemplo: ``` Route::resource('usuarios', 'UserController'); ``` **Forma 3. Crear un controlador tipo API.** El controlador tipo API es como un resource, pero sin create() ni edit(), porque una API no necesita mostrar los formularios de inserción/modificación. ``` $ php artisan make:controller UserController --api ``` De nuevo, no te olvides de las entradas en el enrutador. Puedes englobarlas todas en una sola entrada con este aspecto: ``` Route::apiResource('usuarios', 'UserController'); ``` ",
    "url": "/laravel/9",
    "relUrl": "/laravel/9"
  },"34": {
    "doc": "About",
    "title": "About",
    "content": "This is the base Jekyll theme. You can find out more info about customizing your Jekyll theme, as well as basic Jekyll usage documentation at [jekyllrb.com](https://jekyllrb.com/) You can find the source code for Minima at GitHub: [jekyll][jekyll-organization] / [minima](https://github.com/jekyll/minima) You can find the source code for Jekyll at GitHub: [jekyll][jekyll-organization] / [jekyll](https://github.com/jekyll/jekyll) [jekyll-organization]: https://github.com/jekyll ",
    "url": "/about/",
    "relUrl": "/about/"
  },"35": {
    "doc": "Desarrollo Web en Entorno Servidor",
    "title": "Desarrollo Web en Entorno Servidor",
    "content": "Esta es la documentación (apuntes) del módulo de ***Desarrollo Web en Entorno Servidor*** del Ciclo Formativo de Grado Superior de Desarrollo de Aplicaciones Web impartido en el IES Celia Viñas de Almería (España). 1. TOC {:toc} ",
    "url": "/",
    "relUrl": "/"
  }
}
