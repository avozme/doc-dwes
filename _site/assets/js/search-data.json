{"0": {
    "doc": "1 Sistemas gestores de contenido (CMS)",
    "title": "1 Sistemas gestores de contenido (CMS)",
    "content": "# 1. CMS: Sistemas gestores de contenido Vamos a empezar con algo que no tiene nada que ver con la programación: los CMS. Los Sistemas Gestores de Conentido (CMS = Content Management Systems) son aplicaciones web que permiten montar sitios web sin necesidad de programar una sola línea de código. Así que, sí, los CMS son tus enemigos. Y al enemigo hay que conocerlo. Por eso vamos a empezar este curso por aquí. {:toc} ",
    "url": "/cms/",
    "relUrl": "/cms/"
  },"1": {
    "doc": "2.1 Programación cliente-servidor",
    "title": "2.1 Programación cliente-servidor",
    "content": "## 2.1. Programación cliente-servidor {: .no_toc } - TOC {:toc} En los primeros tiempos de Internet, no se ejecutaban programas en el servidor. Solo se pedían páginas estáticas más o menos elaboradas que había sido grabadas en el servidor por un administrador de sistemas. A esto se le denomina web 1.0. A alguien se le ocurrió la idea de que los propios visitantes podrían también crear contenido. Ese contenido se guardaría en el servidor (en archivos o en una base de datos) y posteriormente podría recuperarse para generar con él una web dinámica, que no existía previamente y que nadie, en realidad, ha tecleado. Esa web dinámica estaría generada por un programa ejecutado en el servidor, un programa cuya salida sería HTML válido, comprensible por el navegador que la reciba. A esto se le denomina web 2.0 y supuso una revolución tan grande como el propio nacimiento de Internet. ### 2.1.1. Un poco de jerga informática Antes de continuar, tienes que asegurarte de que comprendes bien el significado de algunos términos: * Un **servidor** es un programa que se ejecuta en una máquina conectada a una red y que permanece dormido hasta que una petición procedente de la red lo despierta. Entonces, el programa hace algo (consulta datos, elabora un cálculo, lo que sea) y devuelve su resultado por la red. * Por extensión, un servidor también es cualquier ordenador donde se ejecute un programa servidor. Es decir, usamos la misma palabra para referirnos a un programa y al ordenador donde se ejecuta ese programa. Mala idea, ya lo sé, pero es lo que hay. * El **cliente** es el programa que envía esas peticiones al programa servidor para despertarlo. También es el programa que recoge el resultado devuelto por el servidor. * Por extensión, la máquina donde se ejecuta un programa cliente también se llama cliente. Pues bien, en programación web, nuestro cliente es el **navegador web** (también llamado cliente web). Cualquier navegador del universo conocido entra en esta categoría (excepto, tal vez, Internet Explorer). Y un servidor es cualquier máquina de la red donde se esté ejecutando un programa servidor web como Apache, Nginx, Tomcat, IIS y otros cuando viejos amigos que irás conociendo a lo largo de este curso. ### 2.1.2. Una petición web en la época 1.0 Ahora que tienes claro qué es un servidor y un cliente web, puedes comprender el siguiente esquema. En él, se ilustra lo que ocurre cuando un cliente web (recuerda: tu navegador) envía al servidor la peiticón de una **página estática**. El servidor, en este caso, se limita a enviar al cliente el documento HTML tal cual está almacenado en su disco duro, sin cambiar una sola coma. ![Ejemplo de servicio www](/assets/images/02-servicio-www-1.jpg) ### 2.1.3. Una petición web en la época 2.0 Con la web 2.0 la cosa cambia bastante porque aparecen las **páginas dinámicas**, aunque tendrás que fijarte bien en el esquema para apreciar la diferencia, ¿verdad? Quédate con lo importante: en este esquema, el cliente web no pide un documento HTML, sino *un programa*, que puede estar escrito en PHP o algún otro lenguaje, eso es lo de menos. Ese programa se ejecuta en el servidor, y *el resultado de esa ejecución* es lo que recibe el cliente, *no el programa en sí*. ![Ejemplo de servicio www](/assets/images/02-servicio-www-2.jpg) Así es como funcionan las aplicaciones web. ",
    "url": "/php/programacion-cliente-servidor",
    "relUrl": "/php/programacion-cliente-servidor"
  },"2": {
    "doc": "2.2 Caja de herramientas",
    "title": "2.2 Caja de herramientas",
    "content": "## 2.2. Caja de herramientas para desarrollar de aplicaciones web {: .no_toc } - TOC {:toc} Para desarrollar apliaciones web necesitamos una caja de herramientas bastante completa. Algunas herramientas son fundamentales, como el martillo o el destornillador de una caja de herramientas convencional. Otras, en cambio, son optativas y dependerán del trabajo que vayamos a realizar y de nuestras propias preferencias como desarrolladores. En esta sección vamos a hacer un repaso de las herramientas fundamentales, las que no pueden faltar en tu caja de herramientas. Algunas ya las conoces y otras las aprenderemos a manejar a lo largo de este curso. Se trata de: * DHTML (HTML, CSS y Javascript) * PHP u otro lenguaje de script de servidor (Python, Ruby, Perl, etc) * MySQL / MariaDB u otro SGBD que permita acceso remoto. ### 2.2.1. HTML DHTML (Dynamic HTML) no es un lenguaje como tal, sino que, como probablemente sabes ya, es la conjunción de tres lenguajes: * HTML * CSS * JavaScript DHTML y PHP son los lenguajes que nos van a permitir ejecutar programas en el servidor y acceder a sus recursos a través de páginas web, pero existen otras posibles combinaciones como: * DHTML con ASP * DHTML con JSP * DHTML con Python, Ruby, Perl, etc. HTML significa \"HyperText Markup Language\" (Lenguaje de Etiquetas de Hipertexto). Como sin duda sabrás, se trata de un lenguaje para formatear documentos: * Permite definir el tipo de letra, tamaño, formato y color de los textos. * Permite insertar imágenes y otro contenido multimedia. * Permite crear listas, tablas, enumeraciones... * Permite crear enlaces entre secciones del mismo documento, o enlaces con otros documentos (hipertexto) HTML **NO** es un lenguaje de programación: no permite programar algoritmos. Pero sí permite incrustar otros lenguajes de programación en su interior, aumentando así su potencia. Los trozos de código embebidos dentro de HTML se denominan ***scripts***. #### Brevísima historia de HTML * En 1990 se crea HTML (procedente de un lenguaje anterior, SGML) junto con la World Wide Web, para formatear los documentos de la www. * Se amplía en sucesivas versiones hasta la 3.0, que no consiguió éxito debido a las limitaciones de los navegadores de la época. * Comienza la guerra de navegadores: Microsoft y Netscape sacan sus propios “dialectos” de HTML y destrozan en estándar. * A partir de HTML 4 se intenta unir las características de los dos, pero el resultado es demasiado complejo. * Se hace evidente que hay que hacer una “limpieza” de HTML * Así surge XHTML, la versión XML de HTML, mucho más estricta y formal, con menos añadidos pero igual de potente. Las versiones actuales de HTML son: * HTML 4.01 transicional: HTML clásico, con todos los elementos del HTML antiguo. En la actualidad está obsoleto, pero aún quedan muchas páginas antiguas que lo utilizan. * HTML 4.01 estricto: también llamado XHTML, no permite usar los elementos HTML desaprobados, tales como definición de formatos. También se considera obsoleto. * HTML5: elimina definitivamente los elementos antiguos del lenguaje e incorpora algunos nuevos para completar la asimilación con XML. Es el estándar actual. * La especificación para HTML6 (o HTML Next) está actualmente en desarrollo. ### 2.2.3. CSS CSS significa \"Cascade Style Sheet\" (Hojas de estilo en cascada). CSS es un lenguaje para la definición de los formatos utilizados en una página web. Sólo permite definir el formato (es decir, el aspecto) de la página, no su contenido. Al definir los formatos en otra parte, se pueden reutilizar a lo largo de una o incluso de varias páginas: si cambiamos la definición CSS del formato, se cambian automáticamente los formatos de todas las páginas que usen esa definición. El objetivo último de CSS es **separar completamente el formato de la página de su contenido**. CSS 2.1 se usaba con HTML 4. CSS3 se usa con HTML5 y se considera el estándar actual. Está soportado universalmente, aunque, como sin duda habrás sufrido en tus carnes, los diferentes navegadores pueden interpretar de forma ligeramente distinta algunas definiciones CSS. ### 2.2.4. Javascript JavaScript es un lenguaje interpretado que puede ser incrustado dentro del código HTML de una página web. El código JavaScript puede interactuar y modificar cualquier parte del documento HTML, por lo que dota a las páginas web de dinamismo e interactividad. **JavaScript no es Java**, por mucho que su nombre se parezca. También su sintaxis puede recordar un poco a Java en algunas ocasiones. Pero déjame que te lo repita de nuevo: Javascript no es Java. La implementación de JavaScript de cada navegador es distinta, obteniéndose resultados que no siempre son iguales, por desgracia para los desarrolladores. Por ejemplo: * V8 = motor JS de Chrome * WebKit = motor JS de Safari * Rhino = motor JS de Mozilla Firefox * WebKit = motor JS de Microsoft Edge ### 2.2.5. PHP PHP es un acrónimo recursivo. Significa “PHP Hypertext Preprocessor” Sí, así es el sentido del humor de los informáticos. Qué le vamos a hacer. Es un lenguaje de programación de propósito general. Junto con librerías como PHP-Qt o PHP-GTK, puedes programar con él cualquier aplicación de escritorio. Pero, por circunstancias más debidas al azar que a otra cosa, se empezó a usar para desarrollo web al comienzo de la web 2.0, y hoy en día se utiliza casi exclusivamente para ese propósito. Cuando se usa en desarrollo web, PHP aparece embebido dentro de documentos HTML. #### Características de PHP * PHP permite conectarse con múltiples bases de datos: MySQL, MariaDB, Oracle, PostgreSQL, SQL Server, DB2, etc. También puede conectar por ODBC. * Se parece mucho a otros lenguajes de tercera generación y orientados a objeto (en particular a C/C++ y, por tanto, a Java). Su curva de aprendizaje para los que ya saben programar es muy plana. #### Brevísima historia de PHP * Surge en 1995 como extensión de CGI (otro lenguaje para acceso a funciones del servidor) * PHP3 (1998) tuvo un gran éxito comercial. * PHP4 (2000) es la versión más extendida (por desgracia): la mayoría de los scripts en PHP que circulan por la red están escritos en esta versión obsoleta. * PHP5 (2004) tiene soporte para orientación a objetos y una biblioteca de clases bastante bien diseñada. Por lo tanto, desde esta versión PHP pasa de ser un lenguaje estructurado (3GL) a ser un lenguaje orientado a objetos. * PHP6 empezó a desarrollarse en 2007 y se canceló en 2014. * PHP7 introdujo novedades menores y estuvo vigente hasta 2020. En el momento de escribi esto (junio de 2021) es la versión dominante en la mayoría de los servidores web. * PHP8 es la última versión (8.0.7 en junio de 2021). Las versiones PHP4 y PHP5 se consideran obsoletas e inseguras. Aún existe soporte para PHP7, pero todas las nuevas aplicaciones se deberían escribir pensando en PHP8. #### Lo nuevo en PHP 8 PHP 8 no tiene demasiadas novedades con respecto a PHP 7, como este no las tenía con respecto a PHP 5. Debes tener en cuenta que el mayor salto evolutivo se produjo entre PHP 4 y PHP 5. A partir de ahí, y para principiantes como nosotros, la cosa no ha cambiado demasiado. Algunas de las novedades más destacables de PHP 8 son: * Mejoras importantes de rendimiento, con la aparición de JIT (Just in Time Compiler), un compilador de PHP que trabaja de forma transparente al programador para incrementar la velocidad de ejecución. * Mejoras menores en el manejo de las clases y métodos abstractos. * Simplificación en la declaración de atributos. * Posibilidad de usar arrays con índices negativos. * Etc #### Ventajas de PHP sobre otros lenguajes * Es un lenguaje libre y abierto. * Es muy eficiente. * Es ejecutable en (casi) cualquier servidor. * Cuenta con una excelente documentación y miles de foros y sitios donde consultar dudas. * La curva de aprendizaje es baja si ya sabes programar. * Existen mogollón de entornos de desarrollo para PHP, para todos los gustos. * Fácil interoperatibilidad con otros sistemas, en particular con bases de datos. * Comunidad muuuy grande. * Aunque llevan décadas diciendo que es un lenguaje moribundo, lo cierto es que sigue siendo líder del mercado de aplicaciones web. #### Inconvenientes de PHP * Fallos de diseño (corregidos en su mayoría a partir de PHP 5), como: * Los métodos para acceso a bases de datos cambian según el SGBD usado. * Nombres de funciones inconsistentes. * No es completamente orientado a objetos. * Tipado confuso y, a veces, impredecible. * Grandes (e incompatibles) cambios entre versiones. * Pérdida lenta pero constante de cuota de mercado. * Pésima relación señal/ruido en la web: ¡hay demasiados *malos* desarrolladores en PHP! ### 2.2.6. MariaDB Otra de las herramientas básicas de nuestra caja de herramientas es el gestor de bases de datos relacionales (SGBD). MySQL / MariaDB es el SGBD líder del mercado de las aplicaciones web. Nos permitirá conectarnos a la base de datos y ejecutar sentencias SQL de forma remota al visitar una aplicación web. Existen otras posibilidades, desde luego, como: * SQL Server * Oracle * PostgreSQL * SQLite También está la posibilidad de usar base de datos no relacionales, como MongoDB, Cassandra o Redis. PHP puede conectarse también a estos sistemas, pero la forma de trabajar es diferente que con bases de datos relacionales. Como estas últimas son, de lejos, las predominantes en el mercado, nos centraremos en ellas. #### Características de MariaDB * MariaDB es un gestor de bases de datos relacional multiusuario y multiplataforma. * Permite mútiples conexiones remotas. * Es software libre. * Existen librerías para acceder a MariaDB desde muchos lenguajes: C/C++, Java, PHP, Perl, Pascal... Además, hay drivers ODBC. * Está muy extendida en aplicaciones web, generalmente en combinación con PHP. * Cuenta un interfaz gráfico programado en PHP, llamado PHPMyAdmin, que se ejecuta en el navegador web. Por supuesto, se puede usar cualquier otro cliente compatible con MySQL, como MySQL Workbench. #### Brevísima historia de MariaDB * MySQL surgió como un proyecto OpenSource en Suecia en 1995. * El objetivo era lograr un SGBD rápido y fiable que cumpliera con el estándar SQL. * Las primeras versiones (que se denominaron mSQL) eran muy ineficientes. * La popularización de PHP y su ganancia en eficiencia a partir de la versión 3 la han hecho muy popular en la actualidad. * Tras su adquisición por Oracle, se intentó relegar al segmento medio-bajo en el mercado de los SGBD y surgió un fork: MariaDB. * Versión más reciente (junio 2021): MariaDB 10.5.10 ",
    "url": "/php/caja-de-herramientas",
    "relUrl": "/php/caja-de-herramientas"
  },"3": {
    "doc": "2.3 Sintaxis de PHP",
    "title": "2.3 Sintaxis de PHP",
    "content": "## 2.3. La sintaxis de PHP {: .no_toc } - TOC {:toc} ### 2.3.1. Cómo embeber PHP dentro de HTML El código PHP se escribe incrustado dentro de un documento de texto mediante estas etiquetas: ```html ``` La sintaxis clásica está obsoleta desde PHP 7: ```html ``` Este archivo debe tener extensión .php. El servidor ejecuta el código PHP que encuentre dentro del archivo, mientras que el código HTML es enviado al cliente sin modificar. ### 2.3.2. Comentarios ```php // Comentario de una línea # Comentario de una línea /* Comentario de una o varias líneas */ ``` ### 2.3.3. Operadores * Operadores: son iguales que los de C/C++: * Asignación: $a = 3; * Comparación: ==, =, !=, , etc. * Operadores aritméticos: +, -, *, /, %... * Operadores lógicos: &&, ||, ! ### 2.3.4. Variables Las variables de una función/clase/método PHP son siempre **locales**, es decir, sólo están disponibles en esa función/clase/método, salvo que se indique otra cosa. Si se definen variables fuera de una función, serán globales a todo el fichero actual, pero no pueden usarse en el código ubicado en otros ficheros. El **identificador** de variable siempre debe empezar por $. Esta es una peculiaridad de PHP que al principio descoloca un poco. No es necesario declararlas: al inicializarlas queda especificado el tipo. A partir de PHP 7 pueden indicarse los tipos predefinidos (int, float, string...) Ejemplos: ```php $a = 4; // Variable entera (PHP 5) int $a = 4; // Variable entera (PHP 7+) $media = 52.75; // Variable real $texto = \"Hoy es lunes\"; // Variable string ``` Cualquier variable puede **cambiarse de tipo** con la función **setType()**: ```php $a = \"10\"; // a es una cadena setType($a, \"integer\"); // a se convierte a entero ``` Los **tipos de datos** predefinidos en PHP son: * integer (entero) * double (real) * bool (booleano) * string (cadena) * array (pues eso) ### 2.3.5. Arrays Los arrays en PHP son colecciones de variables del mismo o de distinto tipo identificadas por un índice. Se parecen más a los ArrayList de Java que a los arrays clásicos propiamente dichos. ```php $a[1] = \"lunes\"; $a[2] = \"martes\"; $a[3] = \"miércoles\"; ``` El índice no tiene por qué ser un número entero: puede ser un String (array asociativo): ```php $a[\"ESP\"] = \"España\"; $a[\"FRA\"] = \"Francia\"; $a[\"POR\"] = \"Portugal\"; ``` ### 2.3.6. Estructuras de control #### Condicionales ```php if (condición) { acciones-1; } else { acciones-2; } ``` #### Bucle while ```php while (condición) { acciones; } ``` #### Bucle repeat ```php do { acciones; } while (condición); ``` #### Bucles for y foreach El bucle for controlado por contador es idéntico a C/C++ y Java: ```php for (inicialización; condición; incremento) { acciones; } ``` Hay una variedad de bucle for muy interesante: el bucle foreach para recorrido de arrays asociativos: ```php foreach ($array as $índice=>$var) { acciones; } ``` El bucle foreach se repite una vez para cada valor guardado en el array. Ese valor se asigna a la variable $var en cada repetición. ### 2.3.7. Funciones y procedimientos Los subprogramas (funciones y procedimientos) se escriben en PHP con la misma palabra: function. * Las **funciones** deben devolver un valor en su última línea con return. Si necesitas devolver varios valores, puedes empaquetarlos en un array. * Los **procedimientos** no tienen return. Realizan su función y terminan. Los **parámetros** de la función en PHP siembre se pasan por valor. Por ejemplo: ```php function calcular_iva($base, $porcentaje) { $total = $base * $porcentaje /100; return $total; } ``` ### 2.3.8. Clases y objetos (¡solo en PHP5 y PHP7!) Las clases, métodos y atributos se declaran de forma muy semejante a C++ y Java: ```php class miClase { // Declaración de propiedades (atributos) public $var = 'soy una variable de clase'; // Método constructor (siempre se llama __construct) public function __construct($valor) { $var = $valor; } // Declaración de métodos public function mostrarVar() { echo $this->var; } private function resetVar() { $this->var = ''; } } ``` Para instanciar un objeto de una clase, se usa la palabra new. El constructor puede llevar parámetros o no, como en Java. Por ejemplo: ```php $miObjeto = new miClase('Estoy aprendiendo PHP'); $miObjeto->mostrarVar(); ``` La salida de este programa sería \"Estoy aprendiendo PHP\". ### 2.3.9. Salida de datos PHP puede hacer salidas de datos como cualquier otro lenguaje de programación: puede enviar texto a una impresora, datos a un fichero o puede dibujar ventanas y componentes en un entorno gráfico de usuario. Pero cuando PHP se ejecuta como parte de una aplicación web, nada de eso tiene sentido: esa salida se produciría en el servidor, y nosotros no estamos allí para verla. Nosotros estamos en nuestro cliente (navegador web), pidiendo al servidor que ejecute un programa PHP. Recuerda que, en este contexto, la salida PHP es siempre código HTML válido. Ese código HTML será recibido por tu navegador, interpretado y mostrado en la ventana del navegador. Observa el uso de \"echo\" para producir una salida HTML desde este pequeño script PHP: ```html esto en negrita\" ?> ``` ### 2.3.10. Paso de parámetros por la URL Las aplicaciones web pueden recibir parámetros a través de la propia URL de invocación del servidor. Imagina que tenemos este link en un documento HTML: ```html ``` Al hacer clic en él, pediremos al servidor que ejecute el programa cuyo código fuente está en el archivo \"pagina.php\", ¿verdad? Pues bien, ese programa \"pagina.php\" puede acceder a las variables \"variable1\", \"variable2\", etc. Esto se hace a traves del array global de PHP **$_GET**, que se indexa con el nombre de las variables. Así: ```php \"; ?> ``` ### 2.3.11. Entrada de datos a través de formulario (1) Como PHP se ejecuta dentro de HTML, sólo puede recibir datos del usuario de la aplicación a través del navegador web. Y sólo hay una forma de introducir datos en una página web: a través de un formulario. Veámoslo con un ejemplo. Supongamos que hemos definido en HTML este sencillo formulario: ```html Nombre Apellidos ``` Al pulsar el botón \"Enviar\", se cargará el script destino.php en el servidor. Ese script recibirá dos variables HTML llamadas nombre y apellido, con el valor que el usuario haya introducido en el formulario. Para acceder a las variables HTML, se usa el array del sistema **$_POST**, indexándolo con el nombre de la variable: ```php \" ?> ``` Observa que $_POST es una variable semejante a $_GET. Puedes utilizar una u otra según el valor del atributo *method* de tu formulario HTML. La variable **$_REQUEST** sirve tanto para POST como para GET. **Por eso será la que nosotros usaremos preferentemente en nuestros programas**. ",
    "url": "/php/sintaxis-de-php",
    "relUrl": "/php/sintaxis-de-php"
  },"4": {
    "doc": "2.4 Interacción con la base de datos",
    "title": "2.4 Interacción con la base de datos",
    "content": "## 2.4. Interacción entre MariaDB y PHP {: .no_toc } - TOC {:toc} A partir de ahora, vamos a referirnos a MySQL/MariaDB indistintamente. Este será el gestor de bases de datos relacionales que vamos a usar a lo largo del curso. La adaptación a otros gestores, en cualquier caso, es muy simple. MySQL/MariaDB es un SGBD profesional, por lo que la interacción con él busca ser eficiente y segura, pero no necesariamente fácil. Hay básicamente tres métodos de utilizar MySQL: * **A través de la línea de comandos:** Iniciamos una sesión en MySQL con: ``` $ mysql -h servidor -u nombre_usuario -p ``` Y luego tenemos a nuestra disposición montones de comandos para hacer cosas con la base de datos, incluyendo cualquier instrucción válida en SQL. * **A través de una aplicación con interfaz gráfico como PHPMyAdmin**, una aplicación web escrita en PHP que proporciona un interfaz muy cómodo para trabajar con MySQL o MariaDB. * **A través de un programa escrito en PHP** o algún otro lenguaje con posibilidad de acceso a MySQL. Este método de acceso será el que nosotros practicaremos a lo largo del curso. Por ahora, vamos a ver lo fundamental. ### 2.4.1. MySQL/MariaDB con PHP4 El modo en que se accedía a bases de datos en PHP4 era mediante bibliotecas de funciones diferentes para cada SGBD. Este tipo de codificación está obsoleta y se desaconseja su uso. Ya no tiene soporte oficial, por lo que no se resolverán futuros problemas de seguridad o estabilidad. **Lo mostramos aquí para que sepáis lo que NO se debe hacer.** **Encontraréis mucho código de esta naturaleza en la red que DEBE SER EVITADO.** #### Acceso a MySQL con PHP4 (¡OBSOLETO!) PHP4 utiliza una biblioteca de funciones PHP cuyo nombre empieza por mysql_. Por ejemplo, para insertar un registro en una BD MySQL, se hacía así: ```php ``` Y para ejecutar consultas (SELECT), se recogía el resultado en un cursor. Observa cómo se hacía en este ejemplo: ```php ... continúa en la pág. siguiente ... Consultas SQL con PHP4 (2/2) ... viene de la pág. anterior ... | Nombre | Teléfono | . | '.$registro[\"nombre\"].' | '; echo ' | '.$registro[\"telefono\"].' | . '; } mysql_free_result($result) ?> ``` **RECUERDA: esta forma de operar con la base de datos está OBSOLETA y DEBE SER EVITADA.** Te la mostramos aquí solo para que sepas reconocerla si te la encuentras por las procelosas aguas de internet. ### 2.4.2. MySQL/MariaDB con PHP5+ Desde PHP5, se utiliza una biblioteca de clases para acceder a los diferentes SGBDs. Todos los nuevos desarrollos deberían usar las bibliotecas de clases y prescindir de las viejas librerías de funciones. *Vuelvo a repetirlo: mucho código de ejemplo de PHP que circula por la red es PHP4 y DEBE SER EVITADO.* #### Conectar a MySQL con PHP5+ Por ejemplo, para insertar un registro en una BD MySQL: ```php query(\"INSERT INTO clientes (nombre,telefono) VALUES ('$nombre','$telefono')\"); ?> ``` PHP proporciona varios mecanismos para acceder a bases de datos (¡demasiadas formas de hacer lo mismo!): * **La extensión mysqli en su forma procedimental.** Es idéntica a la de PHP4, pero cambiando la palabra “mysql” por “mysqli”. Por ejemplo, mysql_connect() cambia a mysqli_connect(). Esta forma es apta para programadores perezosos y anticuados, que no quieren pasarse a la programación orientada a objetos. * **La extensión mysqli en su forma orientada a objetos.** Es la que nosotros estamos usando y usaremos todo el curso. * **La extensión PDO.** Se trata de una clase genérica que permite acceder a cualquier gestor de bases de datos mediante el mismo conjunto de métodos. En funcionalidad y rendimiento es idéntica a mysqli. #### Consultas SQL con PHP5+ La ejecución de consultas (SELECT) produce la devolución de un conjunto de registros. Esos registros se manejan en PHP con un cursor. Observa cómo se hace en este ejemplo: ```html connect_error){ die(\"Error en la conexion : \".$db->connect_error); } //Ejecutamos la consulta SQL $result=$db->query(\"SELECT * FROM Clientes\"); ?> | Nombre | Teléfono | . fetch_array()) { echo ' | '.$registro[\"nombre\"].' | '; echo ' | '.$registro[\"telefono\"].' | . '; } $db->free($result); // Libera memoria usada por cursor $db->close(); // Cierra la conexión con el servidor ?> ``` ",
    "url": "/php/interaccion-con-php",
    "relUrl": "/php/interaccion-con-php"
  },"5": {
    "doc": "2.5 Ejercicios resueltos",
    "title": "Biblioteca",
    "content": "\"; // Buscamos todos los libros de la biblioteca if ($result = $db->query(\"SELECT * FROM libros INNER JOIN escriben ON libros.idLibro = escriben.idLibro INNER JOIN personas ON escriben.idPersona = personas.idPersona ORDER BY libros.titulo\")) { // La consulta se ha ejecutado con éxito. Vamos a ver si contiene registros if ($result->num_rows != 0) { // La consulta ha devuelto registros: vamos a mostrarlos // Primero, el formulario de búsqueda echo \" \"; // Ahora, la tabla con los datos de los libros echo \"\"; while ($fila = $result->fetch_object()) { echo \"\"; echo \" | \" . $fila->titulo . \" | \"; echo \" | \" . $fila->genero . \" | \"; echo \" | \" . $fila->numPaginas . \" | \"; echo \" | \" . $fila->nombre . \" | \"; echo \" | \" . $fila->apellido . \" | \"; echo \" | idLibro . \"'>Modificar | \"; echo \" | idLibro . \"'>Borrar | \"; echo \" . \"; } echo \"\"; } else { // La consulta no contiene registros echo \"No se encontraron datos\"; } } else { // La consulta ha fallado echo \"Error al tratar de recuperar los datos de la base de datos. Por favor, inténtelo más tarde\"; } echo \"Nuevo . \"; break; // --------------------------------- FORMULARIO ALTA DE LIBROS ---------------------------------------- case \"formularioInsertarLibros\": echo \" ",
    "url": "/php/ejercicios-resueltos",
    "relUrl": "/php/ejercicios-resueltos"
  },"6": {
    "doc": "2.5 Ejercicios resueltos",
    "title": "Modificación de libros",
    "content": "\"; // Creamos el formulario con los campos del libro echo \" Título: Género: País: Año: Número de páginas:\"; // Añadimos un selector para el id del autor o autores $result = $db->query(\"SELECT * FROM personas\"); echo \"Autores: \"; while ($fila = $result->fetch_object()) { echo \"idPersona . \"'>\" . $fila->nombre . \" \" . $fila->apellido . \"\"; } echo \"\"; echo \"Añadir nuevo\"; // Finalizamos el formulario echo \" \"; echo \"Volver . \"; break; // --------------------------------- INSERTAR LIBROS ---------------------------------------- case \"insertarLibro\": echo \" ",
    "url": "/php/ejercicios-resueltos",
    "relUrl": "/php/ejercicios-resueltos"
  },"7": {
    "doc": "2.5 Ejercicios resueltos",
    "title": "Alta de libros",
    "content": "\"; // Vamos a procesar el formulario de alta de libros // Primero, recuperamos todos los datos del formulario $titulo = $_REQUEST[\"titulo\"]; $genero = $_REQUEST[\"genero\"]; $pais = $_REQUEST[\"pais\"]; $ano = $_REQUEST[\"ano\"]; $numPaginas = $_REQUEST[\"numPaginas\"]; $autores = $_REQUEST[\"autor\"]; // Lanzamos el INSERT contra la BD. echo \"INSERT INTO libros (titulo,genero,pais,ano,numPaginas) VALUES ('$titulo','$genero', '$pais', '$ano', '$numPaginas')\"; $db->query(\"INSERT INTO libros (titulo,genero,pais,ano,numPaginas) VALUES ('$titulo','$genero', '$pais', '$ano', '$numPaginas')\"); if ($db->affected_rows == 1) { // Si la inserción del libro ha funcionado, continuamos insertando en la tabla \"escriben\" // Tenemos que averiguar qué idLibro se ha asignado al libro que acabamos de insertar $result = $db->query(\"SELECT MAX(idLibro) AS ultimoIdLibro FROM libros\"); $idLibro = $result->fetch_object()->ultimoIdLibro; // Ya podemos insertar todos los autores junto con el libro en \"escriben\" foreach ($autores as $idAutor) { $db->query(\"INSERT INTO escriben(idLibro, idPersona) VALUES('$idLibro', '$idAutor')\"); } echo \"Libro insertado con éxito\"; } else { // Si la inserción del libro ha fallado, mostramos mensaje de error echo \"Ha ocurrido un error al insertar el libro. Por favor, inténtelo más tarde.\"; } echo \"Volver . \"; break; // --------------------------------- BORRAR LIBROS ---------------------------------------- case \"borrarLibro\": echo \" ",
    "url": "/php/ejercicios-resueltos",
    "relUrl": "/php/ejercicios-resueltos"
  },"8": {
    "doc": "2.5 Ejercicios resueltos",
    "title": "Borrar libros",
    "content": "\"; // Recuperamos el id del libro y lanzamos el DELETE contra la BD $idLibro = $_REQUEST[\"idLibro\"]; $db->query(\"DELETE FROM libros WHERE idLibro = '$idLibro'\"); // Mostramos mensaje con el resultado de la operación if ($db->affected_rows == 0) { echo \"Ha ocurrido un error al borrar el libro. Por favor, inténtelo de nuevo\"; } else { echo \"Libro borrado con éxito\"; } echo \"Volver . \"; break; // --------------------------------- FORMULARIO MODIFICAR LIBROS ---------------------------------------- case \"formularioModificarLibro\": echo \" ",
    "url": "/php/ejercicios-resueltos",
    "relUrl": "/php/ejercicios-resueltos"
  },"9": {
    "doc": "2.5 Ejercicios resueltos",
    "title": "Modificación de libros",
    "content": "\"; // Recuperamos el id del libro que vamos a modificar y sacamos el resto de sus datos de la BD $idLibro = $_REQUEST[\"idLibro\"]; $result = $db->query(\"SELECT * FROM libros WHERE libros.idLibro = '$idLibro'\"); $libro = $result->fetch_object(); // Creamos el formulario con los campos del libro // y lo rellenamos con los datos que hemos recuperado de la BD echo \" Título:titulo'> Género:genero'> País:pais'> Año:ano'> Número de páginas:numPaginas'>\"; // Vamos a añadir un selector para el id del autor o autores. // Para que salgan preseleccionados los autores del libro que estamos modificando, vamos a buscar // también a esos autores. $todosLosAutores = $db->query(\"SELECT * FROM personas\"); // Obtener todos los autores $autoresLibro = $db->query(\"SELECT idPersona FROM escriben WHERE idLibro = '$idLibro'\"); // Obtener solo los autores del libro que estamos buscando // Vamos a convertir esa lista de autores del libro en un array de ids de personas $listaAutoresLibro = array(); while ($autor = $autoresLibro->fetch_object()) { $listaAutoresLibro[] = $autor->idPersona; } // Ya tenemos todos los datos para añadir el selector de autores al formulario echo \"Autores: \"; while ($fila = $todosLosAutores->fetch_object()) { if (in_array($fila->idPersona, $listaAutoresLibro)) echo \"idPersona' selected>$fila->nombre $fila->apellido\"; else echo \"idPersona'>$fila->nombre $fila->apellido\"; } echo \"\"; // Por último, un enlace para crear un nuevo autor echo \"Añadir nuevo\"; // Finalizamos el formulario echo \" \"; echo \"Volver . \"; break; // --------------------------------- MODIFICAR LIBROS ---------------------------------------- case \"modificarLibro\": echo \" ",
    "url": "/php/ejercicios-resueltos",
    "relUrl": "/php/ejercicios-resueltos"
  },"10": {
    "doc": "2.5 Ejercicios resueltos",
    "title": "Modificación de libros",
    "content": "\"; // Vamos a procesar el formulario de modificación de libros // Primero, recuperamos todos los datos del formulario $idLibro = $_REQUEST[\"idLibro\"]; $titulo = $_REQUEST[\"titulo\"]; $genero = $_REQUEST[\"genero\"]; $pais = $_REQUEST[\"pais\"]; $ano = $_REQUEST[\"ano\"]; $numPaginas = $_REQUEST[\"numPaginas\"]; $autores = $_REQUEST[\"autor\"]; // Lanzamos el UPDATE contra la base de datos. $db->query(\"UPDATE libros SET titulo = '$titulo', genero = '$genero', pais = '$pais', ano = '$ano', numPaginas = '$numPaginas' WHERE idLibro = '$idLibro'\"); if ($db->affected_rows == 1) { // Si la modificación del libro ha funcionado, continuamos actualizando la tabla \"escriben\". // Primero borraremos todos los registros del libro actual y luego los insertaremos de nuevo $db->query(\"DELETE FROM escriben WHERE idLibro = '$idLibro'\"); // Ya podemos insertar todos los autores junto con el libro en \"escriben\" foreach ($autores as $idAutor) { $db->query(\"INSERT INTO escriben(idLibro, idPersona) VALUES('$idLibro', '$idAutor')\"); } echo \"Libro actualizado con éxito\"; } else { // Si la modificación del libro ha fallado, mostramos mensaje de error echo \"Ha ocurrido un error al modificar el libro. Por favor, inténtelo más tarde.\"; } echo \"Volver . \"; break; // --------------------------------- BUSCAR LIBROS ---------------------------------------- case \"buscarLibros\": // Recuperamos el texto de búsqueda de la variable de formulario $textoBusqueda = $_REQUEST[\"textoBusqueda\"]; echo \" ",
    "url": "/php/ejercicios-resueltos",
    "relUrl": "/php/ejercicios-resueltos"
  },"11": {
    "doc": "2.5 Ejercicios resueltos",
    "title": "Resultados de la búsqueda: \\\"$textoBusqueda\\\"",
    "content": "\"; // Buscamos los libros de la biblioteca que coincidan con el texto de búsqueda if ($result = $db->query(\"SELECT * FROM libros INNER JOIN escriben ON libros.idLibro = escriben.idLibro INNER JOIN personas ON escriben.idPersona = personas.idPersona WHERE libros.titulo LIKE '%$textoBusqueda%' OR libros.genero LIKE '%$textoBusqueda%' OR personas.nombre LIKE '%$textoBusqueda%' OR personas.apellido LIKE '%$textoBusqueda%' ORDER BY libros.titulo\")) { // La consulta se ha ejecutado con éxito. Vamos a ver si contiene registros if ($result->num_rows != 0) { // La consulta ha devuelto registros: vamos a mostrarlos // Primero, el formulario de búsqueda echo \" \"; // Después, la tabla con los datos echo \"\"; while ($fila = $result->fetch_object()) { echo \"\"; echo \" | \" . $fila->titulo . \" | \"; echo \" | \" . $fila->genero . \" | \"; echo \" | \" . $fila->numPaginas . \" | \"; echo \" | \" . $fila->nombre . \" | \"; echo \" | \" . $fila->apellido . \" | \"; echo \" | idLibro . \"'>Modificar | \"; echo \" | idLibro . \"'>Borrar | \"; echo \" . \"; } echo \"\"; } else { // La consulta no contiene registros echo \"No se encontraron datos\"; } } else { // La consulta ha fallado echo \"Error al tratar de recuperar los datos de la base de datos. Por favor, inténtelo más tarde\"; } echo \"Nuevo . \"; echo \"Volver . \"; break; // --------------------------------- ACTION NO ENCONTRADA ---------------------------------------- default: echo \" ",
    "url": "/php/ejercicios-resueltos",
    "relUrl": "/php/ejercicios-resueltos"
  },"12": {
    "doc": "2.5 Ejercicios resueltos",
    "title": "Error 404: página no encontrada",
    "content": "\"; echo \"Volver\"; break; } // switch ?> . ``` ``` ",
    "url": "/php/ejercicios-resueltos",
    "relUrl": "/php/ejercicios-resueltos"
  },"13": {
    "doc": "2.5 Ejercicios resueltos",
    "title": "2.5 Ejercicios resueltos",
    "content": "## 2.5. Ejercicios resueltos de PHP {: .no_toc } - TOC {:toc} En esta sección vamos a mostrar algunos ejemplos sencillos de aplicaciones web muy, muy básicas programadas con PHP. La última de ellas incluye un acceso a una base de datos. Mira con detenimiento el código y asegúrate de entenderlo. Para empezar a programar con PHP, no hay nada mejor que echar un vistazo a algunos programas fáciles que luego puedas utilizar como plantilla para los tuyos. ### 2.5.1. Tabla de multiplicar Vamos a escribir un programa en PHP que pida un número al usuario y muestre su tabla de multiplicar hasta el 25 en una tabla HTML de 5 por 5 casillas. En la siguiente solución utilizaremos un solo archivo para implementar tanto el formulario HTML como la recogida de datos del formulario más el cálculo de la tabla de multiplicar. Observa como se usa la función isset() para averiguar si estamos enviando los datos del formulario o si, por el contrario, acabamos de lanzar la aplicación y tenemos que mostrar ese formulario al usuario. ```html . Introduce un número: \"; } else { // Ya tenemos número pasado por GET. Vamos a procesarlo. $n = $_REQUEST[\"numero\"]; echo \"\"; echo \" | Tabla de multiplicar del número $n | . \"; echo \"\"; for ($i = 1; $i \"; echo \" | $n x $i = \" . $n * $i . \" | \"; } echo \" . \"; echo \"\"; } ?> . ``` ### 2.5.2. Juego del número secreto Vamos a escribir una aplicación web en PHP para jugar al número secreto. El juego consiste en lo siguiente: el ordenador \"pensará\" un número al azar entre 1 y 100 y el jugador tendrá que averiguarlo. Cada vez que el jugador haga un intento, la aplicación le indicará si el número secreto es mayor o menor que el número introducido. Cuando el jugador por fin acierte, la aplicación le dará la enhorabuena y le indicará cuántos intentos ha necesitado para averiguar el número secreto. Vamos a ver dos soluciones para este programa. En la primera, utilizaremos variables de la URL para mantener vivos los datos del programa. En la segunda, utilizaremos variables de sesión para lograr el mismo efecto de forma mucho más limpia. #### Juego del número secreto: solución sin variables de sesión Este juego necesita que algunas variables, como el número secreto (variable $aleatorio) o el número de intentos (variable $intentos) persistan entre una solicitud al servidor y la siguiente. Para lograrlo, haremos que el script se envíe a sí mismo el valor de esas variables. Es una solución poco elegante que se dejó de usar hace años, pero que ilustra perfectamente cuál es el primer problema al que nos enfrentamos al desarrollar aplicaciones web: que se ejecutan en el servidor \"a tirones\", un trozo cada vez, y para el servidor cada uno de esos trozos es un programa independiente, aunque el usuario tenga la sensación de que forman una aplicación coherente. ```html . Adivina mi número: \"; } else { $n = $_REQUEST[\"numero\"]; $aleatorio = $_REQUEST[\"aleatorio\"]; $intentos = $_REQUEST[\"intentos\"]; $intentos++; echo \"Tu número es: $n\"; if ($n > $aleatorio) { echo \"Mi número es MENOR\"; } else if ($n ENHORABUENA, HAS ACERTADO . \"; echo \"Has necesitado $intentos intentos\"; } echo \"Sigue jugando...\"; } ?> ``` #### Juego del número secreto: solución con variables de sesión En esta solución, se ha sustituido la chapuza de las variables pasadas por URL por **variables de sesión**. Aunque las veremos con más detalle en el siguiente tema, te puedo adelantar que las variables de sesión permiten almacenar datos persistentes entre sucesivas ejecuciones de scripts desde el mismo cliente. Es decir, el servidor **recuerda** el valor de determinadas variables para que ese programa ejecutado a tirones se comporte como un todo unificado de cara al usuario. Observa detenidamente cómo se usan las variables de sesión con PHP mediante el array global $_SESSION. ```html . Adivina mi número: \"; } else { $n = $_REQUEST[\"numero\"]; $aleatorio = $_SESSION[\"aleatorio\"]; $intentos = $_SESSION[\"intentos\"]; $intentos++; echo \"Tu número es: $n\"; if ($n > $aleatorio) { echo \"Mi número es MENOR\"; echo \"Sigue jugando...\"; } else if ($n Sigue jugando...\"; } else { echo \"ENHORABUENA, HAS ACERTADO . \"; echo \"Has necesitado $intentos intentos\"; $intentos = 0; unset($_SESSION[\"aleatorio\"]); echo \"Jugar de nuevo\"; } $_SESSION[\"intentos\"] = $intentos; } ?> . ``` ### 2.5.3. Biblioteca Este es un ejemplo muy importante por dos razones: 1. Porque es nuestra primera aplicación web \"de verdad\", con una base de datos detrás 2. Porque volveremos sobre ella varias veces para hacerle sucesivas mejoras, hasta dejarla presentable. Se trata de escribir una aplicación web en PHP que gestione (de forma muy simplificada) una biblioteca. La aplicación trabajará con una base de datos compuesta de solo dos tablas (ya te dije que estaría muy simplificada): libros y autores. Esta aplicación nos permitirá, en principio, ver la lista de todos los libros disponibles, así como dar de alta libros nuevos y modificar o borrar los libros existentes. De momento no trabajaremos con los autores, pero sería fácil extenderla para que también nos dejase hacer altas, bajas y modificaciones de los autores. Lee este código con especial atención (aunque sea un poco largo), y observa como utilizamos una variable muy especial llamada $action para saber qué tiene que hacer la aplicación en cada momento. Esa variable es el germen de la arquitectura modelo-vista-controlador con la que trabajaremos una y otra vez más adelante. ```php . <?php $db = new mysqli(\"localhost:3386\", \"root\", \"bitnami\", \"biblioteca\"); if (isset($_REQUEST[\"action\"])) { $action = $_REQUEST[\"action\"]; } else { $action = \"mostrarListaLibros\"; // Acción por defecto } switch ($action) { // --------------------------------- MOSTRAR LISTA DE LIBROS ---------------------------------------- case \"mostrarListaLibros\": echo \" ",
    "url": "/php/ejercicios-resueltos",
    "relUrl": "/php/ejercicios-resueltos"
  },"14": {
    "doc": "2 Introducción a PHP",
    "title": "2 Introducción a PHP",
    "content": "# 2. Introducción a PHP En este capítulo vamos a conocer la sintaxis básica de PHP y cómo este lenguaje trabaja en el lado del servidor para ayudarnos a crear aplicaciones web dinámicas, es decir, aplicaciones que generan un HTML distinto según los datos de entrada. También conoceremos el kit de herramientas básico que vamos a necesitar para convertirnos en desarrolladores/as web y nos conectaremos a una base de datos remota para enviar y recuperar información. Por último, veremos algunos ejemplos de aplicaciones web sencillas que puedes utilizar como base para tus propios desarrollos. {:toc} ",
    "url": "/php/",
    "relUrl": "/php/"
  },"15": {
    "doc": "3 Cookies, sesiones y seguridad",
    "title": "3 Cookies, sesiones y seguridad",
    "content": "# 3. Cookies, sesiones y seguridad ## 3.1. Autenticación mediante ACL Casi todas las aplicaciones web incluyen un subsistema de autenticación de usuarios (ACL = Access Control List). Ese subsistema suele estar basado en este diseño de base de datos: ![Tablas ACL](/assets/images/03-acl.jpg) Esto significa que necesitamos **cinco tablas** para implementar un ACL completo. Sin embargo, la mayor parte de las veces tendremos suficiente con solo tres tablas (usuarios, roles y usuarios-roles), o incluso solo con una (usuarios, añadiendo quizá un campo \"tipo\"). Optar por una solución más o menos compleja dependerá del tipos de sistema que estemos implementando. En cualquier caso, es conveniente que conozcas el esquema ACL completo (5 tablas) para que lo pongas en práctica cuando lo necesites. ## 3.2. Cookies ### 3.2.1. ¿Qué son las cookies? Las cookies son pequeños archivos de texto enviados desde el servidor que se almacenan en el lado del cliente. Permiten guardar información de forma persistente, de manera que se mantenga entre una petición al servidor y otra. Una cookie puede durar minutos, horas, días o incluso indefinidamente. PHP soporta cookies de forma transparente. Se pueden configurar Cookies usando las funciones setcookie() o setrawcookie() y el array global $_COOKIE. ### 3.2.2. Manejando cookies con PHP #### Enviar una cookie: setcookie() Esta función define una cookie que se enviará al cliente junto con el resto de las cabeceras de HTTP. Devuelve *true* si la cookie se envía con éxito o *false* en caso contrario. Su sintaxis es: ```php bool setcookie ( string $name [, string $value [, int $expire = 0 [, string $path [, string $domain [, bool $secure = false [, bool $httponly = false ]]]]]] ) ``` Las cookies deben enviarse antes de que el script genere ninguna salida. Esto es una restricción del protocolo http. Por lo tanto, debes llamar a esta función antes de hacer *cualquier* salida, incluidos espacios en blanco. En caso contrario, la cookie no estará disponible hasta que la página se recargue. La función setcookie() admite un montón de parámetros, la mayor parte de ellos optativos: * **name**: El nombre de la cookie. Este es el único obligatorio. * **value**: El valor de la cookie. * **expire**: El tiempo que la cookie tardará en expirar. Se trata de una fecha expresada en formato Unix. * **path**: La ruta del servidor para la que la cookie estará disponible. Si se utiliza '/', la cookie estará disponible en la totalidad del dominio. * **domain**: El dominio para el cual la cookie está disponible. * **secure**: Si la cookie solo debería enviarse en caso de conexión https, pon este argument a *true*. * **httponly**: Esta cookie solo será accesible a través de http. Es decir, no podrá utilizarse desde Javascript. Aquí tienes tres ejemplos de envío de la misma cookie: ```php ``` #### Recuperar una cookie: $_COOKIES[] Para ver el contenido de una cookie, simplemente hay que acceder al array global $_COOKIES. Por ejemplo: ```php ``` #### Borrar una cookie Para forzar el borrado de una cookie en el cliente basta con enviarla con una fecha de expiración anterior a la fecha actual. Por ejemplo: ```php ``` ## 3.3. Sesiones Las sesiones en PHP habilitan un mecanismo para que un script almacene variables (llamadas **variables de sesión**) en el servidor de manera persistente, de modo que posteriores peticiones de scripts procedentes de un cliente puedan acceder a esas variables. Cada cliente tiene su propio espacio de variables de sesión en el servidor, de manera que no se mezclan unas con otras, ni un cliente puede acceder a las variables de otro cliente. La forma en la que PHP logra distinguir a los clientes entre sí es enviándoles una cookie con un valor aleatorio diferente para cada cliente. En el archivo php.ini se puede configurar la manera en la que PHP almacenará las variables de sesión (en memoria, en un fichero, etc), pero esto es irrelevante de cara a su funcionamiento y compete más al administrador del sistema que al programador. Lo que a nosotros nos interesa es aprender a crear variables de sesión, asignarles valor y recuperarlo posteriormente. ### 3.3.1. Abrir sesiones: session_start() Antes de acceder a cualquier variable de sesión (ya sea para crearla, para modificarla o para eliminarla) necesitamos indicarle a PHP que queremos usar variables de sesión en ese scrpit. La función **session_start()** se usa para eso: habilita el acceso a las variables de sesión, es decir, crea una nueva sesión o reanuda una sesión preexistente. Las sesiones admiten un nombre, por si necesitas crear sesiones separadas para el mismo cliente. No obstante, la mayor parte de las veces te bastará con crear sesiones sin nombre, sin necesidad de pasar ningún argumento a session_start(). ### 3.3.2. Usar variables de sesión: $_SESSION Las variables de sesión se manipulan a través del array superglobal **$_SESSION**. Si necesitas una variable de sesión llamada, por ejemplo, nombre_usuario, simplemente haz esto: ```php session_start(); $_SESSION['nombre_usuario'] = \"lo-que-sea\"; ``` Por supuesto, el valor de esa posición del array $_SESSION puede consultarse o modificarse cuando lo necesitemos. ### 3.3.3. Eliminar variables de sesión: unset() y session_destroy() La función **unset()** se utiliza para destruir cualquier variable, incluidas las de sesión: ```php unset($_SESSION['nombre_usuario']); ``` Si lo que deseas es destruir todas las variables de sesión, es preferible recurrir a **session_destroy()**. Ahora bien, session_destroy() destruye la información asociada a la sesión actual, pero no elimina realmente las variables de la memoria del servidor ni borra la cookie de sesión del cliente. Para asegurarte de destruir todas las variables de sesión, puedes usar la función **session_unset()**. Y, para borrar la cookie de sesión, debes usar **setcookie()**, como en este ejemplo: ```php ``` ## 3.4. Sesiones, cookies y seguridad Cookies y variables de sesión se usan a menudo para controlar la seguridad de la aplicación web. Por ejemplo, tras el login, el ID del usuario puede almacenarse en: * **Una cookie**. Si existe esa cookie, significa que el login ha sido correcto y la aplicación puede continuar. * **Una variable de sesión**. Si existe determinada variable (por ejemplo, una con el id del usuario), el login ha sido correcto. Cuando el usuario abandona la aplicación, el programa debe destruir la cookie o cerrar la sesión. Pues bien: **ninguno de estos métodos es completamente seguro**. Las cookies pueden rastrearse o modificarse en el ordenador del cliente. Además, algunos clientes las tienen desactivadas. ¡No te puedes fiar de ellas! Las variables de sesión, en principio más seguras, pueden ser atacadas capturando el ID de sesión, como veremos más adelante. El método más seguro, y el más complicado de programar, es el que combina: * Cookies y/o variables de sesión. * Variables guardadas en una tabla de la BD. El uso de frameworks solventes (como los que veremos este curso) hace innecesario tomarse este trabajo, puesto que todos habilitan un mecanismo de sesiones seguras que mejora notablemente las prestaciones de las sesiones nativas de PHP. ## 3.5. Técnicas de ataque frecuentes (Esta sección está adaptada de [securitybydefault.com](securitybydefault.com)) Uno de los fallos más graves y más frecuentes a la hora de escribir aplicaciones PHP es olvidarse de la seguridad. Cualquier aplicación web, por el mero hecho de estar abierta a recibir información procedente de la red, es susceptible de ser atacada. Y te aseguro que, antes o después, cualquier aplicación que está online acaba por ser atacada. Es una certeza matemática. En esta sección vamos a describir qué tipos de ataque son los más frecuentes. Aunque proporcionaremos algunas estrategias de defensa (que debes tener en cuenta en tus desarrollos), hay una estrategia común a todos estos ataques: utilizar un framework potente como Laravel, Symfony o Zend, debidamente actualizado. Los mecanismos de seguridad que implementan estos frameworks son suficientes para la mayor parte de los casos y se mejoran cada vez que se descubre una vulnerabilidad. ### 3.5.1. Captura de ID de sesión Como ya hemos visto, el ID de sesión se guarda como una cookie en el cliente. Por lo tanto, viaja en el paquete http desde el servidor hasta el cliente. Un atacante que esté escuchando en esa red puede **leer el ID de sesión del paquete http** y, de ese modo, **suplantar la identidad** de la persona que inició la sesión. También puede inyectar Javascript a su víctima para capturar de ese modo el ID de sesión, con idénticos resultados. Soluciones: * Combinar las variables de sesión con cookies o con entradas en la base de datos. * Cambiar el ID de sesión periódicamente. * No confiar en variables de sesión de PHP para almacenar información muy sensible. * Denegar el acceso a la cookie de sesión desde Javascript (usando el atributo httponly). * Acceder solo a webs que usen https, no http. De ese modo, la cookie de sesión viaja encriptada hasta el navegador. ### 3.5.2. Inyección de SQL Este ataque consiste en que **un usuario malintencionado ejecuta sentencias SQL contra la base de datos** del sitio web insertándolas en un formulario. Por ejemplo, si un atacante supone que nuestra tabla de usuarios se llama *users* (una suposición muy razonable), podría inyectar SQL en el formulario de login. Imaginemos un formulario de login donde se introduzcan el *nick* del usuario y la contraseña. El atacante nos atacaría escribiendo algo como esto en el campo *nick*: ``` nada'; DELETE * FROM users; # ``` Imagina lo que pasaría si esta cadena se enviase sin filtrar a una variable php (por ejemplo, $nick) y se lanzase una consulta más o menos así: ``` $sql = \"SELECT * FROM users WHERE nick = '$nick' and passwd = '$pass'\"; ``` ¿Te lo ha imaginado ya? Lo que sucedería es que, al expandir la varible $nick en ese string, se obtendría esta concatenación de sentencias sql: ``` SELECT * FROM users WHERE nick ='nada'; DELETE * FROM users; #'and passwd = '$pass' ``` Cuando el gestor de base de datos reciba esas sentencias, las ejecutará en orden. El primer SELECT no devolverá ningún resultado, pero es sintácticamente correcto y, en cualquier caso, al atacante no le interesan esos resultados. Luego ejecutará el DELETE y ¡bingo! El simpático atacante acaba de cepillarse nuestra tabla de usuarios. (La tercera línea se ignorará, porque empieza por un símbolo de comentario). El atacante no solo puede ejecutar un DELETE, sino que puede llevar a cabo otras acciones destructivas (¿qué tal un DROP DATABASE?) o instrusivas (puede intentar insertar un usuario administrador fraudulento en la tabla users). Y todo ello partiendo de una suposición bastante plausible: que la tabla de usuarios se llama *users*. Para blindarse frente a inyecciones de SQL, se recomienda: * **Filtrar los datos. SIEMPRE**. Por ejemplo, si tenemos en nuestro formulario un campo *username* y sabemos que los usuarios sólo pueden estar compuestos por letras y números, no se deben permitir caracteres como comillas, puntos y coma, asteriscos, etc. * **Escapar los caracteres especiales** de cualquier dato de entrada antes de enviarla al gestor de bases de datos. Por ejemplo, mysql_real_escape_string() coloca barras invertidas antes de ciertos caracteres. addslashes() hace algo parecido. En las versiones recientes de PHP, el escape de caracteres especiales se hace automáticamente con cualquier dato que llegue por GET o POST. * **Usar nombres poco habituales para las tablas** de la base de datos. Una estrategia frecuente es utilizar un identificador significativo (como *users* para la tabla de usuarios) y añadirle varios caracteres o números aleatorios (así, la tabla se convertiría en algo como *users_58283*). Ese sufijo aleatorio se suele almacenar en un archivo de configuración para que esté accesible para todos los scripts del programa. ### 3.5.3. XSS (cross site scripting) El ataque por XSS consiste **ejecutar código de scripting malicioso** (básicamente, Javascript) en el contexto del sitio web. Hay muchas formas de hacer XSS. Por ejemplo, imagínate que tenemos un portal tipo blog de noticias, y que un usuario malicioso publica, dentro del texto de una entrada, este string: ```javascript ``` ¿Qué ocurriría? Pues que cada vez que alguien visite nuestro portal y cargue esa noticia, será redirigido a otrosition.com, donde probablemente pretenderán vendernos medicamentos de dudosa procedencia o algo por el estilo. Otra cosa que suele hacerse con XSS es robar datos de las cookies del cliente. Para ello, el atacante solo tiene que inyectar un código como este: ```javascript ``` Para evitar los ataques XSS, la estrategias más útil, otra vez, es **filtrar todos los datos externos**. El filtrado de datos es la práctica más importante que se puede adoptar: nunca te fíes de ningún dato que provenga de un formulario. ### 3.5.4. CSRF o XSRF (cross site request forgery) Este tipo de ataques **explota la confianza que tiene un sitio web en la identidad de un usuario**. Es decir, se toma a un usuario válido registrado en un sitio (por ejemplo, sitio-confiable.com) y, desde otro sitio (por ejemplo, sitio-maligno.com) se le fuerza a hacer algo chungo en sitio-confiable.com. Veámoslo con un ejemplo. Supón que eres un usuario administrador en sitio-confiable.com. Para borrar a un usuario de tu web (o cualquier otro recurso), lanzas una URL como https://sitio-confiable.com/usuario/delete/28 (donde 28 es el id del usuario). Pues bien, imagina que has abierto una sesión como administrador en sitio-confiable.com y, sin cerrarla, navegas por otra web llamada sitio-maligno.com. Y un atacante súpermalvado, conocedor de tu propensión a navegar por sitios chungos sin cerrar la sesión en sitio-confiable.com, ha colocado este código como parte del código fuente de sitio-maligno.com: ```html ``` Cuando tu navegador cargue esa página, lanzará una petición GET a sitio-confiable.com, resultando en la eliminación del usuario 28 sin que tú te enteres de cómo ha podido suceder semejante desgracia. Esto es solo un ejemplo. Por supuesto, el atacante puede hacer un montón de cosas desagradables en sitio-confiable.com, porque ese sitio está confiando en ti, que eres un usuario legímito. Algunas técnicas para dificultar el ataque por CSRF: * **Utilizar POST en lugar de GET** para recibir datos. * **Generar tokens únicos para cada petición**. Un tóken es una cadena alfanumérica aleatoria generada por el servidor cuando sirve el código HTML de un formulario. El cliente debe enviar de vuelta ese tóken junto con los datos del formulario para que el servidor acepte la petición como válida. Si un atacante intenta efectuar un ataque CSRF, enviará sus peticiones sin el tóken y serán rechazadas. ### 3.5.5. DT (directory transversal) Este ataque se produce cuando el atacante logra **acceder a ficheros del servidor que están fuera del directorio de la aplicación** y que, teóricamente, no deberían ser accesibles desde esta. Es fácil comprender cómo puede montarse un ataque así. Imagina un programa PHP que haga un include de este estilo: ```php include (\"views/\" . $viewName); ``` Si un atacante logra manipular la variable $viewName para asignarle, por ejemplo, el valor \"../../../../otro-fichero.php\", nuestro programa hará un include de un fichero que está claramente fuera de los directorios de la aplicación. Para evitar este tipo de ataques, algunas estrategias son: * **Tener un array de páginas válidas**. Si un include trata de usar un fichero que no está en la lista, se sospechará de un ataque. * **Buscar caracteres sospechosos en los nombres de los archivos**. Si la variable *$viewName* del ejemplo anterior incluye los caracteres \"../\", la cosa se pone fea. No en vano, el ataque Directory Transversal también se denomina \"ataque punto punto barra\". ### 3.5.6. RFI (remote file inclusion) Este ataque se produce cuando **se incluye un archivo remoto** explotando una vulnerabilidad del código fuente. Imagina, como antes, un programa PHP que haga un include tan común como este: ```php include (\"views/\" . $viewName); ``` Imagina también que este código se invoque mediante una petición del estilo: https://sitio-confiable.com?view=main.php, algo perfectamente posible. Pues bien, un atacante puede hacer lo siguiente: https://sitio-confiable.com?view=https://sitio-malicioso/soy-un-script-malvado.php De ese modo, la aplicación cargará el código soy-un-script-malvado.php y lo ejecutará en el servidor sitio-confiable.com. Este código puede entonces hacer cosas terribles, como esta: ```php ``` (No te digo lo que hace por si se te ocurre probarlo) Para prevenir los ataques por RFI, algunas estrategias válidas son: * **No confiar en los datos** que no provengan de nuestro sistema. * **Validar y filtrar los datos** que introduce el usuario (sí, otra vez: validar, validar y validar cualquier cosa que provenga del usuario). ",
    "url": "/cookies-sesiones-seguridad/",
    "relUrl": "/cookies-sesiones-seguridad/"
  },"16": {
    "doc": "4 Arquitectura MVC",
    "title": "Listado de Artículos",
    "content": "| Fecha | Titulo | . fetch_array()) { echo \"\"; echo \" | \".$fila['fecha'].\" | \"; echo \" | \".$fila['titulo'].\" | \"; echo \" . \"; } echo \"\"; // Cerramos la conexión con la BD $db->close(); ?> ``` Esta solución se denomina **monolítica**, porque incluye todo el código necesario en el mismo bloque. Por supuesto, para un ejemplo tan simple como este, el código monolítico es más que suficiente, pero en un sistema más complejo pronto empieza a convertirse en un monstruo inmanejable. ### 4.5.2. Primera mejora: controlador + vista Vamos a aproximarnos un poco a la solución MVC separando ese código monolítico en dos bloques (que guardaremos en archivos distintos): * Un controlador. * Una vista. Primero, el **controlador**. Se encargará de recuperar los datos, pero *no de mostrarlos*. Generar el interfaz de usuario, es decir, el HTML, será la labor que le dejaremos a la vista. El controlador preparará esos datos y los empaquetará en un array para que estén disponibles en la vista. Y la vista la insertaremos en el controlador con un include(). ```php query('SELECT fecha, titulo FROM articulo'); $articulos = array(); while ($fila = $resultado->fetch_array()) { $articulos[] = $fila; } $db->close(); include('vista.php'); ?> ``` La **vista** que mostrará los datos del array contiene un código muy semejante al de la solución monolítica, solo que ahora estará ubicada en un archivo aparte, llamado vista.php, y hará un bucle sobre el array de resultados que le ha preparado el controlador: ```php ",
    "url": "/mvc/",
    "relUrl": "/mvc/"
  },"17": {
    "doc": "4 Arquitectura MVC",
    "title": "Listado de Articulos",
    "content": "| Fecha | Titulo | . | | . ``` ### 4.5.3. Segunda mejora: modelo, vista y controlador En esta segunda mejora, dividiremos el código en tres bloques (ubicados, de nuevo, en archivos diferentes): * Un modelo (archivo model.php) --> Contendrá una clase con un método que se encargará de acceder a la base de datos y empaquetar el resultado de la consulta en un array. * Una vista (archivo view.php) --> Se encargará de generar el HTML con el resultado de la consulta. * Un controlador (archivo index.php) --> Se encargará de invocar al modelo y a la vista en el orden correcto. Por lo tanto, el **controlador** se queda en algo tan sencillo como esto: ```php include('model.php'); // En este archivo estará el modelo $articulos = Model::getAll(); require('view.php'); // En este archivo estará la vista ``` El **modelo** consta de una clase con un método (de momento) encargado de consultar todos los artículos y devolverlos empaquetados en un array: ```php query('SELECT fecha, titulo FROM articulo'); $articulos = array(); while ($fila = $resultado->fetch_array()) { $articulos[] = $fila; } $db->close(); return $articulos; } } ?> ``` Por último, la **vista** será exactamente igual que en la versión anterior: un recorrido por el array de artículos para mostrarlos en formato HTML: ```php ",
    "url": "/mvc/",
    "relUrl": "/mvc/"
  },"18": {
    "doc": "4 Arquitectura MVC",
    "title": "Listado de Articulos",
    "content": "| Fecha | Titulo | . | | . ``` ### 4.5.4. Tercera mejora: añadiendo capa de abstracción de datos Como no sabemos lo que es el miedo, vamos a complicar nuestro patrón modelo-vista-controlador con una cuarta capa: la capa de abstracción de datos. La idea de esta capa adicional es proporcionar un mecanismo de abstracción respecto del gestor de base de datos concreto que estemos utilizando. Si te fijas en el **modelo** de la solución anterior, verás que estamos usando una clase (mysqli) y unos métodos que solo funcionan con MySQL o MariaDB. Si quiséramos cambiar el gestor de base de datos, tendríamos que revisar todos nuestros modelos. Una forma de independizar la aplicación del gestor de base de datos es programar una **capa de abstracción** que contenga dos o tres métodos genéricos (como consultar() para lanzar SELECT o manipular() para lanzar INSERT, UPDATE o DELETE). De ese modo, cuando queramos hacer una consulta desde el modelo, no lo haremos con los métodos de MySQL o de otro gestor de bases de datos, que traduzcan una petición genérica (como consultar(\"SELECT * FROM users\")) a una petición concreta para un gestor de base de datos (new mysqli(...), $db->query(), etc). Por lo tanto, en esta tercera mejor vamos a dividir el código en cuatro bloques: * Un controlador (archivo index.php). * Una vista (archivo view.php). * Un modelo en dos capas * Capa de abstracción de datos (dbabstract.php) * Capa de acceso a datos (el modelo propiamente dicho) (model.php). El código de la **capa de abstracción** sería algo así: ```php class DbAbstract { private $db; function crearConexion($servidor, $usuario, $clave, $dbname) { $db = new mysqli($servidor, $usuario, $clave, $dbname); } function cerrarConexion() { if ($db) $db->close(); } function consulta($consulta) { $res = $db→query($consulta); $resArray = array(); if ($res) { $resArray = $res->fetch_all(); } return $resArray; } ...etc... (añadimos cualquier función que acceda directamente a MySQL) } ``` El código del **modelo** va a hacer uso de la capa de abstracción: ```php include \"DbAbstract.php\"; class Model { public function getAllArticulos() { $db = new dbAbstract(); $db->crearConexion('localhost', 'usuario', 'clave', 'dbName'); $articulos = $db->consulta('SELECT fecha, titulo FROM articulo'); $db->cerrarConexion(); return $articulos; } } ``` El **controlador** y la **vista** son exactamente los mismos que en la solución anterior. ### 4.5.5. Cuarta (y última) mejora: transformación en clases y objetos reutilizables Para terminar, vamos a dejar el código bien organizado y a mostrarlo completo. Lo que haremos en esta última etapa es empaquetarlo todo en clases reutilizables. Observa que sigue siendo el mismo código fuente, solo que empaquetado en clases y métodos. Lo único que queda fuera de una clase es la instanciación del objeto controlador. Fíjate bien en cómo hemos convertido las vistas en una clase con un método show() que nos servirá para mostrar cualquier vista y reutilizar el mismo header y el mismo foorter. Cada vista se programará en un archivo independiente que deberemos organizar el directorios y subdirectorios. Otra cosa que quiero que observes con atención es el controlador, porque lo hemos dejado preparado para poder añadir nuevas funciones al programa con posterioridad. Este controlador te servirá de esqueleto para montar tus propias aplicaciones MVC. **index.php** ```php $controlador = new Controller(); $controlador->main(); ``` **controller.php** ```php include (\"View.php\"); include (\"Model.php\"); class Controller { public function main() { $estado = (isset($_REQUEST['do']) ? $_REQUEST['do'] ; \"formLogin\"); switch ($estado) { case \"formLogin\": ... case \"checkLogin\": ... case \"showAllArticles\": $articulos = Articulos::getAllArticulos(); View::show(\"showAllArticles\"); break; case \"...etc...\": ... } } } ``` **view.php** ```php ``` **showAllArticles.php** ```html ",
    "url": "/mvc/",
    "relUrl": "/mvc/"
  },"19": {
    "doc": "4 Arquitectura MVC",
    "title": "Listado de Articulos",
    "content": "| Fecha | Titulo | . | | . crearConexion('localhost', 'usuario', 'clave','dbName'); $articulos = $db->cosulta('SELECT fecha, titulo FROM articulo'); $db->cerrarConexion(); return $articulos; } } ``` **dbabstract.php** ```php class DbAbstract { private $db; function crearConexion($servidor, $usuario, $clave, $dbname) { $db = new mysqli($servidor, $usuario, $clave, $dbname); } function cerrarConexion() { if ($db) $db->close(); } function consulta($consulta) { $res = $db→query($consulta); $resArray = array(); if ($res) { $resArray = $res->fetch_all(); } return $resArray; } ...etc... (añadimos cualquier función que acceda directamente a MySQL) } ``` ## 4.6. Una explicación del patrón MVC Ahora que hemos aprendido a manejarnos con el patrón MVC por medio de un ejemplo, estamos en condiciones de definirlo de manera más teórica y, oh maravilla, incluso entender esa definición. El patrón MVC divide la aplicación en tres capas: * **Los modelos**, donde se programa la *lógica de negocio*. De esa forma tan rimbombante se refiere la literatura técnica al acceso a los datos con los filtros, algoritmos y restricciones que el sistema imponga. En la práctica, esto significa que en los modelos debemos colocar todo el código de acceso a la base de datos o a cualquier otro recurso del servidor (como las variables de sesión, por ejemplo). Los modelos deben empaquetarlos en objetos estándar de PHP (como arrays) y devolverlos al controlador. Lo más práctico es crear un modelo para cada tabla maestra de la base de datos. Los frameworks automatizan los métodos más típicos de cada modelo, como insertar un registro, borrar, actualizar, consultar uno o consultar todos. * **Las vistas**, donde se programan todas las salidas HTML que el usuario final va a ver y con las que va a interactuar. El código Javascript y CSS, por lo tanto, forma parte de las vistas. En las vistas estará el grueso del código de cualquier aplicación. Los frameworks más avanzados incluyen sistemas de plantillas y lenguajes adicionales para simplificar este proceso, pero si programamos en PHP clásico, tendremos que construir las vistas manualmente. * **Los controladores**, donde se captura cada petición del usuario y se dirige el flujo de ejecución, invocando a los modelos y a las vistas en el orden adecuado. En una aplicación pequeña, bastará con tener un controlador para todo. Cuando la aplicación crece, suele hacerse un controlador por cada modelo, es decir, un controlador por cada tabla maestra. Nuestros controladores van a estar compuestos por un switch muy grande con un case para cada funcionalidad de la aplicación. Ese switch estará dirigido por una variable de control. En los frameworks, este switch se transforma en una colección de métodos, lo cual proporciona un código mucho más elegante, pero que funcionalmente hace lo mismo. ",
    "url": "/mvc/",
    "relUrl": "/mvc/"
  },"20": {
    "doc": "4 Arquitectura MVC",
    "title": "4 Arquitectura MVC",
    "content": "# 4. Arquitectura MVC Cuando hablamos de arquitectura de una aplicación web nos referimos a la estructura básica que la sustenta, como los pilares de un edificio en construcción. Si quitas las paredes, las ventanas, las puertas, los azulejos de la cocina... todavía pueden distinguirse las formas fundamentales, ¿verdad? En este tema, hablaremos mucho de la arquitectura más popular en aplicaciones web (llamada MVC; no te preocupes, pronto se convertirá en tu mejor amiga). Pero, antes, vamos a darle una vuelta al término \"arquitectura\", porque en aplicaciones web se usa con dos significados distintos que conviene que tengas claros para no hacerte un lío. ## 4.1 Arquitecturas FÍSICAS multinivel (multitier) Hablamos indistintamente de \"arquitectura de una aplicación web\" para referirnos a dos cosas distintas: la arquitectura física y la arquitectura lógica. Y ahí empiezan los líos. Vamos a intentar desliarnos antes de apretar el nudo. Una **arquitectura física de varios niveles** (multinivel o multitier, en inglés) consiste en un conjunto de ordenadores conectados a una red que ejecutan de forma conjunta una aplicación. El ejemplo más sencillo es la arquitectura cliente-servidor, la más popular en aplicaciones web sencillas: una máquina cliente y una máquina servidor ejecutan alternativamente fragmentos del código, proporcionando al usuario final la sensación de una aplicación unificada. ![Arquitectura en 2 niveles](/assets/images/04-arquitectura-2-niveles.png) Por supuesto, nada impide que tengamos más de dos máquinas colaborando en red par ejecutar una aplicación web. Podemos tener, por ejemplo, un cliente, un servidor web y un servidor de bases de datos (estos dos últimos en dos máquinas físicas diferentes). Esto sería una arquitectura de 3 niveles físicos. La arquitectura de N niveles tendría este aspecto: ![Arquitectura en N niveles](/assets/images/04-arquitectura-N-niveles.png) ## 4.2 Arquitecturas LÓGICAS multicapa (multilayer) Ahora viene la vuelta de tuerca: la arquitectura de una aplicación también puede referirse a sus capas (layers) lógicas. Es decir, a las capas de software que nosotros, como desarrolladores, crearemos. Dividir una aplicación en capas que colaboran entre sí por medio de interfaces bien definidos no es una idea nueva, ni pertenece exclusivamente al ámbito de la programación web. Pero la mayor parte de las aplicaciones web hacen uso de este mecanismo de abstracción. La idea es dividir nuestra aplicación en capas de niveles de abstracción cada vez mayor. La capa superior (la más abstracta) es la que interacciona con el usuario: ahí se implementará nuestro interfaz de usuario, o lo que en aplicaciones web se llama *front-end*. La capa inferior (la menos abstracta) es la que está en contacto con el hardware de la máquina. Bueno, con el hardware no: debajo de ella habrá otras capas que ya no pertenecen a nuestra aplicación y que se encargarán de ello: el sistema operativo, el servidor, el gestor de bases de datos, o lo que sea. Pero nuestra capa inferior será la que interactúe con esas otras capas que escapan a nuestros dominios y que están en contacto con la máquina. Esta división en capas de abstracción, que puede parecer al neófito una complicación innecesaria, tiene un montón de ventajas y por eso se usa en cualquier aplicación un poco más complicada que \"Hola, mundo\". ### 4.2.1. Ventajas de las arquitecturas multicapa Las arquitecturas multicapa permiten varias cosas que no pueden hacerse con los códigos monolíticos. Entre otras: * Desarrollar en paralelo cada capa (mayor rapidez de desarrollo). * Aplicaciones más robustas (gracias al encapsulamiento. ¿Te suena? ¡Programación orientada a objetos!). * Matenimiento más sencillo. * Más flexibilidad para añadir módulos. * Más escalabilidad para aumentar rendimiento. * Más seguridad, al poder aislar (relativamente) cada capa del resto. * Mejor escalabilidad: es más fácil hacer crecer al sistema. * Mejor rendimiento (aunque esto podría discutirse: puedes hacer un sistema multicapa con un rendimiento desastroso y un sistema monolítico que vaya como un tiro. Pero, en general, es más fácil mejorar el rendimiento trabajando en cada capa por separado). * Es más fácil hacer el control de calidad, incluyendo la fase de pruebas. ### 4.2.2. Esquema Modelo-Vista-Controlador (MVC) Y por fin llegamos a la palabreja: Modelo-Vista-Controlador o MVC. ¿Qué narices es esto? Tan solo una arquitectura multicapa estandarizada. Una arquitectura de 3 capas, para ser exactos. Este es el esquema de una arquitectura en 3 capas. Recuerda: cada capa ejecuta una parte de la solución, y entre ellas colaboran para formar la aplicación completa. La capa superior interactúa con el usuario; la capa inferior, con la máquina (donde dice \"hardware\", debería decir \"cualquier cosa menos abstracta que nuestro programa\"). Tienes permiso para imaginar cada capa como una clase con sus métodos y atributos. ![Arquitectura en 3 capas](/assets/images/04-arquitectura-3-capas.png) Pues bien, si a esas tres les ponemos nombres exóticos como modelo, vista y controlador, y remeneamos un poco el esquema, ya lo tenemos: la arquitectura MVC. ![Arquitectura MVC](/assets/images/04-arquitectura-mvc.png) Es decir, la arquitectura MVC solo es un caso particular de la arquitectura en 3 capas. ¿Y ya está? Bueno, no. Ahora tienes que aprender qué signfica *en realidad* esta palabrería. Para que tengas una idea completa del asunto, ahora tienes que aprender qué parte de la aplicación se ejecuta en cada una de las capas. Pero es más simple de lo que parece. Y lo maravilloso es que el 99,99% de las aplicaciones web encajan como un guante en esta arquitectura. Es decir, apenas tendremos que hacer trabajo de diseño previo, porque, si es una aplicación web, ya sabemos qué clases tendremos que construir: los que nos indique la arquitectura MVC. Antes de entrar en profundidad, un breve apunte: por supuesto, nada impide construir arquitecturas con más de 3 capas. De hecho, nosotros vamos a usar una variante del MVC en el que se añade una capa adicional por debajo del modelo, es decir, una arquitectura con 4 capas. Pero ya llegaremos a eso. ## 4.3. Patrones de software Los **patrones de software** son soluciones comprobadas a problemas comunes en el desarrollo de software. Para que un patrón pueda considerarse tal cosa, tiene que cumplir estas condiciones: * Debe haber sido comprobado en otros sistemas. * Debe ser fácilmente reutilizable. * Debe ser aplicable a diferentes circunstancias. * Debe estar bien documentado. La documentación típica de un patrón de software incluye: * Problema que resuelve. * Contexto en el que es aplicable. * Fuerzas, objetivos y restricciones. * Solución que propone. * Ejemplos. * Contexto resultante. * Exposición razonada. * Otros patrones relacionados. ### 4.4.2. Tipos de patrones: Dependiendo del grado de abstracción del patrón, existen patrones de diverso tipo: * De arquitectura * De diseño * De creación de objetos * De estructura de clases * De comportamiento * De dialectos * De interacción o interfaz de usuario * De análisis * De dominio Quizá no te sorprenda oír que el esquema MVC se considera un **patrón de software de arquitectura**. ### 4.4.3. Ejemplo de patrón: el patrón Singleton Antes de centrarnos en MVC, vamos a ver, solo a modo de ejemplo, otro tipo de patrón: **el patrón Singleton**. Algunos recursos en una aplicación son de tal naturaleza que sólo puede existir una instancia de ese tipo de recurso. Por ejemplo, la conexión a la base de datos a través de un manejador de base de datos. A veces interesa compartir un manejador de base de datos para que el resto de recursos no tengan que conectarse y desconectarse continuamente de la BD, y sólo debería existir una instancia de ese manejador. El patrón Singleton cubre esta necesidad. Un objeto es “singleton” si la aplicación puede generar una y sólo una instancia del mismo. Esta es una implementación reutilizable de ese patrón: ```php _handle =& DB::Connect( $dsn, array() ); } public function handle() { return $this->_handle; } } print( \"Handle = \".DatabaseConnection::get()->handle().\"\\n\" ); print( \"Handle = \".DatabaseConnection::get()->handle().\"\\n\" ); ?> ``` ## 4.5. El patrón MVC en la práctica Tras esta introducción, vamos a estudiar a fondo el patrón MVC. Y lo vamos a hacer por medio de un ejemplo, que es como mejor suelen comprenderse estas cosas. Una vez terminado y comprendido el ejemplo, daremos una definición forma del patrón MVC. Si lees el código fuente con atención, verás como, al acabar, entenderás perfectamente en qué consiste el MVC y podrás empezar a aplicarlo en tus proyectos. El ejemplo con el que vamos a trabajar es este: supongamos que queremos programar una pequeña aplicación web que nos permita hacer publicaciones en una especie de blog simplificado. Esas publicaciones se guardan como registros en una tabla de una base de datos. En el código de ejemplo sobre el que vamos a trabajar, nos vamos a centrar en obtener de la base de datos el listado de los artículos existentes para mostrarlo en una página HTML. ### 4.5.1. Código monolítico Una primera aproximación a la solución, sin usar ningún patrón de arquitectura en absoluto, podría ser esta (échale un vistazo y asegúrate de entenderlo): ```php query('SELECT fecha, titulo FROM articulo'); ?> // Generamos una tabla con el resultado de la consulta ",
    "url": "/mvc/",
    "relUrl": "/mvc/"
  },"21": {
    "doc": "5 Laravel",
    "title": "5 Laravel",
    "content": "# 5. Laravel Laravel es un framework PHP MVC diseñado para agilizar el desarrollo de aplicaciones web. En los últimos años ha tenido una gran penetración en la industria. Empezaremos por aprender qué es un framework PHP MVC, qué frameworks existen y en qué circunstancias resulta interesante utilizar una de estas herramientas para desarrollar una aplicación. Dedicaremos el resto del tema a estudiar todas las peculiaridades de Laravel para aprender a desarrollar aplicaciones con este poderoso framework. ",
    "url": "/laravel/",
    "relUrl": "/laravel/"
  },"22": {
    "doc": "6 Servicios web",
    "title": "6 Servicios web",
    "content": "# 6. Servicios web ## 6.1. ¿Qué es un servicio web? Como dijimos al estudiar el patrón MVC, esta arquitectura no es la única manera de plantear las aplicaciones web. En este tema vamos a hablar de otra manera en la que las aplicaciones web funcionan muy frecuentemente: como simples servicios. ### 6.1.1. Una definición de servicio web Un **servicio web** es una forma de permitir que una aplicación cliente y una aplicación servidor se comuniquen entre sí e intercambien información independientemente de la plataforma en la que cada una se ejecute. Los mensajes que las aplicaciones se intercambiar generalmente tienen formato XML o JSON. Hay dos estándares principales en la industria para implementar servicios web: **SOAP** y **REST**. ### 6.1.2. Diferencias entre servicios web y aplicaciones web Llegados a este punto, puede que estés pensando: \"Vale, pero ¿en qué se diferencia todo esto de una aplicación web MVC? ¿No intercambian también el cliente y el servidor información independientemente de la plataforma en la que se ejecuta cada uno?\". Pues sí, pero hay algunas **diferencias fundamentales entre un servicio web y una aplicación web**: * Una aplicación web está diseñada para que un ser humano interactúe con ella a través de un interfaz DHTML. Un servicio web, en cambio, está pensado para que lo use otra aplicación (el cliente), no un ser humano. * Por ese motivo, los servicios web carecen de interfaz de usuario y no produce salidas HTML legibles. Es decir, un servicio web **no tiene vistas**. * En cambio, los servicios web suelen producir salidas XML o JSON, pensadas para que los clientes las procesen. Una aplicación web solo hace esto cuando responde a una petición Ajax, algo que veremos más adelante. Por lo demás, un servicio web puede tener una arquitectura *aproximadamente* MVC, y digo *aproximadamente* porque el servicio web, como acabo de contarte, carece de vistas. Pero puede seguir conservando sus controladores y sus modelos. Los controladores se encargarán de convertir los datos de los modelos a JSON o XML y devolverlos al cliente. ## 6.2. SOAP **SOAP (Single Object Access Protocol)** es un mecanismo estandarizado para la implementación, descripción y publicación de servicios en red. SOAP establece el modo en el que deben comportarse el cliente y el servidor para hablar entre sí, así como la forma en la que el servidor debe dar a conocer sus servicios. Es un mecanismo orientado al proceso, a diferencia de REST, que está orientado a los datos y que veremos después. ### 6.2.1. La pila de protocolos de SOAP El estándar SOAP define una serie de protocolos de niveles de abstracción crecientes. Esta colección de protocolos suele denominarse **pila de protocolos SOAP**, y son los siguientes: XXX imagen Vamos a explicar brevemente en qué consiste cada protocolo de la pila, y lo vamos a hacer, como en otras ocasiones, por medio de un ejemplo en lugar de perdernos en largas y farragosas explicaciones. ### 6.2.2. Los protocolos SOAP y WSDL Para ver cómo funciona el protocolo SOAP (el más importante de la pila de protocolos SOAP, como ya te habrás imaginado por su nombre), utilizaremos tres ejemplos: * En el primero, veremos cómo construir un servidor que duelva colecciones de datos en forma de array. * En el segundo, veremos cómo puede un servidor devolver datos con estructura más compleja formateados con JSON. * En el tercero, veremos un servidor extremadamente simple con un fichero WSDL. #### Ejemplo 1: Consulta de una BD de marcas y modelos de coches. Vamos a programar un servicio web muy sencillo capaz de servir a los clientes que nos lo pidan un listado de las marcas de coches que existen y otro con los modelos registrados que pertenecen a una marca en concreto. El servidor, por lo tanto, necesita dos funciones: * ObtenerMarcas * ObtenerModelos($marca) El cliente, como es lógico, debe conocer cómo utilizar el servidor. Esto puede hacerse mediante el protocolo WSDL (que ya veremos un poco después) por otras vías más tradicionales: documentación de la API, guía del desarrollador, manual de usuario... En estos ejemplos, tanto el servidor como el cliente estarán escritos en PHP. Por supuesto, puede usarse cualquier otro lenguaje para ello, en particular en el lado del cliente. Para saber cómo hacer un cliente SOAP en otros lenguajes, consulta la documentación de tu lenguaje preferido. **En el lado del servidor** necesitaremos crear un objeto de tipo SoapServer y definir los métodos a los que el servidor va a responder. Vamos a empezar por los métodos. Crearemos un fichero (por ejemplo, llamado **GestionAutomoviles.class.php**) en cuyo interior escribiremos una clase con los métodos que necesitemos. Para nuestro ejemplo de marcas y modelos de coches, podrías ser algo así: El servidor se crea con una clase que contenga los métodos necesarios: ```php class GestionAutomoviles { public function ObtenerMarcas() { $db = new mysqli(); $marcas = array(); if( $db ) { $result = $db->query('select id, marca from marcas'); while( $row = $result->fetch_array() ) $marcas[$row['id']] = $row['marca']; $db->close(); } return $marcas; } public function ObtenerModelos($marca) { $db = new mysqli(); $marca = intVal($marca); $modelos = array(); if( $marca !== 0 ) { $result = $db->query('select id, modelo from modelos where marca = ' . $marca ); while( $row = $result->fetch_array() ) $modelos[$row['id']] = $row['modelo']; } $db->close(); return $modelos; }} ``` Ahora, en otro archivo aparte, que llamaremos, por ejemplo, *webservice.php*, *registramos el servicio* usando la clase SoapServer de PHP y asignándole la clase anterior GestionAutomoviles. Así: ```php 'http://localhost/')); $soap->setClass('GestionAutomoviles'); $soap->handle(); ?> ``` El constructor de SoapServer tiene dos argumentos: * El fichero WSDL donde se describe el servicio. Como aún no vamos a usar fichero WSDL, ese argumento lo dejaremos, de momento, a null. * La URL donde el servidor va a estar escuchando. Puede ser el directorio raíz de nuestro servidor o cualquier subdirectorio o archivo. Por último, y para comprobar que nuestro servidor SOAP funciona bien, necesitamos crear un secillo cliente que consuma ese servicio. Como hemos dicho antes, esta parte también la vamos a programar en PHP, aunque podría hacerse en cualquier otro lenguaje con soporte SOAP. **En la parte cliente**, necesitamos crear un objeto de tipo SoapClient: ```php $soapS = new SoapServer(null, \"URI del servidor\"); ``` Nuevamente, el primer argumento del constructor es el fichero WSDL. Como aún no trabajamos con ellos, lo dejamos a null. Si tuviéramos fichero WSDL, no necesitaríamos indicar la URI del servidor, porque el propio fichero WSDL lo establecería de forma inequívoca. Una vez hecho eso, podemos consumir los servicios del cliente. Por ejemplo: ```php 'http://localhost/', 'location' => 'http://localhost//webservice.php')); $marcas = $client->ObtenerMarcas(); foreach($marcas as $key => $value ) echo $value; ?> ``` Observa cómo hemos indicado la localización del servidor: en un array, indicamos su ubicación y la ruta de acceso al fichero que maneja el servicio (en nuestro ejemplo, webservice.php). #### Ejemplo 2: Lista de libros de una biblioteca. El ejemplo anterior funciona porque tanto cliente como servidor trabajan en PHP. Pero si el cliente no fuera PHP, podría tener problemas al recibir los datos de respuesta del servidor, que son arrays PHP. Lo más adecuado cuando se responden datos complejos es enviarlos en algún formato de intercambio de información, como XML o JSON. En este nuevo ejemplo, vamos a crear un servidor que nos devuelva la lista de libros de una biblioteca (lo que incluirá el id, el título y el ISBN de cada libro) empaquetada en un string JSON. De momento, tampoco usaremos WSDL (fichero de descripción del servicio). **Servidor** (archivo *libros.class.php*): ```php class libros { private function getLibrosJSON() { $sql = \"SELECT * FROM libros\"; $db = new dbAbstract(); // Suponemos que existe una capa // de abstracción de datos return json_encode($db->consulta($sql)); } ...aquí irían más métodos que pudiera tener el servidor } Registramos el servidor en otro archivo (que llamaremos *libros.server.php*): ```php 'http://localhost/')); $soap->setClass('libros'); $soap->handle(); ?> ``` **Cliente** De nuevo, lo vamos a crear en PHP, aunque no sea lo más habitual. Al ser un programa PHP, tendrás que ejecutarlo contra un servidor web, o bien directamente desde la línea de comandos. ```php 'http://localhost/', 'location' => 'http://localhost/libros.server.php')); $listaLibros = $libros->getLibrosJSON(); ?> ``` A partir de ahí, el cliente dispondrá en $listaLibros de la información recibida del servidor (id, titulo, isbn de todos los libros) empaquetada en formato JSON. #### Ejemplo 3: Servicio de calculadora Este será un servicio mucho más simple y hasta un poco tontorrón, pero no te lo tomes a mal: solo es un ejemplo. El servicio simple y tontorrón proporcionará dos métodos: * sumar (op1, op2) --> Devuelve la suma de op1 y op2 * restar (op1, op2) --> Devuelve la diferencia entre op1 y op2 Ahora sí usaremos WSDL para definir el servicio y que los clientes sepan cómo usarlo. Así, a través de un ejemplo simple (y tontorrón) podrás conocer cuál es la estructura de estos ficheros. **Servidor** El código del servidor es extremadamente simple. Fíjate en que ahora, el crear el objeto SoapServer, sí indicamos el archivo WSDL: ```php AddFunction(\"sumar\"); $server->AddFunction(\"restar\"); $server->handle(); ?> ``` **Cliente** ```php sumar(2.7, 3.5); $resultado_resta = $clienteSOAP->restar(2.7, 3.5); echo \"la suma de 2.7 mas 3.5 es: \" . $resultado_suma . \"\"; echo \"la diferencia de 2.7 menos 3.5 es: \" . $resultado_resta . \"\"; ?> ``` **Documento WSDL** El documento WSDL es un archivo de texto alojado en el servidor donde se describen todos los aspectos del servicio: * Los mensajes que se pueden intercambiar entre el cliente y el servidor. * Los argumentos y tipos de datos de esos mensajes. * Las operaciones y sus tipos * Las rutas donde puede encontrarse el servidor Se trata de un documento en formato XML que resulta bastante farragoso de leer, así que tómatelo con calma (ahora entiendes por qué hemos elegido un servicio tan simple como el de este ejemplo para ver su archivo WSDL: si usáramos un servicio más realista, el archivo resultaría un monstruo de miles de líneas). Aquí lo tienes: ```xml . ``` Escribir los documentos WSDL a mano es casi imposible. Y hacerlo sin cometer errores, es imposible del todo. Para eso existen herramientas automatizadas que toman el archivo con la clase que contiene los métodos del servicio y generan automáticamente el archivo WSDL. Puedes encontrar estas herramientas de creación automática del archivo WSDL en cualquier IDE avanzado (como Netbeans o Eclipse) y también en mucho sitios web. Por lo tanto, no es un documento que vayas a tener que redactar tú, ni siquiera que leer tú: se trata de una descripción del servicio escrita por y para programas informáticos. Por eso no tiene un formato demasiado legible para un humano. ### 6.2.3. UDDI Este protocolo, que también forma parte de la pila SOAP, es muy fácil de explicar. Olvídate de que existe. Fin de la explicación. Fácil, ¿verdad? Pero si esta explicación te sabe a poco, te cuento que UDDI fue un intento de la industria por estandarizar repositorios de servicios, de manera que cualquier cliente pudiera lanzar una petición a la red para descubrirlos y usarlos. Imagina que tienes una web que necesita conocer la previsión del tiempo en una zona, la que sea. Puedes localizar un servicio web que te proporcione esa información (ya sea de forma gratuita o mediante una suscripción, eso es irrelevante). Hay, de hecho, muchos servidores que ofrecen este servicio, empezando por el de la Agencia Estatal de Meteorología. Para usar ese servicio, tienes que conocer el servidor que lo ofrece y luego bucear en su API para avieriguar cómo narices debes pedirle la información y en qué formato te la va a devolver. Y, una vez hecho eso, ya estás listo para programar tu cliente y consumir ese servicio. Pues bien: el servicio UDDI buscaba implementar una manera para que el servidor publicara el tipo de servicio que está ofertando y los clientes pudieran escanear la red en busca de esos servicios, para luego seleccionar uno y lanzar peticiones contra él, todo ello de forma más o menos transparente al programador. Era una idea interesante, ¿verdad? Pero murió hace mucho. De hecho, entró en punto muerto en el año 2006, cuando Microsoft e IBM decidieron abandonarlo. Así que, lo dicho: aunque en teoría el protocolo UDDI forma parte de la pila SOAP, puedes actuar como si no existiera. ## 6.3. REST ### 6.3.1. ¿Qué es REST? **REST (Representational State Transfer)** es un mecanismo de intercambio de información entre clientes y servidores de una red. A diferencia de SOAP, está orientado a los datos, esto eso, proporciona siempre los mismos tipos de acceso a los recursos, sin posibilidad de definir nuevas operaciones. Por esa razón se dice que **REST está orientado a los datos** mientras que **SOAP está orientado a los procesos**. Actualmente, gran parte de las APIs, ya sean públicas o privadas, se programan según el diseño RESTful para que los programadores que las usen sepan qué esperar de la API. ### 6.3.2. Las 7 operaciones REST Un servidor REST (también llamado **RESTful**) debe implementar siete operaciones de acceso a cada tipo de recurso. Los nombres de las operaciones, los datos que se esperan que se devuelvan y el método de acceso (si se accede al servidor por http, que es lo que nosotros haremos) deben respetarse escrupulosamente. Imagina que estamos programando un servidor RESTful para acceder, por ejemplo, a un recurso llamado *Producto* dentro de una aplicación más grande (por ejemplo, una tienda online). En la siguiente tabla tienes las siete operaciones que un servidor RESTful puede realizar con ese recurso, es decir, con los productos de la base de datos. También te indico qué significa cada operación y un ejemplo típico de la URL que permitirá el acceso a través de https. |Operación|Significado|Verbo|URL típica|---|---|---|---|index|Listar todos los producto|GET|https://servidor/producto/|show|Mostrar un producto|GET|https://servidor/producto/id|create|Mostrar formulario de creación de un producto|GET|https://servidor/producto/create|store|Crear un producto con los datos procedentes de un formulario|POST|https://servidor/producto/store|edit|Mostrar el formulario de edición de un producto|GET|https://servidor/producto/edit/id|update|Actualizar el producto con los datos procedentes del formulario|PUT|https://servidor/producto/update/id|destroy|Eliminar un producto|DESTROY|https://servidor/producto/destroy/id| (Las operaciones *create* y *edit* podrían no estar disponibles en algunas APIs RESTful, cuando estas están diseñadas para que las usen otras aplicaciones y no seres humanos). Soy consciente de que esta tabla necesita algunas explicaciones adicionales, así que vamos a ello. En primer lugar, ¿qué es eso de los *verbos* que figura en cada petición? ### 6.3.3. Los verbos http: GET, POST, PUT y DESTROY El protocolo http define dos tipos de petición al servidor, GET y POST. El estándar REST aumenta estos tipos en otros dos, PUT (o PATCH, en algunas implementaciones) y DESTROY: * **GET** se utiliza para solicitar datos al servidor. Por ejemplo: \"Dame toda la información de un producto\". * **POST** se utiliza para enviar datos al servidor. Por ejemplo: \"Aquí tienes toda la información de un producto; anda, almacénalo en tu base de datos\". * **PUT/PATCH** se utiliza para solicitar al servidor la modificación de datos que ya existen. Por ejemplo: \"Este es el nuevo precio de un producto que ya estaba en tu base de datos. Tómalo y actualízalo\". * **DESTROY** se utiliza para solicitar la eliminación de datos en el servidor. Por ejemplo: \"Elimina este producto\". Por ese motivo, en algunas URLs de la tabla anterior enviamos un id como parte de la ruta. Ese id (que debe ser sustituido por un número real, es decir, por el id de un producto) indicará al servidor qué producto le estamos pidiendo que nos busque, modifique o elimine. Si ya has trabajado con HTML antes, seguro que conocías el significado de GET y POST, pero probablemente nunca habías oído hablar de PUT y DESTROY, ¿verdad? ### 6.3.4. El problema de PUT y DESTROY Cuando solicitamos una URL a un servidor sin indicar otra cosa, el protocolo http asumirá que se trata de una petición GET. Si en un formulario indicamos que el método de envío de los datos al servidor es POST, conseguiremos hacer una petición POST, y los datos que el usuario rellene en ese formulario se enviarán al servidor como parte del paquete http, en una zona especialmente dedicada a empaquetarlos: ```html ...cuerpo del formulario ``` Pero **con HTML5 *no hay manera de hacer una petición al servidor por PUT ni por DESTROY***. Esto se debe a que la implementación actual de http no contempla los verbos PUT ni DESTROY. Pero, en el estándar REST, estos verbos son fundamentales. Como a nosotros nos interesa construir servidores RESTful con acceso por http, es decir, vía web, aquí tenemos un grave problema. Mientras llega una nueva implementación de http y/o de HTML, **este problema tiene dos soluciones temporales**: * Sustituir las llamadas con PUT y DESTROY por llamadas POST convencionales. Esto hará que, en la práctica, nuestro servidor deje de ser RESTful, claro. * Parchear las llamadas con PUT y DESTROY mediante un campo oculto (de tipo *hidden*) en el formulario. Esta es la forma en la que se realizan las implementaciones RESTful vía web en la actualidad. Tienes un ejemplo en este formulario: ```html ...cuerpo del formulario... ``` ### 6.3.5. REST y JSON REST y JSON tienen una relación especial: todas las APIs RESTful devolverán sus datos formateados en JSON, por lo que, si vas a construir un servidor RESTful, harías bien en devolver todos tus datos en ese formato. Entiéndeme: si a tu servidor le llega una petición de tipo GET a través de esta ruta: https://servidor/producto/18, no hay nada que te impida devolver los datos del producto 18 formateados en XML, por ejemplo, pero tienes que ser consciente de que tu servidor habrá dejado de ser RESTful. Devolver un producto (o lo que sea) formateado en JSON mediante PHP resulta tan sencillo como hacer esto: ```php $producto = modelo-de-productos::get($id); // Obtenemos los datos del producto $id pidiéndoselos a nuestro modelo echo json_encode($producto); ``` ### 6.3.6. REST vs SOAP **SOAP es más flexible que REST**: permite definir nuevas operaciones sobre los recursos, mientras que REST está limitado a las 7 operaciones predefinidas. **REST es mucho más sencillo de usar e implementar que SOAP**: las operaciones son bien conocidas y no es necesario describirlas (WSDL) ni publicarlas de ningún modo. No hay que estudiarse ninguna API ni pelearse con estructuras de datos desconocidas, puesto que todo el intercambio de información se hace con JSON. Por todo ello, para la mayor parte de las aplicaciones REST es más que suficiente, y de ahí su mayor implantación en la actualidad. ### 6.3.7. Algunos trucos para implementar un servidor RESTful Para implementar un servidor RESTful, basta con: * Crear una arquitectura MVC para los recursos/datos que deseemos servir. Con Laravel, esto se puede conseguir con el comando: ``` $ php artisan make:controller --resource ``` * En lugar de mostrar los recursos en una vista, los mostraremos mediante JSON con un sencillo echo (recuerda que esa salida la recibirá el cliente, no un ser humano) Si estamos trabajando con Laravel, en lugar de echo usaremos return al final de cada método del controlador. Laravel se encargará de enviar ese valor devuelto al cliente. * Es importante respetar los nombres de las peticiones HTTP, así como los verbos (GET, POST, PUT y DESTROY), puesto que serán los que el cliente utilice. ",
    "url": "/servicios-web/",
    "relUrl": "/servicios-web/"
  },"23": {
    "doc": "7 Ajax",
    "title": "7 Ajax",
    "content": "# 7. Ajax ## 7.1. ¿Qué es Ajax? Ajax = Asynchronous Javascript And XML Ajax es una tecnología JS para ejecutar la aplicación web en el cliente (o gran parte de ella) y lanzar peticiones al servidor para refrescar la información mostrada. Las peticiones al servidor se lanzan y reciben en segundo plano (= de forma asíncrona) Ajax permite actualizar las páginas sin necesidad de recargarlas por completo, lo que mejora la usabilidad y velocidad de respuesta. ## 7.2. Cómo enviar peticiones Ajax al servidor ### 7.2.1. Peticiones sin datos al servidor peticion_http = new XMLHttpRequest(); peticion_http.onreadystatechange = procesa_respuesta; peticion_http.open('GET', 'http://servidor/recurso', true); peticion_http.send(null); function procesa_respuesta() { if(peticion_http.readyState == 4) { if(peticion_http.status == 200) { alert(peticion_http.responseText); } } } ### 7.2.2. Peticiones con datos al servidor (GET) var cp = document.getElementById(\"codigo_postal\"); var telefono = document.getElementById(\"telefono\"); query_string = \"&codigo_postal=\" + encodeURIComponent(cp.value) + \"&telefono=\" + encodeURIComponent(telefono.value); peticion_http = new XMLHttpRequest(); peticion_http.onreadystatechange = procesa_respuesta; peticion_http.open('GET', 'http://servidor/scrip.php', true); peticion_http.send(query_string); function procesa_respuesta() { .... } ### 7.2.3. Peticiones con datos al servidor (POST) var cp = document.getElementById(\"codigo_postal\"); var telefono = document.getElementById(\"telefono\"); query_string = \"&codigo_postal=\" + encodeURIComponent(cp.value) + \"&telefono=\" + encodeURIComponent(telefono.value); peticion_http = new XMLHttpRequest(); peticion_http.onreadystatechange = procesa_respuesta; peticion_http.open(\"POST\", \"http://servidor/script.php\", true); peticion_http.setRequestHeader(\"Content-Type\", \"application/x-www-form-urlencoded\"); peticion_http.send(query_string); function procesa_respuesta() { .... } ### 7.2.4. Peticiones con datos al servidor (XML) var cp = document.getElementById(\"codigo_postal\"); var telefono = document.getElementById(\"telefono\"); xml = \"\" + \"\" + cp + \" + + telefono + + \"\"; peticion_http = new XMLHttpRequest(); peticion_http.onreadystatechange = procesa_respuesta; peticion_http.open(\"POST\", \"http://servidor/script.php\", true); peticion_http.setRequestHeader(\"Content-Type\", \"application/x-www-form-urlencoded\"); peticion_http.send(xml); function procesa_respuesta() { .... } ## 7.3. Cómo recibir la respuesta del servidor ### 7.3.1. Recepción de datos XML Recepción de datos XML function procesaRespuesta() { if(peticion_http.readyState == 4) { if(peticion_http.status == 200) { var xml = peticion_http.responseXML; var datos = xml.getElementsByTagName(\"datos\")[0]; var telefono = datos.getElementsByTagName(\"telefono\")[0]. firstChild.nodeValue; var cp = datos.getElementsByTagName(\"cp\")[0]. firstChild.nodeValue; document.getElementById(\"respuesta\").innerHTML = \"Codigo postal = \" + codigo_postal + \"\" + \"Telefono = \" + telefono; } } } ### 7.3.2. Recepción de datos JSON function procesaRespuesta() { if(http_request.readyState == 4) { if(http_request.status == 200) { var json = http_request.responseText; var objeto_json = eval(\"(\"+json+\")\"); var telefono = objeto_json.datos.telefono; var codigo_postal = objeto_json.datos.cp; document.getElementById(\"respuesta\").innerHTML = \"Codigo postal = \" + codigo_postal + \"\" + \"Telefono = \" + telefono; } } } ## 7.4. Ajax y jQuery El uso de jQuery facilita enormemente la programación de llamadas Ajax al servidor. jQuery ofrece varias funciones para hacer llamadas Ajax: $.ajax() → La más configurable pero también la más compleja. $.get() → Para lanzar peticiones GET sencillas. $.post() → Para lanzar peticiones POST sencillas $.load() → Para lanzar peticiones GET y cargar la respuesta en una capa. Función $.ajax() $.ajax({ url: '/ruta/hasta/script.php', type: 'POST', async: true, data: 'parametro1=valor1&parametro2=valor2', success: función_procesa_respuesta, error: función_procesa_error }); Funciones $.get() y $.post $.get(url, datos, funcion_manejadora); $.post(url, datos, funcion_manejadora); Ejemplo: $.get('/ruta/hasta/script.php', { user: 'juanperez03' }, function(user) { alert('Hola, ' + user); } ); Función $.load() Inserta el resultado del script del servidor en el elemento seleccionado con $: $('#info').load('/ruta/hasta/pagina.php'); Variación “IfModified”: $.getIfModified('/ruta/hasta/script.php'); $.postIfModified('/ruta/hasta/script.php'); $('#info').loadIfModified('/ruta/hasta/script.php'); ## 7.5. Ajax y Laravel Enrutador /routes/web.php Route::post('miJqueryAjax','AjaxController@miMetodo'); Ten en cuenta que: No es imprescindible crear un controlador específico para atender las peticiones Ajax. Puedes usar métodos de tus controladores habituales. Las peticiones Ajax pueden llegar por GET, POST o cualquier otro método. De hecho, el servidor no tiene modo de saber si han llegado por Ajax o no. Controlador /app/controllers/AjaxController.php class AjaxController extends Controller { public function miMetodo() { ...aquí va mi código... $result = json_encode($mis_variables); echo $result; } } O mejor todavía: class AjaxController extends Controller { public function miMetodo() { $msg = \"This is a simple message.\"; return response()->json($mis_variables); } } Ten en cuenta que: La salida de una petición Ajax suele ser JSON, pero podría ser otra cosa: HTML, XML, o un simple carácter como “0” o “1”. Para responder a una petición Ajax no se debe renderizar una vista, sino que basta con un echo en el controlador. Agregar el token CSRF a las peticiones (1/2) Las peticiones enviadas por POST a Laravel deben llevar el token CSRF o serán rechazadas. El token debe agregarse a cada petición, así: $.ajax({ method: \"POST\", url: \"mi-url\", data: { \"_token\": \"{{ csrf_token() }}\", }, ...etc... }); Agregar el token CSRF a las peticiones (2/2) También puede agregarse automáticamente el token CSRF a todas las peticiones haciendo esto en el header de nuestro layout: A partir de ahora, podremos hacer las peticiones Ajax normalmente, porque el token CSRF se añadirá él solito a cada petición Ajax. ",
    "url": "/ajax/",
    "relUrl": "/ajax/"
  },"24": {
    "doc": "8 Otras tecnologías",
    "title": "Hola, mundo",
    "content": "\" print \" . \" ### 8.3.5. Ejemplo 2 en Python: login con comprobación de email por Ajax url: \"/cgi-bin/login.py\", // URL of the Python script Script Python en el lado del servidor (login.py) #!/usr/bin/python import cgi import MySQLdb # read the CGI params form = cgi.FieldStorage() usuario = form[\"username\"].value; password = form[\"password\"].value; print \"Usuario = \", usuario, \" Pass = \", password # check the username and password in the database db=MySQLdb.connect(host='localhost',user='root',passwd='root',db='perl') cursor=db.cursor() num_rows = cursor.execute(\"SELECT id FROM users WHERE username = '%s' AND password = '%s';\", (usuario, password)) userid = cursor.fetchone() # return JSON string print \"Content-type: application/json\\n\" if num_rows == 0: print \"{'error': 'Usuario o contrase&ntilde;a incorrectos'}\" else: print \"{'success': 'El usuario y la contrase&ntilde;a son v&aacute;lidos', 'userid': '%d'\", userid ## 8.4.NET ### 8.4.1. Características de .NET Fecha de aparición: 1996 (ASP) / 2002 (.NET) Última revisión: 4.7.1 (oct 2017) Perspectivas: Alternativa de Microsoft a JSP para desarrollo de grandes proyectos, donde PHP se queda pequeño. Componentes exclusivos en el servidor y altas prestaciones. Coste más elevado y problemas de seguridad endémicos. Filosofía Framework de código cerrado y propietario. Tecnología multilenguaje. Suele correr con VBS (Visual Basic Script), pero puede hacerlo con otros. Puede funcionar como PHP, embebido dentro de HTML. ASP.Net incluye controles de servidor exclusivos de Microsoft (equivalentes a los ActiveX del lado del cliente) ### 8.4.2. Configuración necesaria en el servidor Instalar Microsoft IIS (Internet Information Server). Viene de serie en los Windows Server. Puede ejecutarse con un módulo de apache (mono), pero es mucho más lento. Cada lenguaje tiene su servidor. Si quieres PHP, usa Apache. Si quieres JSP, usa Tomcat. Si quieres ASP, usa IIS. ### 8.4.3. Sintaxis básica de .NET con VBasic Embeber el código ASP (VBS) en HTML ... Este texto se ha generado desde HTML No es necesario declarar las variables de tipo simple, pero puede hacerse: Dim i,j,k As Integer Algunos operadores: Comparación: , =, =, Asignación: = Algunas estructuras de control do while (condicion) Acciones loop if (condicion) then Acciones-1 else Acciones-2 end if Entrada / Salida // Leer datos de un formulario (GET): variable = request.QueryString(\"campo\"); // Leer datos de un formulario (POST): variable = request.Form(\"campo\"); // Salida: response.write (\"cadena\" + variable + \"cadena2\"); Subrutinas sub nombre(parametros) Acciones; end sub Bibliotecas ### 8.4.4. Ejemplo 1 en VBasic: Hola mundo \") response.write(\" ",
    "url": "/otras-tecnologias/",
    "relUrl": "/otras-tecnologias/"
  },"25": {
    "doc": "8 Otras tecnologías",
    "title": "Hola, mundo",
    "content": "\") response.write(\" . \") %> ### 8.4.5. Ejemplo 2 en VBasic: login con comprobación de email por Ajax url: \"/ruta/al/script.asp\", // URL of the ASP script Script ASP en el lado del servidor (login.asp) ## 8.5. JSP ### 8.5.1. Características del lenguaje JSP Fecha de aparición: 1995 Última revisión: Java 11 (ago 2012) Perspectivas: Usado para proyectos grandes y complejos, donde PHP (y otros lenguajes de scripting) se quedan pequeños. El lenguaje de programación es Java, es decir, lo conoce cualquier programador. Velocidad de ejecución superior a la de otros lenguajes semi-interpretados. Filosofía Adaptación natural de Java al lado del servidor. Orientado a objetos. Multiplataforma. Fuertemente tipado. Puede embeberse dentro de HTML, como PHP. El código Java se precompila en un Servlet y se deja cargado en la memoria del servidor. Las peticiones subsiguientes se ejecutan así mucho más rápidas. ### 8.5.2. Configuración necesaria en el servidor Instalar Tomcat. Es el servidor de referencia para la tecnología JSP. JSP se puede ejecutar como CGI, pero resulta mucho más lento. ### 8.5.3. Sintaxis básica de JSP Embeber el código JSP en HTML ... Este texto se ha generado desde HTML . Las variables se declaran como en cualquier programa Java: int var = 5; out.print(\"La variable var vale \" + var); Algunos operadores: Comparación: , =, ==, != Asignación: = Algunas estructuras de control while (condicion) { Acciones } if (condicion) { Acciones-1 } else { Acciones-2 } Entrada / Salida // Leer datos de un formulario: variable = request.getParameter(\"campo\"); // Salida: out.println (\"cadena\" + variable + \"cadena2\"); Clases y métodos class mi-clase extends clase-madre { public|private|protected tipo nombre(params) { Acciones; } } Módulos import modulo; ### 8.5.4. Ejemplo 1 en JSP: Hola mundo \"); out.println(\" ",
    "url": "/otras-tecnologias/",
    "relUrl": "/otras-tecnologias/"
  },"26": {
    "doc": "8 Otras tecnologías",
    "title": "Hola, mundo",
    "content": "\"); out.println(\" . \"); %> ### 8.5.5. Ejemplo 2 en JSP: login con comprobación de email por Ajax url: \"/ruta/al/script.jsp\", // URL of the JSP script Script JSP en el lado del servidor (login.jsp) ## 8.6. Ruby ### 8.6.1. Características del lenguaje Ruby Fecha de aparición: 1995 Última revisión: 2.6.1 (feb 2013) Perspectivas: Uso y popularidad creciente. Base de programadores fiel y especializada. Excelente relación señal/ruido. Aún tiene que resolver algunas cosas: El lenguaje todavía está en fase de importantes cambios. Tiene peor rendimiento que Python o PHP. Muchos módulos (gemas) están mal documentados. Filosofía Completa – y verdaderamente – orientado a objetos. Todo es un objeto. Admite otros paradigmas ocultos bajo los objetos. “Rápido y fácil”. Es un lenguaje divertido: de programadores para programadores. Curva de aprendizaje larga pero nunca abrupta. Lenguaje de scripting Unix: expresiones regulares. En combinación con Rails, ideal para desarrollo web MVC rápido y basado en prototipos. ### 8.6.2. Configuración necesaria en el servidor Instalar el intérprete Ruby en el sistema. Instalar el módulo de Ruby (mod_ruby) y/o el módulo cgi (mod_cgi) para Apache. Configurar el manejador de Apache para CGI. Instalar módulos adicionales para Ruby (como cgi o mysql) si son necesarios. Como en el caso de Perl o Python, Ruby puede correr de forma nativa en Apache (más rápido pero menos frecuente) o como script CGI. ### 8.6.3. ¿Y Ruby on Rails? ¿Y Ruby on Rails? Rails es un framework para desarrollar aplicaciones web MVC con Ruby. Apareció en 2004 y gustó tanto que otros frameworks para otros lenguajes (como CodeIgniter para PHP) copiaron su forma de trabajar: Abundantes capas de abstracción para evitar tareas de bajo nivel, como ActiveRecord. Scaffolding Integración con Ajax mediante jQuery, Prototype o Script.aculo.us CoC & DRY (Convention over Configuration & Don't Repeat Yourself) ### 8.6.4. Sintaxis básica de Ruby No es necesario declarar las variables. El tipado es dinámico (duck) Todo es un objeto, incluso números enteros o valores constantes: 5.isEven? \"cadena\".lenght variable_cadena.chop! Algunos operadores: Comparación: , =, =, != Asignación: = Algunas estructuras de control while condicion Acciones end if condicion Acciones-1 else Acciones-2 end Sin embargo, el uso de bucles clásicos casi siempre puede sustituirse por iteradores sobre objetos: variable_array.do_each ... end num_rows.times do ... end Entrada / Salida // Leer datos de un formulario require \"cgi\" cgi = CGI.new variable = cgi[\"campo\"]; // Salida: print \"cadena\", variable, \"cadena2\", ... Clases y métodos class nombre_clase \" print \" ",
    "url": "/otras-tecnologias/",
    "relUrl": "/otras-tecnologias/"
  },"27": {
    "doc": "8 Otras tecnologías",
    "title": "Hola, mundo",
    "content": "\" print \" . \" ### 8.6.6. Ejemplo 2 en Ruby: login con comprobación de email por Ajax url: \"/cgi-bin/login.rb\", // URL of the Ruby script Script Ruby en el lado del servidor (login.rb) #!/usr/bin/ruby require \"mysql\" require \"cgi\" begin # connect to the database con = Mysql.new 'server', 'db-user', 'db-password', 'db-name' # retrieve the form params cgi = CGI.new name = cgi[\"username\"] pass = cgi[\"password\"] # check username and password in the database res = con.query(\"SELECT id FROM users WHERE user = '#{name}' AND password = '#{pass}'\") # generate ouput JSON string print \"Content-type: application/json\\n\\n\" if res.num_rows == 0 print %Q!{\"error\": \"Username or password not valid\"}! else row = res.fetch_hash print %Q!{\"success\": \"Authentication is OK\", \"userid\": \"#{row['id']}\" }! end con.close if con end ## 8.7. NodeJS TODO ### 8.7.1. Características del lenguaje NodeJS TODO ### 8.7.2. Configuración necesaria en el servidor TODO ### 8.7.3. Sintaxis básica de NodeJS TODO ### 8.7.4. Ejemplo 1 en NodeJS: Hola mundo TODO ### 8.7.5. Ejemplo 2 en NodeJS: login con comprobación de email por Ajax TODO ## 8.8. Y otras tecnologías aún más extrañas Además de los lenguajes que hemos visto, existen otras alternativas a PHP para desarrollar aplicaciones web en el lado del servidor. A continuación mostramos una lista con alguna de estas alternativas (no están todas las que son, pero sí son todas las que están) para quien quiera profundizar aún más en el asunto: ### 8.2.1. ColdFusion ColdFusion es la alternativa de Adobe. ColdFusion es al mismo tiempo un servidor de aplicaciones y un lenguaje de programación. Utiliza elementos para insertar su código en la página web y, lógicamente, interacciona de manera óptima con otros productos de Adobe, como Flash. Los archivos tienen extensión .cfm. Se diseñó para tener un rendimiento muy elevado (por ejemplo, aprovecha bien la presencia de múltiples procesadores en el servidor) ### 8.2.2. WebDNA WebDNA es un lenguaje especialmente diseñado para hacer scripting del lado del servidor (no como PHP, Perl, Python o Ruby, que fueron pensados para otros propósitos). Especialmente rápido en la interacción con bases de datos. Utiliza etiquetas encerradas entre corchetes [...] para intercalar su código con HTML. ### 8.2.3. Erlang Se trata de un lenguaje para desarrollo de aplicaciones concurrentes (es decir, en las que varios procesos se ejecutan simultáneamente, cooperando en la resolución de un problema). Fue diseñado para sistemas en tiempo real. Se está empezando a usar en el lado del servidor cuando las aplicaciones tienen necesidades de procesamiento brutales. ### 8.2.4. Otros SSJS (SSJS = Server Side JavaScript): hace mucho tiempo que se especula con la posibilidad de programar scripts del lado del servidor en JavaScript. Al fin y al cabo, JS es un lenguaje dominado por cualquier desarrollador web. No existe por ahora ninguna solución estandarizada: a veces, el JS se traduce a Java para ejecutarlo como JSP, otras veces se compila a código nativo del servidor (como hace NodeJS), otras veces se instala un plugin en el servidor para ejecutarlo nativamente, o bien se reduce su uso sólo a generar y procesar información JSON, etc. JS en el lado del servidor necesita siempre de librerías adicionales para acceder a los recursos del servidor (p.ej: bases de datos) ",
    "url": "/otras-tecnologias/",
    "relUrl": "/otras-tecnologias/"
  },"28": {
    "doc": "8 Otras tecnologías",
    "title": "8 Otras tecnologías",
    "content": "# 8. Otras tecnologías ## 8.1. Common Gateway Interface (CGI) CGI es la definición de la interfaz entre los servidores web y las aplicaciones que se ejecutan en el servidor. Estas aplicaciones pueden estar construidas en cualquier lenguaje como Perl, C, scripting de unix, Python o cualquier otro. CGI sólo define la forma de transferir información en ambos sentidos. En el diagrama siguiente vemos el esquema general en que se ejecutan programas en el servidor a través de CGI. Las invocaciones se llevan a cabo a través del llenado de un formulario con los parámetros que se envían al programa que corresponda. Por lo tanto, el primer paso es el acceso al formulario en donde se definen los campos, y el programa que se ejecutará cuando se envíen los datos. El segundo paso es justamente el envío de los datos. El tercer paso es la invocación de la ejecución del programa referenciado (en el ejemplo, “programa 1”). Esta invocación es hecha por el servidor web, quien le traspasa los datos recibidos del cliente. Los programas CGI generan una salida, típicamente un documento HTML, que será enviado al cliente como paso final (cuarto). XXX esquema Ventajas e inconvenientes de CGI El interfaz CGI permite que cualquier programa ejecutable en el servidor pueda usarse para generación dinámica de páginas web. Por eso fue la primera alternativa utilizada para este tipo de páginas. Además, está disponible en muchos servicios de hosting web y es relativamente fácil de configurar. Sin embargo, tiene un serio problema de rendimiento: cada vez que se envían los datos de un formulario se crea un nuevo proceso en el servidor para ejecutar el programa en cuestión, quien genera una respuesta que se envía a través del servidor HTTP al browser, luego de lo cual se elimina el proceso creado. Esta creación de procesos implica una carga importante para el servidor, por lo cual esta modalidad de generación de contenido dinámico no es muy escalable. Existen algunas alternativas para solucionar este problema, como mantener un sólo proceso CGI en memoria que se encargará de procesar todas las peticiones (técnica conocida como FastCGI), pero resulta más complejo de configurar y operar, e implica algunos problemas de seguridad. Variables de entorno CGI La comunicación desde el browser al servidor con los datos del formulario se puede hacer en dos modalidades, a través de variables de entorno (GET) o a través de la línea de comando (POST). Estos datos están disponibles en la variable QUERY_STRING en los envíos con GET y en la entrada estándar en los envíos con POST. Adicionalmente existe un conjunto de variables de entorno que existen en ambas modalidades: • SERVER_SOFTWARE    Devuelve el nombre y la versión del software del servidor de información que contesta la petición de usuario (y ejecuta el programa cgi).  • SERVER_NAME    Devuelve nombre de host del servidor, el alias DNS, o la dirección IP como aparecería en las URL autoreferenciadas. • GATEWAY_INTERFACE    Devuelve la revisión de la especificación CGI con que el servidor puede trabajar. Formato: CGI/revisión. • SERVER_PROTOCOL    Da el nombre y revisión del protocolo de información con el que la petición de usuario viene. Formato: protocolo/revisión.  • SERVER_PORT         Devuelve el número de puerto por el cual fue enviada la petición.  • REQUEST_METHOD    Devuelve el método por el cual la petición fue enviada. Para HTTP serán \"GET\", \"HEAD\", \"POST\", etc • PATH_INFO        La información extra sobre el path, tal como es dada por el cliente. En otras palabras, podemos acceder a los scripts por su pathname virtual, seguido de alguna información extra. Esa información extra es enviada como PATH_INFO. La información será decodificada por el servidor si viene de una URL antes de pasarla al script CGI. • PATH_TRANSLATED    El servidor proporciona una versión traducida del PATH_INFO, que transforma el path virtual al físico. • SCRIPT_NAME    Path virtual al script que va a ejecutar, usado para autoreferenciar URL. • QUERY_STRING    La información que sigue al signo ‘?’ en la URL que referencia al script. Es la información de la pregunta. No deberá ser decodificada de ningún modo. Esta variable será activada cuando hay una petición de información, sin hacer caso de la decodificación de la línea de comandos.  • REMOTE_HOST    El nombre de host que realiza la petición. Si el servidor no posee esta información activará REMOTE_ADDR y dejará esta desactivada. • REMOTE_ADDR    La dirección IP del host remoto que realiza la petición.  • AUTH_TYPE    Si el servidor soporta autentificación de usuario , y el script está protegido, esta es el método de autentificación específico del protocolo para validar el usuario.  • REMOTE_USER    Si el servidor soporta autentificación de usuario , y el script está protegido, este será el nombre de usuario con el que se ha autentificado.  • REMOTE_IDENT    Si el servidor HTTP soporta autentificación RFC 931 , entonces está variable se activará con el nombre del usuario remoto obtenido por el servidor. Esta varible solo se utilizará durante el login.  • CONTENT_TYPE    Para peticiones que tienen información añadida, como HTTP POST y PUT, este será el tipo de datos contenido.  • CONTENT_LENGTH    La longitud del contenido tal como es dado por el cliente. La forma de acceder a estas variables, lógicamente, dependerá del lenguaje que estemos usando. Cada lenguaje proporcionará sus propias librerías para hacer uso de CGI y facilitar el desarrollo de aplicaciones CGI. Respuesta al cliente La respuesta se envía a través de la salida estandar y puede ser cualquier cosa comprensible por el navegador web. Para el caso de texto HTML (que es lo más habitual), se debe comenzar enviando el string: Content-Type: text/html ...seguido de una línea en blanco. Detrás del texto “Content-Type:” puede colocarse cualquier tipo MIME reconocible por el navegador. ## 8.2. Perl ### 8.2.1. Características del lenguaje Perl Fecha de aparición: 1987 Última revisión: 5.30.1 (nov 2019) Perspectivas: Uso decreciente. Apto para tareas pequeñas y rápidas. Cuenta con desarrolladores muy fieles y experimentados. Documentación muy extensa. Soporte amplio en cualquier servidor. Filosofía Versión mejorada del shell scripting de Unix. Pensado para procesamiento rápido de archivos de texto y automatización de tareas de administración del sistema. Favorece la programación ágil, rápida y sucia de scripts. Énfasis en las expresiones regulares. Multiparadigma. En combinación con CGI, se popularizó para aplicaciones web antes de la aparición de PHP. ### 8.2.2. Configuración necesaria en el servidor Instalar el intérprete Perl (usr/bin/perl). Activar los módulos perl y/o cgi de Apache y configurar el handler para CGI. Se puede ejecutar el intérprete Perl de forma nativa en Apache, o bien hacerlo a través de CGI. Lo primero es más difícil de configurar y raramente se encuentra en hostings web compartidos. Instalar módulos Perl adicionales para acceso a bases de datos, etc. ### 8.2.3. Sintaxis básica de Perl Las variables no se declaran, tienen tipado dinámico y son globales por defecto. $var = valor; print \"La variable var vale $variable\"; Algunos operadores: Comparación: lt, gt, le, ge, eq, ne... Asignación: = Algunas estructuras de control while (condicion) { Acciones } if (condicion) { Acciones-1 } else { Acciones-2 } Entrada / salida # Entrada de datos estándar: chop ( $variable = ); # Lectura de datos desde un formulario HTML: use CGI; my $cgi = CGI->new; my $username = $cgi->param(\"username\"); # Salida: print \"cadena $variable cadena...\"; Subprogramas # Comentarios Sub nombre-rutina (argumentos) { Acciones } Bibliotecas use biblioteca ### 8.2.4. Ejemplo 1 en Perl: Hola mundo #!/usr/bin/perl print \"Content-type: text/html\\n\\n\"; print \"Hola mundo\"; print \"Hola, mundo\"; print \" . \"; ### 8.2.5. Ejemplo 2 en Perl: login con comprobación de email por Ajax Formulario HTML Enter information Username . Password . Login . Script AJAX/jQuery $(document).ready(function(){ $(\"form#loginForm\").submit(function() { // loginForm is submitted var username = $('#username').attr('value'); // get username var password = $('#password').attr('value'); // get password if (username && password) { // values are not empty $.ajax({ type: \"GET\", url: \"/cgi-bin/login.pl\", // URL of the Perl script contentType: \"application/json; charset=utf-8\", dataType: \"json\", // send username and password as parameters to the Perl script data: \"username=\" + username + \"&password=\" + password, // script call was *not* successful error: function(XMLHttpRequest, textStatus, errorThrown) { $('div#loginResult').text(\"responseText: \" + XMLHttpRequest.responseText + \", textStatus: \" + textStatus + \", errorThrown: \" + errorThrown); $('div#loginResult').addClass(\"error\"); }, // error // script call was successful // data contains the JSON values returned by the Perl script success: function(data){ if (data.error) { // script returned error $('div#loginResult').text(\"data.error: \" + data.error); $('div#loginResult').addClass(\"error\"); } // if else { // login was successful $('form#loginForm').hide(); $('div#loginResult').text(\"data.success: \" + data.success + \", data.userid: \" + data.userid); $('div#loginResult').addClass(\"success\"); } //else } // success }); // ajax } // if else { $('div#loginResult').text(\"enter username and password\"); $('div#loginResult').addClass(\"error\"); } // else $('div#loginResult').fadeIn(); return false; }); }); Script Perl en el lado del servidor (login.pl) #!/usr/bin/perl -T use CGI; use DBI; use strict; use warnings; # read the CGI params my $cgi = CGI->new; my $username = $cgi->param(\"username\"); my $password = $cgi->param(\"password\"); # connect to the database my $dbh = DBI->connect(\"DBI:mysql:database=mydb;host=localhost;port=2009\", \"mydbusername\", \"mydbpassword\") or die $DBI::errstr; # check the username and password in the database my $statement = qq{SELECT id FROM users WHERE username=? and password=?}; my $sth = $dbh->prepare($statement) or die $dbh->errstr; $sth->execute($username, $password) or die $sth->errstr; my ($userID) = $sth->fetchrow_array; # create a JSON string according to the database result my $json = ($userID) ? qq{{\"success\" : \"login is successful\", \"userid\" : \"$userID\"}} : qq{{\"error\" : \"username or password is wrong\"}}; # return JSON string print $cgi->header(-type => \"application/json\", -charset => \"utf-8\"); print $json; ## 8.3. Python ### 8.3.1. Características del lenguaje Python Fecha de aparición: 1991 Última revisión: 3.8.1 (dic 2019) Perspectivas: Uso creciente. Es el sustituto natural de Perl para el desarrollo rápido de scripts. También usado en grandes proyectos como alternativa a PHP. Menos extendido que PHP, pero comunidad con muchos desarrolladores profesionales (mejor relación señal/ruido) Muchas bibliotecas de terceros → flexibilidad Filosofía Es la versión “limpia” de Perl. Pensado para escribir scripts de forma rápida y limpia. Énfasis en la legibilidad: Python es casi pseudocódigo (código “pythonico” → v. “El Zen de Python”) Interpretado. Tipado dinámico. Fuertemente tipado. Expresiones regulares heredadas de Perl. Multiparadigma: imperativo, O.O., funcional. ### 8.3.2. Configuración necesaria en el servidor Instalar el intérprete Python (/usr/bin/python). El más extendido es CPhyton. Activar los módulos python y/o cgi de Apache y configurar el handler de Apache para CGI. Python puede funcionar de forma nativa integrado en Apache o a través de CGI. Lo primero es más rápido, lo segundo más frecuente. Instalar módulos adicionales (p. ej: para acceso a bases de datos) si es necesario. ### 8.3.3. Sintaxis básica de Python Las variables no se declaran obligatoriamente, tienen tipado dinámico y son locales por defecto. varariable = valor; print \"La variable var vale %s\" (variable); Tiene muchos tipos de datos complejos predefinidos: listas, tuplas, diccionarios... Algunos operadores: Comparación: , =, ==, != Asignación: = Algunas estructuras de control ¡El código debe indentarse OBLIGATO-RIAMENTE! La indentación marca el final del bloque while condicion: Acciones if condicion: Acciones-1 else: Acciones-2 Entrada / salida # Entrada de datos estándar: variable = raw_input(\"Texto\") # Lectura de datos de un formulario HTML: import cgi form = cgi.FieldStorage() campo = form[\"campo\"].value # Salida: print \"cadena %s cadena %s ...\" (variable1, variable2) Subprogramas # Comentarios def nombre-rutina (argumentos): Acciones [return valor1, varlor2...] Módulos import modulo ### 8.3.4. Ejemplo 1 en Python: Hola mundo #!/usr/bin/python print \"Content-type: text/html\\n\\n\" print \"\" print \" ",
    "url": "/otras-tecnologias/",
    "relUrl": "/otras-tecnologias/"
  },"29": {
    "doc": "5.1 Frameworks PHP MVC",
    "title": "5.1 Frameworks PHP MVC",
    "content": "## 5.1. ¿Qué es un framework? Un framework es un conjunto estandarizado de prácticas de programación para resolver un problema concreto. El framework proporciona una serie de clases, librerías y otros componentes para facilitar el desarrollo ágil, seguro y escalable de nuevas aplicaciones. Un framework MVC PHP es un tipo de framework concreto, destinado a servir de base para desarrollar aplicaciones en PHP con arquitectura MVC. ### 5.1.1. ¿Realmente necesito un framework para desarrollar una aplicación web? No, pero en ciertas ocasiones es muy conveniente. Hay programadores pro-frameworks y anti-frameworks. Los programadores anti-frameworks realmente acaban desarrollando su propio framework después de varias aplicaciones MVC. Para decidir si necesitas un framework o no, tienes que conocer antes cómo funcionan y qué ventajas e inconvenientes presentan. Usar un framework tiene ciertas ventajas, como: * Reutilización del trabajo ya hecho (no reinventar la rueda). * Extensa documentación. * Separación en capas. * Seguimiento de buenas prácticas de programación. * Escalabilidad y mantenimiento. * Desarrollo más rápido. Pero también tiene algunos inconvenientes: * A veces pueden limitar el desarrollo. * Curva de aprendizaje costosa (más en unos frameworks que en otros) * Puede llegar a implicar más trabajo, dependiendo del proyecto. * Preferencias personales: algunos programadores solo se sienten cómodos si todo el código es suyo. * Ocultan gran parte del funcionamiento de la aplicación: no son aptos para aprender a programar. En resumen: la idea es que, al usar un framework, solo te centras en desarrollar lo importante. El resto (lo que ya estaba desarrollado) no te quita tiempo. ### 5.1.2. ¿Qué framework escoger? Existen multitud de frameworks MVC PHP. Estos son algunos de gran implantación actual: * Symfony: el más extendido desde hace alos. * Laravel: el que tiene un crecimiento más rápido. * CodeIgniter: el más sencillo, aunque su implantación en la industria el menor. * Otros framworks MVC PHP importantes son Zend Framework, Yii o CakePHP. Puedes pasar el resto de tu vida leyendo en foros y en blogs, descargando e instalando varios frameworks para desecharlos a los dos días, esperando a que salga una nueva versión o un framework nuevo... No hay respuesta a la pregunta: ¿qué framework es mejor? Además, el framework por sí sólo puede no ser suficiente para un desarrollo completo, y probablemente harán falta otros componentes como: * Librerías del lado del servidor (pear, pChart, doctrine...) * Librerías del lado del cliente (jQuery, vue.js, bootstrap...) ",
    "url": "/laravel/1",
    "relUrl": "/laravel/1"
  },"30": {
    "doc": "5.10 Migraciones",
    "title": "5.10 Migraciones",
    "content": "## 5.10. Migraciones ### 5.10.1. ¿Qué son las migraciones? Las migraciones constituyen una especie de control de versiones para la base de datos de la aplicación. Permiten crear y modificar tablas de la BD con independencia del SGBD que estemos usando. Con las migraciones no solo podrás reconstruir la base de datos en menos de lo que tarda en decirse \"Von Neumann\" (algo muy práctico cuando estás en fase de desarrollo), sino que podrás parchear la base de datos de una aplicación en producción en un tiempo record y con riesgo cero. Solo el que ha tenido que parchear la base de datos de una aplicación en producción antes de la existencia de las migraciones sabe la tranquilidad de espíritu que esto produce y la cantidad de problemas embarazosos que te quita de encima. Antes de empezar, recuerda que, para que cualquier operación sobre la base de datos funcione, debes tener bien configurados estas variables de entorno del archivo .env de Laravel: ``` DB_HOST=localhost DB_DATABASE=mi-base-de-datos DB_USERNAME=mi-usuario-de-BD DB_PASSWORD=mi-password-de-BD ``` ### 5.10.2. Crear tablas mediante las migraciones Si, por ejemplo, quisiéramos crear las migraciones de una tabla llamada Clients, los pasos a seguir serían: **Paso 1**: Inicializar el sistema de migraciones de Laravel (si ya lo hemos hecho antes, nos dará un error al intentar hacerlo otra vez): ``` $ php artisan migrate:install ``` **Paso 2**: Crear la migración para la tabla Clients: ``` $ php artisan make:migration create_clients_table ``` Esto generará un fichero en /database/migrations cuyo nombre contendrá un timestamp. Algo como /database/migrations/20201226072434createclientstable.php Si editas ese fichero, verás dos métodos: * up() → se ejecuta cuando se lanza la migración. * down() → se ejecuta cuando se cancela la migración. **Paso 3**: Editar el fichero /database/migrations/createclientstable.php: En el método up() tienes que indicar las columnas que tendrá la tabla. Por ejemplo: ```php public function up() { Schema::create('clients', function (Blueprint $table) { $table->bigIncrements('id')->index();// UNSIGNED BIGINT AUTOINC. $table->string('name',75)->unique(); // VARCHAR $table->text('address')->nullable(); // TEXT $table->integer('level'); // INT $table->date('brith_date'); // DATE // La siguiente línea crea campos created_at y updated_at. Si la borras // esos campos no existirán en tu tabla $table->timestamps(); }); } public function down() { Schema::drop('clients'); } ``` **Paso 4**: Lanzar las migraciones. ``` $ php artisan migrate ``` Esto creará las tablas que no se hayan creado aún. Es decir, si una migración ya se ha lanzado con anterioridad, no se vuelve a ejecutar para no perder los datos que pudieran existir en esas tablas. **Paso 5**: Revertir las migraciones (si es necesario) Si necesitas revertir la creación de todas las tablas: ``` $ php artisan migrate:rollback ``` Para revertir solo el último paso en la creación de tablas: ``` $ php artisan migrate:rollback --step=1 ``` Para dejar la BD a su estado original (vacía): ``` $ php artisan migrate:reset ``` ¡Cuidado! Estas acciones son destructivas. Pero, por supuesto, hay una forma de modificar una tabla sin borrarla y volver a crearla. ### 5.10.3. Modificar tablas mediante migraciones Si necesitas modificar una tabla que ya existe (por ejemplo, para añadir o eliminar campos), tienes dos opciones: 1. Modificar la migración original (en la que se crea la tabla) para añadir o eliminar el campo afectado. Esto te obligará a lanzar la migración de nuevo y, por lo tanto, la tabla se reconstruirá y todos los datos que pudiera contener se perderán. 2. Crear una nueva migración en la que únicamente se haga la modificación de la tabla, sin tocar el resto. Esto respetará los datos que la tabla ya pudiera contener. Como es lógico, la opción 2 será la que preferiremos si la aplicación ya está en producción y necesitamos modificar la estructura de la base de datos. En cambio, durante el desarrollo, puede ser más simple utilizar la opción 1. Supongamos que queremos añadir un campo \"email\" a la tabla \"Clients\" del apartado anterior. Si optas por la opción 2, es decir, por crear una nueva migración que se encargue de hacer esa modificación en la tabla sin alterar sus datos, la forma de proceder es la siguiente: **Paso 1**. Crear la migración: ``` $ php artisan make:migration add_email_to_clients --table=clients ``` (Nota: puedes asignar el nombre que quieras a las migraciones, pero Laravel aconseja utilizar las convenciones que ves en estos ejemplos para simplificarnos la vida) **Paso 2**: Editar la migración /database/migration/add_email_to_clients.php para añadir, en el método up(), el campo nuevo; y, en el método down(), especificaremos qué hay que hacer en caso de que se fuerce un rollback de esta migración: ```php public function up() { Schema::table('clients', function (Blueprint $table) { $table->string('email')->after('address'); }); } public function down() { Schema::table('clients', function (Blueprint $table) { $table->dropColumn('email'); }); } ``` ### 5.10.4. Otras operaciones en las migraciones Las migraciones pueden usarse para cualquier otra operación sobre la estructura de la base de datos, como: * Cambiar tipos de columnas. * Cambiar atributos de columnas (null, unique, default...) * Cambiar o asignar claves primarias y ajenas. Las migraciones construídas de este modo nos permitirán reproducir la base de datos en cualquier servidor o actualizarla en cualquier momento sobre una aplicación en producción sin necesidad de programar parches o exportar la BD a un archivo SQL para importarlo en otro servidor. Más info en: [https://laravel.com/docs/8.x/migrations](https://laravel.com/docs/8.x/migrations) ### 5.10.5. Seeding El seeding es una técnica adicional a la de las migraciones que permite cargar con datos las tablas de la base de datos. Es muy práctico en estos supuestos: * Si quieres tener un conjunto de datos de prueba en tu base de datos de desarrollo (esa que destrozas periódicamente cuando haces pruebas). Con un solo comando, tendrás la base de datos reconstruída como si no hubieras ejecutado un \"DELETE * FROM users\" sin querer. * Si necesitas cargar algunos datos mínimos en algunas tablas para que la aplicación, una vez desplegada en un servidor de producción, funcione (por ejemplo, para crear un usuario administrador en la tabla \"Users\" o para crear algunas entradas en una tabla \"Options\") Para crear un seeder (por ejemplo, para la tabla users), sigue estos pasos: **Paso 1**. Ejecuta el comando: ``` $ php artisan make:seeder UsersTableSeeder ``` **Paso 2**. Editar el seeder /database/seeds/UsersTableSeeder.php y añade algo como esto al método up() (por supuesto, modifica el código para adaptarlo a tu tabla y a tus datos): ```php public function run() { Users::truncate(); // Opativo: vacía la tabla antes de rellenarla DB::table('users')->insert([ 'name' => 'Stephen Falken', 'address' => ' Oregon 97, Goose Island', 'email' => 'sfalken@norad.com', 'brith_date' => '1932-09-03', ]); } ``` **Paso 3**. Ejecuta este comando para lanzar el seeder y que los datos se carguen en tu tabla: ``` $ php artisan db:seed --class=UsersTableSeeder ``` Esto cargará un solo registro en la tabla users. Si quieres más, solo tienes que crear nuevas líneas insert() en el método up(). ### 5.10.5. Automatizar el seeding Lanzar los seeders de uno en uno puede ser muy tedioso. Puedes lanzar varios seeders con un solo comando si haces lo siguiente: **Paso 1**. Edita el fichero /database/seeds/DatabaseSeeder.php **Paso 2**. Añade a la función run() una línea como esta por cada seeder que quiera ejecutar automáticamente: ```php $this->call(UsersTableSeeder::class); ``` **Paso 3**. ¡Y listo! Al ejecutar el comando db:seed de Artisan, sin indicar la clase, se lanzarán todos los seeders que hayas aladido a run(): ``` $ php artisan db:seed ``` ### 5.10.6. Lista de comandos superútiles para manejar migraciones ``` $ php artisan migrate → Lanza todas las migraciones. ``` ``` $ php artisan make:migration --create= → Crea una migración para la tabla indicada. ``` ``` $ php artisan make:migration --table= → Modifica una migración para la tabla indicada. ``` ``` $ php artisan migrate:rollback → Retrocede UN paso en todas las migraciones. ``` ``` $ php artisan migrate:rollback --step= → Retrocede N pasos en todas las migraciones. ``` ``` $ php artisan migrate:reset → Deshace todas las migraciones que se hayan ejecutado hasta ahora. ``` ``` $ php artisan migrate:refresh → Reset + migrate en un solo comando. ``` ``` $ php artisan migrate:refresh --seed → Reset + migrate + seed en un solo comando. ``` ``` $ php artisan migrate:fresh → Elimina todas las tablas y lanza todas las migraciones. ``` ``` $ php artisan migrate:fresh --seed → Elimina todas las tablas, lanza todas las migraciones y todos los seeders. ``` ",
    "url": "/laravel/10",
    "relUrl": "/laravel/10"
  },"31": {
    "doc": "5.11 Usando la BD con Eloquent",
    "title": "5.11 Usando la BD con Eloquent",
    "content": "## 5.11. Usando la BD con Eloquent ### 5.11.1. ¿Qué es Eloquent? Eloquent uno de los componentes de Laravel que permiten al desarrollador manipular los datos de la BD sin rebajarse a escribir sucio SQL. Eloquent es un ORM (Object-Relational Mapping), es decir, una librería que mapea los objetos de nuestra aplicación con una BD relacional. Sí, lo has entendido bien: podrás manejar los datos de tu base de datos como si fueran objetos de tu aplicación. Y, cuando los modifiques, borras o crees, se ejecutará el código SQL necesario (sin que tú te enteres) para traducir esas operaciones en sentencias para la base de datos. Te lo muestro con un ejemplo. Imagina que tenemos una tabla Articles(id, title, body). Con Eloquent, usar esa tabla desde un controlador es tan fácil como hacer algo así: ```php $art = Article::find('7'); // Buscamos un artículo por su id echo $art->title; // Accedemos a los campos de ese artículo $art->body = \"Texto del cuerpo\"; // Modificamos los campos del artículo $art->save(); // Guardamos la modificación en la BD ``` ### 5.11.2. Mola. ¿Cómo puedo usar Eloquent en mi aplicación? Tienes que crear un modelo. ¿Qué te creías? Pero con Artisan es así de fácil: ``` $ php artisan make:model ``` Por ejemplo: ``` $ php artisan make:model Article ``` El modelo se creará en /app/Article.php Nota: si creas el modelo con la opción -m, se creará atomáticamente su migración, lo cual resulta tremendamente práctico: ``` $ php artisan make:model Article -m ``` Ya tienes tu modelo. Si no puedes contener tu curiosidad insaciable y lo abres, verás un archivo bastante decepcionante con este aspecto: ```php ', 100)->get(); // Select con where Article::where('id', '>', 100)->take(10)->get(); // Select con where y take Article::max('id'); // Último id asignado ``` ### 5.11.5. Inserciones y borrados con Eloquent Podemos usar Eloquent para insertar un nuevo artículo desde nuestro controlador: ```php $art = new Article; $art->title = 'Los Chitauri invaden Nueva York'; $art->body = 'Bla, bla, bla'; $art->save(); ``` Si los datos del artículo vienen de un formulario, fíjate en lo alucinantemente fácil que es recoger todos esos datos, crear un objeto Article con ellos y guardar el artículo en la BD: ```php public function store(Request $request) { Article::create($request->all()); // Esto es una ASIGNACIÓN MASIVA de las que hablábamos más arriba!! return ; } ``` Ojo: solo los campos que hayas indicado como \"fillables\" en el modelo se podrán asignar al artículo de este modo. Mira el apartado 5.11.3 si no sabes de qué estamos hablando. Y, por supuesto, también podemos modificar y borrar artículos de la base de datos: ```php $art = Article::find(18); // MODIFICAR $art->body = 'Nuevo cuerpo'; $art->save(); $art = Article::find(13); // BORRAR $art->delete(); ``` ### 5.11.6. Lista de los métodos más útiles de Eloquent * all() → Recupera todos los registros de una tabla. * where(\"campo\", valor) → Aplica claúsula where. * orderBy(\"campo\", \"asc|desc\") → Aplica claúsula order by. * get() → Recupera registros seleccionados. Se suele usar con where y/o order by: * Ciudades::where(\"ciudad\", \"Madrid\")->orderBy(\"id\", \"asc\")->get(); * first() → Recupera el primer registro. * latest() → Recupera el último registro. * find(valor) → Busca registros con ese valor en el campo id. * findOrFail(valor) → Lanza un error 404 si no encuentra el registro. * count(), max(), min()… → Utiliza funciones de agregado de SQL. * save() → Inserta o actualiza registros. * update() → Actualiza registros. * delete() → Elimina registros. ### 5.11.7. Relaciones entre tablas con Eloquent Las relaciones entre tablas también se pueden manejar con Eloquent sin necesidad de andar con INNER JOIN y otros miembros de su nutrida familia. Aunque te parezca al principio que definir las relaciones entre tablas con Eloquent necesita mucho trabajo previo, te garantizo que después te alegrarás de haberlo hecho. Porque las relaciones, una vez definidas, se comportan como consultas y se puede operar con ellas como si lo fueran. En los siguientes ejemplos, vamos a suponer que tenemos estas tablas: * usuarios(id#, nombre, passwd) * emails(id#, email, usuario_id) → Relación 1:1 con usuarios * articulos(id#, titulo, texto, idUsuario) → Relación 1:N con usuarios * roles(id#, nombre) → Relación N:N con usuarios ATENCIÓN: en la tabla “artículos” hemos usado a propósito un nombre no estándar para la clave ajena. La convención de Laravel es usuario_id, como en la tabla “emails”. #### 5.11.7.1. Relaciones 1:1 (usuarios emails) Para definir un relación 1:1 con Eloquent debes hacer lo siguiente: **Paso 1**. En el modelo de la tabla maestra (class Usuario, en nuestro ejemplo) añadimos este método: ```php public function email() { return $this->hasOne('App\\Email'); } ``` **Paso 2**. En el modelo de la tabla relacionada (class Email) añadimos este método: ```php public function usuario() { return $this->belongsTo('App\\Usuario'); } ``` A partir de ahora, se puede recuperar el email de un usuario (o a la inversa) de forma tan sencilla como esta: ```php $email = Usuario::find(1)->email; $user = Email::all()->first()->user; ``` #### 5.11.7.2. Relaciones 1:N (usuarios artículos) Si tienes una relación 1:N (como la que hay entre las tablas de usuarios y artículos de nuestro ejemplo), para definirla en Eloquent tienes que hacer esto: **Paso 1**. En el modelo de la tabla maestra (class Usuario), añade este método: ```php public function articulos() { return $this->hasMany('App\\Articulo', 'idUsuario'); } // ATENCIÓN: hemos tenido que indicar el nombre de la clave foránea // (idUsuario) porque no habíamos respetado la convención de Laravel // (usuario_id) al crear la tabla de artículos ``` **Paso 2**. En el modelo de la tabla relacionada (class Articulo), añade este otro método: ```php public function usuario() { return $this->belongsTo('App\\Usuario'); } ``` Y listo. Ya puedes recuperar los artículos a partir del usuario o a la inversa. Por ejemplo: ```php $articulos = Usuario::find(1)->articulos; foreach ($articulos as $articulo) { // Procesar cada artículo } ``` #### 5.7.11.3. Relaciones N:N (usuarios roles) Si lo que tienes es una relación con cardinalidad N:N (como la que hay entre usuarios y roles en nuestro ejemplo), los pasos a seguir para construirla con Eloquent son estos: **Paso 1**. En el modelo de una de las tablas (class Usuario) añadimos este método: ```php public function roles() { return $this->belongsToMany('App\\Rol'); } ``` **Paso 2**. En el modelo de la otra tabla (class Rol) añadimos este método: ```php public function usuarios() { return $this->belongsToMany('App\\Usuario'); } ``` Ahora, ya se pueden recuperar los roles a partir del usuario o a la inversa. Por ejemplo: ```php $roles = Usuario::find(1)->roles; foreach ($roles as $rol) { // Procesar cada rol } ``` #### 5.7.11.4. Insertar, modificar y borrar en relaciones N:N Insertar, modificar y borrar en relaciones N:N implica escribir datos (normalmente, ids) en la tabla intermedia o tabla pivote. Ese proceso también se puede automatizar con Eloquent. Lo vemos con un ejemplo entre nuestras tablas usuarios y roles. **Para insertar** un usuario y sus roles se usa el método attach(): ```php public function store(Request $r) { $user = new User($r→all()); $user->roles()→attach($r->roles); $user->save(); } ``` **Para actualizar** un usuario y sus roles se usa el método sync(): ```php public function update(Request $r, $id) { $user = User::find($id); $user->fill($r->all()); $user->roles()->sync($r->roles); $user->save(); } ``` **Para eliminar** un usuario y sus roles se usa el método detach(): ```php public function destroy($id) { $user = User::find($id); $user->roles()->detach(); $user->delete(); } ``` #### 5.7.11.5. Problemas frecuentes en relaciones N:N Eloquent supondrá que el nombre de la tabla de la relación se ha formado con los nombres de las dos tablas maestras en snake case y ordenadas alfabéticamente. Por ejemplo, en la relación N:N entre “usuarios” y “roles”, Eloquent supondrá que existe una tabla llamada “roles_usuarios”. Si no es así, la relación fallará. Se puede indicar otro nombre de tabla al definir la relación. Por ejemplo, en el modelo de usuarios (class Usuario): ```php public function roles() { return $this->belongsToMany('App\\Rol', 'usuarios_roles'); } ``` También se pueden indicar los nombres de las claves foráneas si no siguen la convención de Laravel (usuario_id, rol_id, etc) ```php public function roles() { return $this->belongsToMany('App\\Rol', 'usuarios_roles', 'id_usuario', 'id_rol'); } ``` ¿Te has fijado en que hemos creado un método para acceder a la tabla relacionada, pero estamos usando un atributo en su lugar? ```php public function articulos() { return $this->hasMany('App\\Articulo'); } public function loQueSea() { $arts = Usuario::find(1)->articulos; // articulos, no articulos() } ``` Pues bien, el atributo articulo es un “atributo virtual” creado por Eloquent. Pero el método articulos() también existe, y puede usarse como una consulta, extendiéndola como necesitemos. Por ejemplo: ```php $arts = Usuario::find(1)->articulos()->where('titulo','foo')->first(); ``` ",
    "url": "/laravel/11",
    "relUrl": "/laravel/11"
  },"32": {
    "doc": "5.12 Usando la BD con QueryBuilder",
    "title": "5.12 Usando la BD con QueryBuilder",
    "content": "## 5.12. Usando la BD con QueryBuilder ### 5.12.1. ¿Qué es y cómo se utiliza QueryBuilder? Eloquent permite usar la BD de forma simple y elegante en la mayor parte de las circunstancias. Aún así, puede haber situaciones en las que queramos un acceso de más bajo nivel a la BD. Para eso existe QueryBuilder. El grado de abstracción de QueryBuilder es mucho menor que el de Eloquent. Es decir, estaremos CASI escribiendo SQL, sin llegar a hacerlo. Algunos ejemplos de uso te darán una pista de qué tipo cosas se pueden hacer con QueryBuilder: ```php $users = DB::table(\"users\")->get(); $users = DB::table(\"users\")->where(\"name\", \"=\", \"Ana\")->first(); $users = DB::table(\"users\")->where(\"edad\", \">=\", 18)->orderBy(\"apellidos\"); $maxId = DB::table(\"users\")->max(\"id\"); $existe = DB::table(\"users\")->where(\"id\", \"=\", $id)->exists(); $users = DB::table(\"users\")->select(\"nombre, apellidos as apell\")->get(); ``` En la documentación oficial encontrarás una referencia completa de todas las funciones de QueryBuilder, pero con estas que ves en el ejemplo puedes construir prácticamente cualquier consulta sencilla. El resultado de estas consultas es bastante intuitivo: o bien un dato simple (como el $maxId, que es un entero) o bien un objeto de tipo Collection. Las colecciones de Laravel tienen un montón de métodos útiles para procesarlas y puedes echarle un vistazo a la documentación oficial para ello, pero la mayor parte de las veces basta con hacer un foreach sobre la variable para ir accediendo a cada uno de los elementos, que se comportarán como objetos del tipo adecuado. Por ejemplo, para acceder a todos los registros de la tabla de usuarios: ```php $users = DB::table(\"users\")->get(); foreach ($users as $user) { echo $user->name; echo $user->email; ...etc... } ``` ### 5.12.2. Ventajas de QueryBuilder sobre SQL Como ves, QueryBuilder te permite construir sentencias SQL sin necesidad de escribir SQL. La ventaja de esto es triple: 1. No tendremos que depurar nuestros errores sintácticos en SQL, con el ahorro de tiempo que eso conlleva. 2. El SQL generado será 100% compatible con el gestor de base de datos que estemos utilizando. Si escribimos SQL en crudo, tendremos que adaptarlo al dialecto de nuestro gestor de base de datos. Y, si cambiamos de gestor, habrá que revisar todas las sentencias SQL para adaptarlas de nuevo. Todo esto lo evita QueryBuilder, puesto que hace esa adaptación por nosotros. 3. Es imposible que suframos un ataque por inyección de SQL, puesto que QueryBuilder no lo permitirá. ### 5.12.3. Relaciones entre tablas con QueryBuilder Las relaciones entre tablas se manejan con joins, como en SQL, solo que escritos al estilo QueryBuilder. Para hacer un INNER JOIN, puedes usar como referencia este ejemplo: ```php $users = DB::table('users') ->join('contacts', 'users.id', '=', 'contacts.user_id') ->join('orders', 'users.id', '=', 'orders.user_id') ->select('users.*', 'contacts.phone', 'orders.price') ->get(); ``` Por supuesto, también puedes hacer LEFT JOIN y RIGHT JOIN: ```php $resultado = DB::table('A')->leftJoin('B'...); $resultado = DB::table('A')->rightJoin('B'...); ``` ### 5.12.3. SQL crudo Por último, QueryBuilder también te permite escribir SQL crudo, si es que alguna vez lo necesitas. Eso sí, deberías valorar muy bien para qué narices quieres escribir SQL crudo. ¿Estás seguro de que eso que intentas hacer no se puede lograr más fácilmente con Eloquent o con QueryBuilder? Además, tendrás que extremar las precauciones ante un posible ataque por inyección de SQL. Si aún así no te he convencido, puedes ejecutar tu SQL así: ```php $resultado = DB::raw('escribe-aquí-tu-sentencia-SQL'); ``` ",
    "url": "/laravel/12",
    "relUrl": "/laravel/12"
  },"33": {
    "doc": "5.13 Sesiones con Laravel",
    "title": "5.13 Sesiones con Laravel",
    "content": "## 5.13. Sesiones con Laravel Como es lógico, Laravel también proporciona su propio sistema de manejo de variables de sesión, y este resulta mucho más seguro y poderoso que el estándar de PHP. En esta sección vamos a ver cómo funciona y qué posibilidades nos ofrece. ### 5.13.1. Drivers de sesión Las sesiones de configuran en /config/sessions.php, y una de las cosas que debes configurar ahí es el \"driver\", es decir, el tipo de manejador que quieres que manipule las sesiones. El driver por defecto es ***files***. Es el más sencillo y funcionará en casi cualquier servidor. En producción, Laravel recomienda usar otros drivers llamados ***memcached*** o ***redis*** porque son más rápidos. Ambos son daemons del sistema programados para esta tarea. Obviamente, el servidor debe soportarlos para que puedas usarlos. Si necesitas seguridad adicional, sin duda tu driver es ***database***. Esto almacenará dos copias de cada variable de sesión: una en un fichero y otra en una tabla especial de la base de datos. Si un atacante consiguiera manipular una de las dos variables, Laravel cerrará la sesión automáticamente y el atacante se quedará con un palmo de narices. Eso sí, este sistema es el más lento de todos porque requiere un acceso a la base de datos para cada petición al servidor. ### 5.13.2. Persistencia de las variables de sesión Laravel maneja dos tipos de variable según su persistencia: * Variables flash: solo duran una petición y luego se autodestruyen. * Variables de sesión convencionales: existen hasta que las destruimos expresamente. #### 5.13.2.1. Variables flash Son variables de sesión que solo duran una petición y luego se autodestruyen. Se usan típicamente para enviar feedback al usuario. Te lo muestro con un ejemplo. En el controlador: ```php return ('login/form')->with('mensaje', 'Usuario no reconocido'); ``` En la vista: ```php @if (session('mensaje')) {% raw %}{{ session('mensaje'); }}{% endraw %} @endif ``` #### 5.13.2.2. Variables de sesión convencionales Las variables de sesión convencionales se manejan con la clase Session, que tiene un montón de métodos estáticos para crear variables, destruirlas, consultarlas, etc. Los métodos más útiles son: * **put()** -> almacena una variable de sesión: ```php Session::put('nombre-variable', 'valor'); ``` * **push()** -> elimina una variable de sesión: ```php Session::push('nombre-variable'); ``` * **get()** -> devuelve el valor de una variable de sesión: ```php $v = Session::get('nombre-variable'); $v = Session::get('nombre-variable', 'valor-por-defecto'); ``` * **all()** devuelve todas las variables de sesión en un array: ```php $a = Session::all('nombre-variable', 'valor'); ``` * **flush()** elimina todas las variables de sesión: ```php Session::flush(); ``` * **flash()** crea manualmente una variable de sesión de tipo flash: ```php Session::flash('nombre-variable', 'valor'); ``` ### 5.13.3. Autenticación #### 5.13.3.1. Laravel Breeze Laravel proporciona un Starter Kit llamado ***Breeze*** que viene con todo el código necesario para crear un sistema de autenticación completo y seguro: * Login e inicio de sesión * Registro de usuarios * Recuperación de contraseña olvidada * Confirmación de registro mediante email * Etc. Para instalar Laravel Breeze: ``` $ composer require laravel/breeze --dev $ php artisan breeze:install $ npm install $ npm run dev ``` Laravel Breeze crea automáticamente varias rutas en /routes/auth.php, entre ellas: ```php Routes::get(\"/login\") → Para mostrar el formulario de login Routes::post(\"/login\") → Para procesar el formulario de login Routes::post(\"/logout\") → Para cerrar la sesión Routes::get(\"/register\") → Para mostrar el fomulario de registro Routes::post(\"/register\") → Para procesar el formulario de registro ``` También se crean varios controladores como LoginController y RegisterContoller: están en App/Http/Controllers/Auth. Y se crean varias vistas, como auth/login.blade.php, register.blade.php y layouts/app.blade.php (la plantilla que usarán login y register) Por último, se crea una vista HOME de ejemplo (dashboard.blade.php) a la que llegamos después de hacer login. Esa vista HOME la puedes cambiar en /app/providers/RouteServiceProvider.php ¡Y listo! Solo nos queda adaptar estas vistas y controladores a nuestras necesidades. #### 5.13.3.1. Autenticación y vistas: cómo generar código dependiendo del tipo de usuario En las vistas, tenemos un par de directivas de Blade muy útiles relacionadas con las sesiones. ```php @auth ... // Este código se ejecuta si existe un usuario logueado @endauth @guest ... // Este código se ejecuta si NO existe usuario logueado @endguest ``` Además, podemos acceder a los datos del usuario mediante la clase Auth: ```php Auth::user() → Devuelve el usuario actualmente logueado o null si no hay ninguna sesión abierta. Auth::check() → Devuelve true si el usuario actual está logueado. ``` (Más métodos de Auth en https://laravel.com/docs/8.x/authentication) #### 5.13.3.2. Autenticación y middlewares: cómo proteger los controladores Los middlewares son componentes software de Laravel que capturan y filtran todas las peticiones HTTP que llegan a la aplicación. Están ubicados en App/Http/Middleware. Hay dos middlewares relacionados con la autenticación en Laravel: Authenticate (alias \"auth\") y RedirectIfAuthenticated (alias \"guest\"). Los alias se definen en App/Http/Kernel.php. Podemos usar estos middlewares en el constructor de nuestros controladores para protegerlos en todo o en parte: ```php public function __construct() { // Solo usuarios logueados podrán acceder a este controlador: $this->middleware(\"auth\"); // Solo usuarios logueados podrán acceder a los métodos create() y edit(): $this->middleware(\"auth\")->only(\"create\", \"edit\"); // Solo usuarios logueados podrán acceder al controlador excepto a show(): $this->middleware(\"auth\")->except(\"show\"); } ``` El middleware auth también puede usarse en el enrutador, para proteger todo el controlador, así: ```php Route::get('/ruta-a-proteger', 'Controlador@metodo')->middleware('auth'); ``` ",
    "url": "/laravel/13",
    "relUrl": "/laravel/13"
  },"34": {
    "doc": "5.14 Helpers de Laravel",
    "title": "5.14 Helpers de Laravel",
    "content": "## 5.14. Helpers de Laravel ### 5.14.1. ¿Qué son los helpers? Un helper es un componente del framework diseñado para facilitar alguna tarea típica en el desarrollo de una aplicación web. Por ejemplo: el helper url('ruta') genera una ruta absoluta para referenciar cualquier componente de la aplicación: ```html Volver ``` Generará este código: ```html Volver ``` Eso permite que la ruta sea correcta en cualquier servidor, sin necesidad de modificar el código fuente. El uso de los helpers es optativo: el programador/a debe decidir si le resultan útiles o no. Los helpers van cambiando mucho de una versión a otra de Laravel, por lo que te recomiendo que eches un vistazo a la documentación oficial para saber qué helpers están disponibles en tu versión de Laravel. Puedes encontrar una lista completa de helpers en: https://laravel.com/docs/X.x/helpers (sustituye X.x por tu versión de Laravel) ### 5.14.2. Algunos helpers útiles de Laravel #### 5.14.2.1. url helper ```html Volver ``` Generará este código: ```html Volver ``` Eso permite que la ruta sea correcta en cualquier servidor, sin necesidad de modificar el código fuente. #### 5.14.2.2. route helper Es parecido a url(), pero sirve para routas con nombre en el enrutador. Por ejemplo, si en el enrutador tenemos una ruta como esta: ```php Route::get(\"mi-ruta\", \"metodo@mi-controlador\")->name(\"nombre-ruta\"); ``` ...podemos referirnos a ella como: ```html Texto ``` ...o como: ```html Texto ``` La segunda forma es la mejor: permite cambiar la dirección que ve el usuario sin modificar el código fuente. #### 5.14.2.3. request helper Proporciona acceso a información sobre la petición (GET, POST o la que sea) con la que se cargó la página: * **request()->url()** → Devuelve un string con la ruta actual (completa). * **request()->path()** → Devuelve un string con la ruta actual (solo desde la raíz de la aplicación, sin http ni el nombre del servidor). * **request()->is(\"ruta\")** → Devuelve true si \"ruta\" coincide con la ruta actual. Admite wildcards (símbolos * y ?). * **request()->input(\"campo\")** → Devuelve el valor de \"campo\" (enviado desde formulario). * **request()->all()** → Devuelve un array con todos los campos. * **request()->has(\"campo\")** → Devuelve true si en la petición existe un campo con el nombre indicado. * **request()->isMethod(\"método\")** → Devuelve true si la petición se hizo por el método indicado (POST, GET, PUT, etc). El helper Request puede usarse en las vistas (como request()->url(), por ejemplo) o inyectarse en las funciones del controlador como una variable, así: ```php public function mi-función(Request $request) ``` #### 5.14.2.4. redirect helper Muy útil cuando queremos redirigir al usuario hacia otra URL o acción (por ejemplo, para evitar que al pulsar F5 se reenvíen los datos de un formulario). Admite varias formas: ```php return redirect('user/login'); return redirect()->action('LoginController@login'); return back(); ``` #### 5.14.2.5. auth helper Como vimos en la sección de sesiones y autenticación, este helper permite saber si existe algún usuario autenticado en la aplicación. auth()->user() devuelve el usuario autenticado (como un objeto) o null si nadie ha hecho login. Con el objeto User podemos acceder a todos los datos del usuario: ```php $user = auth()->user(); Bienvenido/a, {% raw %}{{ $user->name }}{% endraw %}. Este es su emial: {% raw %}{{ $user->email }}{% endraw %} ``` #### 5.14.2.6. errors helper Se utiliza para conocer y mostrar los errores ocurridos en la validación de un formulario (v. apartado de validación de formularios). La variable $errors está disponible en todas las vistas gracias a que un Middleware (ShareErrorsFromSession) la inyecta automáticamente. Algunos métodos útiles son: * **$errors->all()** → devuelve un array con todos los errores detectados. * **$errors->any()** → devuelve true si se ha detectado algún error. * **$errors->first(\"campo\")** → devuelve el primer error de todos los que puedan afectar al campo indicado. ",
    "url": "/laravel/14",
    "relUrl": "/laravel/14"
  },"35": {
    "doc": "5.15 Flujo de trabajo típico con Laravel",
    "title": "5.15 Flujo de trabajo típico con Laravel",
    "content": "## 5.15. Flujo de trabajo típico con Laravel Lo que vas a encontrar aquí es solo un posible flujo de trabajo con Laravel, es decir, una propuesta del orden en el que debes hacer las cosas para desarrollar una aplicación con este framework. No es el único flujo de trabajo posible, y sin duda no es el mejor, pero puede resultarte útil en tus primeros desarrollos, como si alguien te llevara de la mano a lo largo de un camino sinuoso. Más adelante, cuando vayas adquiriendo experiencia, tú mismo/a crearás tu propio flujo de trabajo ideal. El flujo que te propongo tiene los siguientes pasos (los cuatro primeros son solo para aplicaciones nuevas): 1. Instalar y configurar nueva aplicación. 2. Crear modelos (se supone que ya tendrás la BD diseñada). 3. Crear migraciones y seeders. 4. Lanzar las migraciones y seeders para crear y poblar la BD. 5. Crear en el enrutador las entradas de la funcionalidad que vas a programar. 6. Crear el controlador (si no existe) para la funcionalidad que vas a programar. 7. Crear las funciones del controlador necesarias. 8. Crear las funciones del modelo necesarias (si no existen ya). 9. Crear las vistas necesarias. 10. Probar. 11. Repetir los pasos 5-10 para cada funcionalidad adicional. ",
    "url": "/laravel/15",
    "relUrl": "/laravel/15"
  },"36": {
    "doc": "5.16 Laravel y Vue.js",
    "title": "5.16 Laravel y Vue.js",
    "content": "## 5.16. Laravel y Vue.js ",
    "url": "/laravel/16",
    "relUrl": "/laravel/16"
  },"37": {
    "doc": "5.17 Aspectos avanzados de Laravel",
    "title": "5.17 Aspectos avanzados de Laravel",
    "content": "## 5.17. Aspectos avanzados de Laravel TODO ### 5.17.1. Traducciones TODO ### 5.17.2. Paginación de resultados TODO ### 5.17.3. Páginas de error personalizadas TODO ### 5.17.4. URLs amigables: Routes model bindings TODO ### 5.17.5. Validación avanzada de formularios con form requests TODO ### 5.17.6. Laravel Mix TODO ### 5.17.7. Crear helpers y middlewares TODO ### 5.17.8. Collections TODO ### 5.17.9. Eventos y Listeners TODO ### 5.17.10. Actualizar la versión de Laravel de una aplicación existente sin tirarse por la ventana en el intento TODO ### 5.17.11. Mejora del rendimiento. Caché. TODO ### 5.17.12. Decoradores e interfaces TODO ### 5.17.13. Pruebas con Mockery y Selenium TODO ",
    "url": "/laravel/17",
    "relUrl": "/laravel/17"
  },"38": {
    "doc": "5.2 Características de Laravel",
    "title": "5.2 Características de Laravel",
    "content": "## 5.2. Características de Laravel Laravel es un framework PHP MVC para desarrollo rápido de aplicaciones web. Automatiza muchos procesos habituales y tiene una curva de aprendizaje empinada, pero no tanto como otros frameworks (como Symfony). Desde hace algunos años, Laravel ha experimentado un crecimiento espectacular en el mercado de las aplicaciones web. ### 5.2.1. Ventajas de Laravel 1. Sintaxis simple y elegante. 2. Mapeo objeto-relacional (ORM): Eloquent. 3. Potente sistema de plantillas para vistas: Blade. 4. Reutiliza y moderniza componentes de Symfony. 5. Sencillo y potente. 6. Uso creciente en la industria: alternativa de futuro. 7. Comunidad de usuarios altamente especializada (buena relación señal/ruido… de momento) ### 5.2.2. Inconvenientes de Laravel 1. Instalación, configuración y despliegue complejos, incluso a través de VM. 2. Curva de aprendizaje elevada. 3. Se mueve según los intereses personales de su autor (es obra individual), con actualizaciones muy frecuentes y cambios caprichosos. 4. Inestabilidad de varios de sus componentes: a menudo hay que recurir a fixes. 5. Fuerte dependencia de la consola de comandos y de herramientas de terceros (composer, vagrant, npm...) (Esto solo es un inconveniente para algunas personas) ",
    "url": "/laravel/2",
    "relUrl": "/laravel/2"
  },"39": {
    "doc": "5.3 Instalación de Laravel",
    "title": "5.3 Instalación de Laravel",
    "content": "## 5.3. Instalación de Laravel ### 5.3.1. Instalación en servidor local No es recomendable instalar Laravel de forma nativa en tu servidor local porque requiere una fuerte configuración del servidor. Tendrás que instalar bastante librerías que consumirán recursos de tu máquina sin necesidad, tales como OpenSSL, Mbstring o Tokenizer. También necesitas instalar composer, la herramienta de resolución de dependencias de PHP. Por todo ello, es recomendable optar por la virtualización del servidor mediante Vagrant (Homestead) o Docker. Discutiremos estas dos opciones más adelante. Si, aún así, estás decidido a instalar Laravel de forma nativa en tu servidor local, sigue estos pasos: **Paso 1**. Descarga Laravel. ``` $ composer global require \"laravel/installer\" ``` **Paso 2**. Instala copia de Laravel limpia y lista para usar (hacerlo en un directorio accesible por Apache). Puede requerir añadir el comando laravel al PATH del sistema. ``` $ laravel new ``` Por ejemplo: ``` $ laravel new blog ``` No olvides dar los permisos necesarios a tus archivos y directorios. Los problemas que pueden surgir son múltiples e insospechados, dependiendo de la configuración de tu servidor. Puedes intentar seguir alguna de estas guías: * [Guía para instalar Laravel en localhost en Ubuntu Linux](https://www.howtoforge.com/tutorial/install-laravel-on-ubuntu-for-apache/) * [Guía para instalar Laravel en localhost con Windows y XAMPP:](https://weeklyhow.com/installing-laravel-8-with-xampp/) ### 5.3.2. Instalación de Laravel con máquina virtual Vagrant (Homestead) Vagrant es una herramienta para crear un entorno de desarrollo virtual sin necesidad de instalar componentes en nuestra máquina. Cada entorno de desarrollo se llama Box y hay cientos de ellos. **Homestead** es un Box de Vagrant con todo lo necesario para desarrollar con Laravel sin necesidad de configurar nuestro servidor local. Este Box, creado por los propios desarrolladores de Laravel, puede configurarse para equipararlo al servidor donde se vaya a desplegar la aplicación en el futuro. La instalación de Laravel en Homestead es la forma recomendada para desarrollar proyectos Laravel en un entorno local. La puesta en producción es otra historia, y dependerá de las posibilidades de configuración del servidor. Instalar Laravel con Homestead en tu entorno local puede parecer un proceso largo y complejo, pero no suele dar problemas y la fiabilidad de está solución está garantizada, por lo que es la manera más recomendable. Si deseas instalarlo, sigue estos pasos: **Paso 1**. Instala la última versión disponible de Virtual Box. **Paso 2**. Instala Vagrant y git **Paso 3**. Agrega a Vagrant el box de Homestead: ``` $ vagrant box add laravel/homestead ``` **Paso 4**. Consigue el último código fuente de Laravel: ``` $ git clone https://github.com/laravel/homestead.git ~/Homestead ``` **Paso 5**. Selecciona la rama \"release\" del repositorio de Laravel y lanza el script de inicialización: ``` $ cd Homestead $ git checkout release $ bash init.sh (o init.bat en Windows) ``` **Paso 6**. Edita el archivo Homestead.yaml para configurar tu máquina virtual. **Paso 7**. Edita el archivo hosts (/etc/hosts o C:\\Windows\\System32\\drivers\\etc\\hosts) para añadir esta línea: ``` 192.168.10.10 homestead.test ``` (Cámbiala por la IP que hayas configurado en el archivo .yaml) **Paso 8**. Levanta la máquina virtual Homestead: ``` $ vagrant up ``` (Este comando hay que ejecutarlo desde el directorio Homestead) La primera vez puede tardar un rato mientras crea y configura la VM. **Paso 9**. Prueba en el navegador la dirección: http://homestead.test. El servidor debería responder. **Paso 10**. Prueba a acceder a la VM mediante ssh con el comando: ``` $ vagrant ssh ``` **Paso 11**. En la máquina real, crea el directorio ~/code (o el que esté configurado en el archivo Homestead.yaml). **Paso 12**. En la máquina virtual, ve al mismo directorio ~/code (o el que esté configurado en Homestead.yaml) y actualiza las librerías PHP con composer: ``` $ composer create-project laravel/laravel code --prefer-dist $ composer install ``` ¡Y listo! Tú trabajarás en tu directorio local ~/code y cualquier cambio que hagas se mapeará automáticamente al directorio ~/code en la VM. Mantén una consola abierta en la VM para ejecutar comandos artisan. Ten en cuenta que MySQL estará escuchando en 127.0.0.1:33060 (user “Homestead”, password “secret”, salvo que hayas cambiado la configuración) (¡Ojo! Esto es para conexiones desde fuera de Homestead. Desde el punto de vista de la app, MySQL seguirá estando en localhost:3306) Es posible que necesites generar una clave SSH para conexiones seguras con tu servidor virtual. * [Cómo hacerlo en Linux](https://ekiketa.es/fallo-en-homestead-check-your-homestead-yaml-file-the-path-to-your-private-key-does-not-exist/) * [Cómo hacerlo en Windows 10](https://medium.com/@eaimanshoshi/i-am-going-to-write-down-step-by-step-procedure-to-setup-homestead-for-laravel-5-2-17491a423aa) Más info en [https://laravel.com/docs/8.X/homestead](https://laravel.com/docs/8.X/homestead) ### 5.3.3. Laravel con Docker Docker es una solución de virtualización aún más ligera que Vagrant. Con Docker, se virtualizan solo los componentes software que nuestra aplicación necesita para funcionar, y se ejecutan directamente en la máquina anfitrión. Los componentes se llaman ***images***. Cuando se instancian, pasan de denominarse ***containers***. Hay docker images para todo lo imaginable. Puedes encontrarlas en [https://hub.docker.com](https://hub.docker.com). Aunque Laravel recomienda la virtualización mediante Vagrant, muchos desarrolladores optan por Docker por su mayor simplicidad y eficiencia. Para instalar Laravel mediante Docker para un desarrollo local, sigue estos pasos: **Paso 1**. Instala docker (y, optativamente, docker-compose) en tu servidor. **Paso 2**. Busca una imagen de Laravel en https://hub.docker.com. Por ejemplo, Bitnami (una empresa propiedad de VMWare) tiene imágenes bastante fiables. **Paso 3**. Crea un directorio para tu aplicación web. No importa en qué parte del árbol de directorios local estés. **Paso 4**. En la consola, teclea el comando para crear una copia local de las imágenes necesarias. En el caso de la imagen Laravel de Bitnami, el comando es: ``` $ docker pull bitnami/laravel ``` **Paso 5**. Sigue las instrucciones para el despliegue del contenedor que el desarrollador ha debido colgar en hub.docker.com. En el caso de bitnami, hay que copiar un archivo remoto mediante el comando curl y levantar las imágenes docker con docker-compose. ¡Y listo! Nuestro Laravel estará funcionando con todas sus dependencias resueltas. ",
    "url": "/laravel/3",
    "relUrl": "/laravel/3"
  },"40": {
    "doc": "5.4 Arquitectura, convenciones y configuración de Laravel",
    "title": "5.4 Arquitectura, convenciones y configuración de Laravel",
    "content": "## 5.4. Arquitectura, convenciones y configuración de Laravel ### 5.4.1. Estructura de directorios Después de una instalación limpia de Laravel, nos encotraremos con una estructura típica de directorios. Los más importantes (al menos, para empezar) son estos: **composer.json**: información para composer. **/app**: el código de nuestra aplicación. Modelos. **/app/config**: configuración de la aplicación. **/app/http**: peticiones HTTP, incluyendo los controladores. **/database**: migraciones de la BD. **/plugins**: pues eso. **/public**: directorio de acceso público. Aquí se pueden colocar imágenes, scripts o archivos css. **/resources**: assets (imágenes, css, js), archivos de idioma y vistas. **/storage**: caché, sesiones, vistas compiladas... **/vendors**: librerías de terceros. ### 5.4.2. Convenciones en Laravel Laravel tiene un montón de convenciones que persiguen hacer más sencilla la configuración de la aplicación. Aunque la mayoría no son obligatorias, es recomendable respetarlas para evitar errores de configuración y conflictos con los identificadores. * **Modelos**: Nombres igual que el de la tabla, en singular, en CamelCase y con mayúscula. Ejemplo: RegisteredUser * **Controladores**: como el modelo, pero añadiendo la palabra \"controller\" o \"controlador\". Ejempo: RegisteredUserController * **Métodos**: en camelCase empezando con minúscula. Ejemplo: User::getAll() * **Atributos**: en snake_case empezando con minúscula. Ejemplo: User::first_name * **Variables**: en camelCase empezando con minúscula. Ejemplos: bannedUsers (colección, en plural), articleContent (variable simple, en singular) * **Tablas**: en plural y en snake_case. Ej: registered_users. * **Columnas**: en snake_case, sin referencia al nombre de la tabla. Ejemplo: first_name * **Clave primaria**: id (integer y auto-increment). * **Claves ajenas**: nombre tabla ajena en singlular + id. Ejemplo: article_id * **Timestamps**: created_at y updated_at * **Tablas pivote**: en snake_case, en plural y orden alfabético. Ejemplo: articles_users será el pivote entre articles y users. ### 5.4.3. Variables de entorno. El archivo .env Este archivo contiene todas las variables de entorno que configuran la aplicación, como: * APP_ENV: ¿estamos en desarrollo o en producción? * APP_DEBUG: ¿mostrar errores para depuración? * APP_URL: URL base de la aplicación * DB_CONNECTION, DB_HOST, DB_USERNAME, etc. El archivo example.env contiene una plantilla para que puedas construir tu archivo .env. Simplemente, renombra el archivo example.env y asigna los valores correctos a las variables de entorno. El archivo .env NO debe sincronizarse con git (o con el control de versiones que usemos) porque contiene información sensible. En los archivos de configuración haremos referencia a las variables de entorno. Por ejemplo: en /config/database.php usaremos una expresión así: ``` 'default' => env('DB_CONNECTION', 'mysql') ``` El primer parámetro de env() es la variable de entorno y el segundo es el valor por defecto en caso de que la variable no exista. ### 5.4.4. Archivos de configuración del directorio /config En este directorio encontraremos multitud de archivos que configuran el funcionamiento de Laravel. En principio, no es necesario modificar ninguno, porque las configuraciones básicas se manejan desde el archivo .env. Sin embargo, hay veces que sí necesitaremos acceder a estos archivos y tocar alguna configuración. Los archivos de configuración más importantes que puedes encontrar aquí son: **database.php**: configuración de la conexión a la base de datos. Toma sus valores principales de .env, pero desde aquí podemos cambiar otras cosas, como el controlador (por defecto es MySQL, pero podemos cambiarlo a PostgreSQL, SQLite, etc) **app.php**: nombre de la aplicación, estado (desarrollo, producción...) **session.php**: forma en la que se almacenarán las sesiones (por defecto, en fichero) ",
    "url": "/laravel/4",
    "relUrl": "/laravel/4"
  },"41": {
    "doc": "5.5 Artisan",
    "title": "5.5 Artisan",
    "content": "## 5.5. Artisan: la consola que mola ### 5.5.1. ¿Qué es Artisan y cómo se utiliza? Artisan es una herramienta de consola que automatiza las tareas habituales en Laravel como: * Generar esqueletos de controladores y modelos. * Crear migraciones de bases de datos (para manipular la estructura de las tablas) * Rellenar la BD con datos de prueba. * Hacer el enrutamiento. * Configurar la aplicación. * Crear baterías de pruebas. * Y otro montón de cosas. No te preocupes si aún no entiendes qué significan algunas de estas cosas. Lo iremos viendo todo poco a poco. Lo importante ahora es que comprendas la tremenda utilidad de Artisan en el trabajo cotidiano con Laravel y que aprendas lo básico de su sintaxis. Por ejemplo, para crear un controlador, existen dos maneras: 1. A mano. Nos vamos al directorio /app/Http/Controllers y creamos un archivo llamado, digamos, HolaController.php. Luego lo rellenamos con el esqueleto de un controlador vacío, copiando y pegando de otro controlador existente y eliminando todo lo que no nos haga falta. Este método, obviamente, es lento, farragoso y resulta fácil que comentamos algún error. 2. Con ayuda de artisan. Simplemente, tecleamos este comando en el directorio raíz de nuestra aplicación: ``` $ php artisan make:controller HolaController ``` Y listo. Artisan creará por nosotros el archivo /app/Http/Controllers/HolaController.php y lo rellenará con el esqueleto de un controlador vacío. ### 5.5.2. Artisan y máquinas virtuales Si utilizas Laravel con una máquina virtual (Homestead o Docker), tienes que hacer login en la máquina virtual para poder usar ejecutar los comandos de Artisan. Con Vagrant: ``` $ vagrant ssh ``` Con Docker: ``` $ docker exec -it bash ``` Una vez dentro de la máquina virtual, accede al directorio de tu aplicación y podrás ejecutar cualquier comando de Artisan. ### 5.5.3. Comandos principales de Artisan Si tecleas: ``` $ php artisan list ``` ...obtendrás una lista con todos los comandos de Artisan válidos en tu instalación de Laravel. Esto puede variar según tu versión de Laravel y los componentes que tengas instalados. En un primer momento, necesitarás conocer estos comandos: * php artisan db:migrate --> Para hacer migraciones (crear la estructura de nuestra base de datos). * php artisan db:seed --> Para llenar de datos predefinidos nuestra base de datos. * php artisan make:migration --> Crea una migración (para crear la estructura de la base de datos). * php artisan make:seeder --> Crea un seeder (para rellenar con datos las tablas). * php artisan make:controller --> Para crear un controlador. * php artisan make:model --> Para crear un modelo. * php artisan route:list --> Muestra todas las rutas definidas en el enrutador. ",
    "url": "/laravel/5",
    "relUrl": "/laravel/5"
  },"42": {
    "doc": "5.6 Primeros pasos con Laravel. Hola mundo",
    "title": "5.6 Primeros pasos con Laravel. Hola mundo",
    "content": "## 5.6. Primeros pasos con Laravel: Hola mundo En esta sección vamos a crear nuestra primera aplicación funcional con Laravel: el tradicional \"Hola mundo\". Nos servirá para aprender la dinámica de trabajo con Laravel y para construir un esqueleto de aplicación sobre la que montar algo más grande más adelante. **Crea una clave segura** Ejecuta el comando: ```php php artisan key:generate ``` Esto genera una clave aleatoria y la almacena en el archivo de configuración /.env Es necesaria para hacer conexiones seguras con la aplicación. En versiones recientes de Laravel es obligatorio crearla. **Probando el enrutador** Vamos a empezar probando algo sencillo: capturar una ruta. Edita el archivo /routes/web.php y añade esto: ```php Route::get('/hola', function() { return \"Hola, mundo\"; }); ``` Esto significa que, cuando escribas la ruta \"hola\" en la barra de direcciones del navegador, se ejecutará esta función anónima (también denominadas ***closures***) y, como resultado, se verá el texto \"Hola, mundo\" en la ventana del navegador. Pruébalo en el navegador la dirección: http:///index.php/hola **Enrutar al controlador** Ahora vamos a hacer que la misma ruta de antes provoque la ejecución de una función en un controlador. Edita el enrutador /routes/web.php, sustituye la ruta anterior por esto: ```php Route::get('/hola', 'HolaController@index'); ``` Esto indica al enrutador que, al recibir la ruta \"hola\", se debe ejecutar el método index() del controlador HolaController. Ahora tienes que crear ese controlador: ```php $ php artisan make:controller HolaController ``` Por último edita el controlador /app/Http/Controllers/HolaController.php: ```php public function index() { return \"Hola, mundo\"; } ``` Comprueba que funciona en el navegador: http:///index.php/hola (NOTA IMPORTANTE: desde Laravel 8, para que esto funcione es necesario descomentar la siguiente línea del archivo /app/Providers/RouteServiceProvider.php: // protected $namespace = 'App\\Http\\Controllers'; ) **Cargar una vista en el controlador** Vamos a variar el código anterior para que el método del controlador no produzca la salida HTML directamente, sino que invoque a una vista que genere el HTML. Además, vamos a inyectar en la URL una variable con el nombre del usuario para mostrar cómo se capturan esos valores y cómo se pasan a las vistas. Comenzamos modificando el enrutador /routes/web.php (observa cómo se indica la presencia de una variable en la URL): ```php Route::get('/hola/{nombre}', 'HolaController@show'); ``` Ahora creamos un método show() en el controlador /app/Http/Controllers/HolaController.php ```php public function show($nombre) { $data['nombre'] = $nombre; return view('hola', $data); } ``` Como ves, estamos invocando una vista llamada \"hola\" y le estamos pasando un array con los datos necesarios (el nombre del usuario, en este caso). Esa vista debe crearse en /resources/views/hola.blade.php y puede tener este aspecto: ```html Saludos, {% raw %}{{$nombre}}{% endraw %}. ¿Le apetece una partidita de ajedrez? ``` Puedes probar esta nueva ruta cargando en el navegador la ruta http:///index.php/hola/ProfesorFalken. La respuesta debería ser esta: ``` Saludos, ProfesorFalken. ¿Le apetece una partidita de ajedrez? ``` Recuerda que, desde Laravel 8, el funcionamiento del enrutador ha cambiado. Para conservar compatibilidad hacia atrás, hay que abrir el archivo /app/Providers/RouteServiceProvider.php y descomentar esta línea: ```php // protected $namespace = 'App\\Http\\Controllers'; ``` Hay otras soluciones que [se describen aquí](https://litvinjuan.medium.com/how-to-fix-target-class-does-not-exist-in-laravel-8-f9e28b79f8b4). ",
    "url": "/laravel/6",
    "relUrl": "/laravel/6"
  },"43": {
    "doc": "5.7 Enrutamiento",
    "title": "5.7 Enrutamiento",
    "content": "## 5.7. Enrutamiento Ya sabemos crear una aplicación Laravel simple (como \"Hola, mundo\") y hemos aprendido varias cosas sobre el enrutador. En esta sección, profundizaremos en este componente fundamental de cualquier aplicación web. ### 5.7.1. ¿Qué es el enrutador? El enrutador de Laravel es el componente que captura las URL solicitadas al servidor y las traduce a invocaciones a métodos de los controladores. El enrutador es capaz, además, de mapear fragmentos de la URL a variables PHP que serán inyectadas como parámetros a los métodos del controlador. También puede distinguir el verbo http empleado para solicitar una página al servidor. Es decir, para el enrutador no es lo mismo una solicitud enviada por GET que otra enviada por POST. Incluso admite verbos que aún no están soportados por http, como DELETE o PUT, y que teóricamente van a formar parte de futuras implementaciones del protocolo. ### 5.7.2. Enrutamiento básico Como vimos en el ejemplo del \"Hola, mundo\", hay varias formas de generar una salida HTML desde el enrutador (/routes/web.php). En este código de ejemplo vemos las más básicas: ```php // Forma 1: generar la salida con un closure (función sin nombre) Route::get('/hola', function() { return \"Hola, mundo\"; }); // Forma 2: llamar a un controlador sin pasarle parámetros Route::get('/hola', 'HolaController@show'); // Forma 3: llamar a un controlador pasándole parámetros Route::get('/hola/{nombre}', 'HolaController@show'); // Forma 4: llamar a un controlador con un parámetro optativo Route::get('/hola/{nombre?}', 'HolaController@show'); ``` ### 5.7.3. Rutas con nombre Es MUY recomendable asignar un nombre a las rutas en el enrutador. Esto hace que, más adelante, podamos cambiar la URL de los enlaces sin tener que modificar el código fuente de nuestras vistas. ```php Route::get('/contactame', 'Controlador@contacto')->name('contact'); ``` Internamente, esta ruta se direccionará con la expresión route('contact') (ya veremos exactamente cómo), pero el usuario verá la dirección http://servidor/contactame. En el futuro se puede cambiar la forma en la que lo ve el usuario, pero para el código fuente seguirá siendo route('contact') ### 5.7.4. Verbos http: GET, POST, PUT y DELETE Además de GET, en el enrutador se puede enrutar otras acciones: ```php Route::get(); // Solicitudes habituales Route::post(); // Recepción de datos de formulario (para insert) Route::put|patch(); // Recepción de datos para update Route::delete(); // Recepción de datos para delete Route::match(array('GET','POST'), 'ruta', acción) // Responderá tanto a GET como a POST ``` Los métodos de formulario PUT y DELETE no están soportados aún por http ni por HTML. Hay que emularlos en los formularios así: ```html @method('DELETE') ``` ### 5.7.5. Orden de las rutas El orden de las rutas es importante. Por ejemplo, si pedimos la dirección http:///usuario/crear, estas rutas fallarán: ```php Route::get('usuario/{nombre}', 'UsuarioController@show'); Route::get('usuario/crear', 'UsuarioController@create'); ``` El problema es que tratará de mostrar un contacto con nombre = \"crear\", porque la petición encaja con las dos rutas y el enrutador siempre elegirá la primera ruta que encuentre. La solución pasa por alterar el orden de las líneas en el enrutador: ```php Route::get('usuario/crear', 'UsuarioController@create'); Route::get('usuario/{nombre}', 'UsuarioController@show'); ``` ### 5.7.6. Servidor RESTful Un servidor RESTful es aquel que responde a la [arquitectura REST](https://juanda.gitbooks.io/webapps/content/api/arquitectura-api-rest.html). Típicamente, el enrutador de un servidor RESTful contendrá las 7 operaciones REST para cada recurso accesible desde la red. Por ejemplo, para un recurso llamado \"usuario\", el enrutador tendrá estas 7 entradas: ```php Route::get('user', 'UserController@index')->name('user.index'); Route::get('user/{user}', 'UserController@show')->name('user.show'); Route::get('user/crear', 'UserController@create')->name('user.create'); Route::post('user/{user}', 'UserController@store')->name('user.store'); Route::get('user/{user}/edit', 'UserController@edit')->name('user.edit'); Route::patch('user/{user}', 'UserController@update')->name('user.update'); Route::delete('user/{user}', 'UserController@destroy')->name('user.destroy'); ``` También se puede crear una entrada en el enrutador de este estilo: ```php Route::resource('user'); ``` Esa única ruta engloba a las siete rutas REST. ",
    "url": "/laravel/7",
    "relUrl": "/laravel/7"
  },"44": {
    "doc": "5.8 Vistas y plantillas. Blade",
    "title": "{% raw %}{{$name}}{% endraw %}",
    "content": "Este es el contenido de mi página. @endsection ``` ### 5.8.5. Condiciones en las vistas Blade admite expresiones condicionales para modificar el aspecto de una vista dependiendo del valor de una variable o del estado de la aplicación. En el siguiente ejemplo, el contenido de la vista depende de la variable $day. Controlador: ```php function show() { return view('page',array('name' => 'Manolo','day' => 'Viernes')); } ``` Vista /resources/views/page.blade.php: ```html @extends('layouts.master') @section('title', 'Page Title') @section('sidebar') Esto se añadirá al sidebar del master layout. @endsection @section('content') ",
    "url": "/laravel/8",
    "relUrl": "/laravel/8"
  },"45": {
    "doc": "5.8 Vistas y plantillas. Blade",
    "title": "{% raw %}{{$name}}{% endraw %}",
    "content": "Este es el contenido de mi página. @if ($day == 'Viernes') Hoy me roban el carro . @else Hoy me dedico a cantar . @endif @endsection ``` Observa que esto mismo podría hacerse abriendo y cerrando php (), pero de este modo el código queda mucho más limpio y resulta menos propenso a errores. ### 5.8.6. Bucles en las vistas Igual que existen condiciones, Blade también permite hacer bucles para simplificar la generación de visas. Por ejemplo, en la siguiente vista recorremos un array llamado $bebidas y mostramos su contenido. Controlador: ```php function show() { $bebidas = array('Cerveza','Agua','Zumo'); return view('page',array('name' => 'Manolo','day' => 'Lunes', 'bebidas' => $bebidas)); } ``` Vista /resources/views/page.blade.php: ```html @extends('layouts.master') @section('title', 'Page Title') @section('sidebar') Esto se añadirá al sidebar del master layout. @endsection @section('content') ",
    "url": "/laravel/8",
    "relUrl": "/laravel/8"
  },"46": {
    "doc": "5.8 Vistas y plantillas. Blade",
    "title": "{% raw %}{{$name}}{% endraw %}",
    "content": "Este es el contenido de mi página. @if ($day == 'Viernes') Hoy me roban el carro . @else Hoy me dedico a cantar . @endif ",
    "url": "/laravel/8",
    "relUrl": "/laravel/8"
  },"47": {
    "doc": "5.8 Vistas y plantillas. Blade",
    "title": "Estas son las bebidas disponibles:",
    "content": "@foreach ($bebidas as $bebida) {% raw %}{{$bebida}}{% endraw %} @endforeach @endsection ``` Observa que esto mismo podría hacerse abriendo y cerrando php (), pero de este modo el código queda mucho más limpio y resulta menos propenso a errores. ### 5.8.7. Invocación de funciones PHP Desde una vista Blade se puede invocar cualquier función de PHP sin necesidad de abrirlo y cerrarlo (). Por ejemplo, si necesitamos la función date(), la invocamos así: ```html ",
    "url": "/laravel/8",
    "relUrl": "/laravel/8"
  },"48": {
    "doc": "5.8 Vistas y plantillas. Blade",
    "title": "Ejemplo de llamada a función estándar de PHP",
    "content": "La fecha del servidor es: {% raw %}{{date(' D M, Y')}}{% endraw %} . ``` Esto es mucho más seguro que abrirlo y cerrarlo php () porque filtra posibles ataques XSS. Si alguna vez necesitamos saltarnos la protección contra XSS, debemos usar {% raw %}{!! ... !!}{% endraw %} en lugar de {% raw %}{{ ... }}{% endraw %}. ### 5.8.8. Otras directivas Blade Blade dispone de multitud de directivas para hacer prácticamente cualquier cosa en la vista sin tener que recurrir a PHP. En esta lista mostramos solo las directivas más habituales. - **@section** → Marca el inicio de una sección de contenido. - **@endsection** → Marca el final de una sección. - **@show** → Marca el final de una sección y la muestra. - **@yield('section')** → Muestra el contenido de una sección (si existe, claro). - **@extends('view')** → Hereda de una plantilla padre. - **@parent** → Muestra el contenido de la sección del mismo nombre en la plantilla padre. - **@include('view')** → Incluye una subvista. - **@if | @else | @endif** → Condicional. - **@for | @endfor** → Bucle for clásico. - **@foreach | @endforeach** → Buche foreach. - **@forelse | @empty | @endforelse** → Como foreach, pero con tratamiento de arrays que vienen vacíos. - **@break | @continue** → Para usar en los bucles. - **@switch | @case | @break** → Condicional múltiple. - **@isset($variable) | @endisset** → Comprueba si la variable existe. - **@auth | @endauth** → La sección solo se muestra si hay un usuario autenticado en la aplicación. - **@php | @endphp** → Para añadir código PHP plano. Usar con moderación. - **{% raw %}{{- Comment -}}{% endraw %}** → Comentarios (no serán renderizados). - **{% raw %}{{ $variable }}{% endraw %}** → Equivalente a echo $variable, pero no es necesario abrir y cerrar PHP, y nos protegemos contra inyección de JS. - **{% raw %}{{ $variable ?? texto-por-defecto }}{% endraw %}** → Como el anterior, pero chequea si la variable existe. Si existe, muestra su valor. Si no, muestra texto-por-defecto. - **$loop** → Es una variable muy útil para usar en y/o depurar un foreach. Nos dice si estamos en el primer elemento, en el último, cuántos loops llevamos, etc. ### 5.8.9. Tratamiento de formularios con Blade Blade también facilita el tratamiento de los formularios. En la vista, creamos el formulario (fíjate cómo indicamos la ruta en el action): ```html @csrf Enviar ``` (Recuerda que los métodos PUT y DELETE no existen aún en HTML y que Laravel los simula con un campo oculto en el formulario que se crea con la directiva @method('PUT') o @method('DELETE')) En el enrutador, definimos la ruta \"mi-ruta\" del action del formulario: ```php Route::post('mi-ruta', 'MiControlador@store'); ``` Y, en el controlador, creamos el método store(). Observa cómo recuperamos los datos del formulario a través de la variable $r: ```php public function store(Request $r) { $email = $r->get(\"email\"); $asunto = $r->get(\"asunto\"); ...etc... } ``` Esta es una forma alternativa para el controlador: ```php public function store() { $email = request(\"email\"); $asunto = request(\"asunto\"); ...etc... } ### 5.8.10. Validación de formularios con Blade Otra cosa que Blade facilita muchísimo es la validación de formularios en el lado del servidor. El formulario en nuestra vista quedaría así (observa cómo mostramos los errores -si los hay- con un bucle): ```html @if ($errors->any()) @foreach ($errors->all() as $error) {% raw %}{{ $error }}{% endraw %} @endforeach @endif ...resto del formulario igual... ``` El objeto $errors (disponible en todas las vistas) tiene muchos más métodos útiles que puedes consultar en la documentación de Laravel. Y el controlador quedaría así. Observa cómo definimos varias reglas de validación para campos del formulario: ```php public function store() { request->validate([ 'email' => 'required|email', 'asunto' => 'required' ]); // A partir de aquí, procesar el formulario igual que antes ``` Puedes consultar todas las reglas de validación admitidas en [https://laravel.com/docs/validation](https://laravel.com/docs/validation). Cuando vuelve a cargarse el formulario que contenía un error, suele ser apropiado volver a cargar los datos que el usuario ya había tecleado. A esto se le llama \"repopular\" el formulario, y con Blade se hace así: ```html @if ($errors->any()) @foreach ($errors->all() as $error) {% raw %}{{ $error }}{% endraw %} @endforeach @endif ...resto del formulario igual... ``` ### 5.8.11. Añadir CSS y Javascript a nuestras vistas Laravel ya trae dos archivos (app.css y app.js) basados en Boostrap 4 para empezar a trabajar. Para usarlos, basta con añadir esto a la cabecera de nuestras vistas: ```html | ``` Si queremos añadir reglas CSS, NO debemos editar /public/app.css, porque es un CSS compilado y minimizado con SASS. Lo correcto para añadir nuestro CSS a ese archivo es: 1. Editar /resources/sass/app.css 2. Recompilar este archivo con SASS (o con less o con stylus) ``` $ npm run dev (o también: $ yarn dev) ``` Y, por supuesto, siempre podemos crear nuestro propio CSS y nuestro JS en /public. En ese caso, los archivos no estarían optimizados (tendríamos que hacerlo a mano, si queremos) y serían accesibles de forma pública. El CSS y el JavaScript que vayamos a usar de este modo se pueden colocar en /public/css y /public/js ### 5.8.12. Vistas de error personalizadas Las vistas creadas en /resources/views/errors permiten personalizar fácilmente las pantallas de error HTTP. Por ejemplo, si creas un archivo /resources/views/errors/404.blade.php, esa vista se mostrará cada vez que ocurra un error 404 (página no encontrada) ",
    "url": "/laravel/8",
    "relUrl": "/laravel/8"
  },"49": {
    "doc": "5.8 Vistas y plantillas. Blade",
    "title": "5.8 Vistas y plantillas. Blade",
    "content": "## 5.8. Vistas y plantillas. Blade Blade es un poderoso y sencillo sub-lenguaje que nos permitirá generar plantillas para minimizar el código que necesitamos para nuestras vistas. Las plantillas Blade admiten condiciones y bucles para operar con las variables PHP, de modo que la misma plantilla se comporta de forma diferente con diferentes conjuntos de datos. ¡Y se acabó la pesadilla de abrir y cerrar comillas para concatenar variables a las salidas HTML! Con Blade, ya no será necesario abrir y cerrar php () para operar con las variables del servidor y generar la salida. El código no solo será más limpio y fácil de depurar, sino también más seguro, porque se impiden los ataques con XSS. Además, unas plantillas pueden heredar de otras para reutilizar mejor el código. ### 5.8.1. Master layout El layout es una forma genérica de referirse a un diseño de capas del interfaz de la aplicación. El master layout es el diseño maestro del que derivan todas las vistas. Ese master layout suele almacenarse en un archivo llamado /resources/views/layouts/master.blade.php. Y podría tener, por ejemplo, este aspecto: ```html @yield('Titulo') . @section('sidebar') Este es mi master sidebar. @show @yield('content') . ``` Aquí vemos varias directivas importantes de blade: * @yield('Titulo') --> Esto define una sección llamada 'Título', que en el master layout está vacía. Las vistas que hereden del master layout tendrán que definir cuál es el valor de 'Título', y ese valor aparecerá escrito aquí. * @section('sidebar') --> Esto define una sección llamada 'sidebar' que NO está vacía (contiene el texto \"Este es mi master sidebar\", pero podría contener cualquier otra cosa). Las vistas que hereden del master layout podrán AÑADIR contenido a esta sección. * @show --> Hace que el contenido de la sección se muestre en ese punto del documento. * @yield('content') --> De nuevo, una sección que está vacía en el master layout y cuyo contenido tendrá que definirse en las vistas que hereden de esta. ### 5.8.2. Vistas que heredan del master layout El aspecto de una plantilla que herede del master layout anterior debería ser este: ```html @extends('master') @section('title', 'Titulo de la página') @section('sidebar') Esto se añadirá al master sidebar. @endsection @section('content') Aquí va el contenido de mi página. @endsection ``` * @extends('master') --> Esto indica que esta vista hereda del master layout. * @section('title, 'Título de la página') --> Aquí se define el contenido de la sección 'Título' que en el master layout estaba vacía. * @section('sidebar') --> Aquí añade contenido a la sección 'sidebar', que en el master layout no estaba vacía. * @ensection --> Se emplea cuando el contenido de una sección ocupa varias líneas de código y no es posible escribirlo dentro de la propia directiva. ### 5.8.3. Cómo pasar variables a las vistas Las variables a las vistas deben enviarse empaquetadas en un array. Hay varias formas de lograr esto, todas ellas correctas. Puedes emplear la que te resulte más cómoda o más elegante: ```php return view('vista', array('variable1'=>'valor', 'variable2'=>'valor')); return view('vista', ['variable1'=>'valor', 'variable2'=>'valor']); return view('vista')->with(['variable1'=>'valor', 'variable2'=>'valor']); return view('vista', compact('variable1', 'variable2')); ``` ### 5.8.4. Cómo usar las variables en las vistas Supongamos que tenemos este método en un controlador: ```php function show() { return view('page',array('name' => 'Manolo Escobar')); } ``` La variable $name se puede usar en la vista /resources/views/page.blade.php de este modo: ```html @extends('layouts.master') @section('title', 'Page Title') @section('sidebar') Esto se añadirá al sidebar del master layout. @endsection @section('content') ",
    "url": "/laravel/8",
    "relUrl": "/laravel/8"
  },"50": {
    "doc": "5.9 Controladores",
    "title": "5.9 Controladores",
    "content": "## 5.9. Controladores ### 5.9.1. Cuatro cosas importantes sobre los controladores en Laravel Los controladores en Laravel heredan de la clase Controller. Su nombre debería escribirse en singular, CamelCase y terminando en la palabra Controller. Por ejemplo: UserController, LoginController, ArticleController Cada método del controlador debe terminar en un return. Lo que el método devuelva será convertido automáticamente en una HTTP response 200, excepto si es un array, en cuyo caso se convertirá automáticamente en JSON. Se puede actuar sobre la HTTP response devolviendo esto: ```php return response('contenido', 201) ->header('mi-cabecera', 'contenido') ->header('otra-cabecera', 'más-contenido') ->cookie('mi-cookie', 'valor'); (etc) ``` ### 5.9.2. Tres formas de crear un controlador **Forma 1. Crear un controlador vacío.** Por ejemplo, para crear un controlador para la tabla de usuarios: ``` $ php artisan make:controller UserController ``` **Forma 2. Crear un controlador de tipo resource.** Estos controladores se generan automáticamente con un andamiaje para construir recursos REST. Es decir, la clase ya llevará incorporados los métodos index(), create(), store(), show(), edit(), update() y destroy() del estándar REST. Para crear un controlador así: ``` $ php artisan make:controller UserController --resource ``` No te olvides de de añadir al enrutador (/routes/web.php) las rutas REST para este tipo controlador. Se pueden resumir las siete rutas en esta sola entrada del enrutador: ``` Route::resource('nombreRecurso', 'controlador'); ``` En nuestro ejemplo: ``` Route::resource('usuarios', 'UserController'); ``` **Forma 3. Crear un controlador tipo API.** El controlador tipo API es como un resource, pero sin create() ni edit(), porque una API no necesita mostrar los formularios de inserción/modificación. ``` $ php artisan make:controller UserController --api ``` De nuevo, no te olvides de las entradas en el enrutador. Puedes englobarlas todas en una sola entrada con este aspecto: ``` Route::apiResource('usuarios', 'UserController'); ``` ",
    "url": "/laravel/9",
    "relUrl": "/laravel/9"
  },"51": {
    "doc": "Anexo I. Sistemas de control de versiones. Git",
    "title": "Anexo I. Sistemas de control de versiones. Git",
    "content": "# 1. Sistemas de control de versiones (Fuente: www.genbetadev.com) Tanto si trabajamos por nuestra cuenta como si lo hacemos por cuenta ajena, es habitual que no lo hagamos solos, sino que tengamos que hacerlo junto a un equipo de personas. El desarrollo de software de calidad es una tarea que exige a menudo de perfiles diferentes, cada uno especializado en un área (frontend, backend, administración de bases de datos, usabilidad…). Esto hace que necesitemos de un sistema eficiente para organizar al equipo. Y cómo no, existe una tremenda variedad de software destinado a facilitar esa organización. ¿Qué es un sistema de control de versiones? Es casi inconcebible hoy en día trabajar desarrollando software y no utilizar un sistema para controlar los cambios que se van realizando, tanto por nosotros mismos como por nuestros compañeros de trabajo. Tales utilidades se denominan sistemas de control de versiones, y existen un buen puñado de ellas. La característica principal en que se dividen bien podría ser si se trata de un sistema centralizado o no. En el primer caso, existe un servidor común donde se encuentra el código fuente, tanto la versión actual en desarrollo como todas aquellas versiones intermedias desde que dio comienzo el proyecto. En el último caso, no es necesario (aunque a menudo es recomendable) poseer un servidor común, sino que se pueden enviar y recibir actualizaciones de cada uno de los miembros participantes de forma directa. ¿Cómo funciona un sistema de control de versiones? Lo habitual es que cada programador realice los cambios necesarios en el código fuente para la tarea que se le ha encomendado. Una vez que dichos cambios están listos, los envía al servidor (o a los otros participantes), de modo que el resto pueda recibirlos en cualquier momento, y así trabajar sobre dichos cambios cuando tengan que realizar cualquier otra tarea. Se puede dar el caso de que varios programadores trabajen sobre el mismo fichero o ficheros, en cuyo caso el sistema lo detectará, y actuará para evitar posibles conflictos. Se pueden dar dos casos: • Los programadores han trabajado en porciones de código diferentes: En principio, no se han pisado las líneas en las que han trabajado, así que es probable que sea suficiente efectuar ambos cambios sobre el fichero, sin más. Casi todos los sistemas de control de versiones detectan esta situación y realiza la unión de los cambios de forma automática, notificándolo al usuario para que tenga constancia. • Los programadores han trabajado en líneas de código comunes, modificando, eliminando o añadiendo líneas en la misma porción de código: En estos casos, el sistema suele señalar que hay un conflicto entre ambos cambios, y habitualmente genera un fichero intermedio convenientemente marcado para que se puedan revisar ambos cambios de forma simultánea, y así quedarse con uno, con el otro, o con una combinación de los dos, realizando la unión a mano y eliminando lo que sobra. Si bien sólo por esta característica ya merece la pena trabajar con un sistema de este tipo, espera a conocer las otras ventajas: • Puedes volver a cualquier punto del desarrollo para ver qué aspecto tenía un determinado fichero de código, o volver a una versión donde todo funcionaba antes de haber metido la pata. • Puedes trabajar en distintas características de forma simultánea, guardando los cambios en cada una de ellas, y uniéndolos al desarrollo principal si ya han sido lo suficientemente probadas. O sencillamente puedes crear una nueva versión para probar un experimento, o corregir un bug que se acaba de detectar en producción, sin comprometer lo que ya llevas realizado. Estas distintas ramas de trabajo hacen que veamos el repositorio de código como un árbol, donde cada una de las ramas representan experimentos que se van creando, y que luego vuelven a unirse al tronco principal del árbol (la versión que pretende llevarse a producción). • Puedes echar un vistazo para ver quién realizó un determinado cambio, y cuándo lo hizo. Y otras muchas características que suelen ser propias de un sistema de control de versiones específico. Algunos de los más habituales son CVS, Subversion, Git, Mercurial, o Bazaar, si bien encontrarás otros muchos. Personalmente, me decanto por Git, el mismo que se utiliza para llevar un control del desarrollo del kernel de Linux (de hecho, fue creado inicialmente para esta tarea), y que además de ser muy popular, es un sistema distribuido, flexible, y para el que existe una gran cantidad de bibliografía. Pero te recomiendo que pruebes unos cuántos y te decidas por el que mejor se ajuste a tus necesidades. ¿Cómo puedo empezar a usarlo? Existe una ingente cantidad de repositorios de software que ponen a disposición del usuario un sistema de control de versiones donde alojar su código. La mayoría de los repositorios de software libre más conocidos utilizan algunos de estos sistemas para acceder al código fuente, y poder colaborar si así se desea en el desarrollo del mismo, o crear tu propio proyecto y alojarlo en ellos de forma gratuita. Muchos otros también permiten alojar proyectos privados a los que sólo tienen acceso tanto tú como tus colaboradores. Entre los más conocidos, cabe mencionar: • GitHub (que como habrás adivinado, es un servicio de almacenamiento de repositorios de software que utilizan Git), el cual permite alojar tanto proyectos de software libre de forma gratuita, como proyectos privados mediante una cuenta de pago. El coste depende del número de repositorios y de colaboradores, y va desde 7 dólares al mes hasta los 200 dólares al mes. • SourceForge, exclusivamente para almacenar software libre. Soporta varios sistemas de control de versiones (CVS, Subversion, Git, Bazaar, Mercurial, y puede que algún otro que me esté dejando). • Launchpad, también para almacenar software libre. Elaborado por Canonical, la empresa detrás del desarrollo de Ubuntu. Utiliza Bazaar como sistema de control de versiones. • Bitbucket, otro servicio gratuito (hasta cinco programadores por repositorio, a partir de ahí hay que pagarlo) que soporta Git y Mercurial y cuenta con varias herramientas sociales integradas. Además, no dejes de echar un vistazo a los servicios unificados de gestión de proyectos, como Unfuddle, ya que éstos suelen traer a menudo la posibilidad de alojar tu código en su propio repositorio de software. ## Git básico GIT – FLUJO DE TRABAJO BÁSICO Workspace Staging area (INDEX) Local repo (HEAD) Remote repo | | | git add → | | | git commit → | | | git push → | | | | ← git fetch | | ← git pull | | | | | 1. Inicializar (solo la primera vez) git init git --config name “Mi nombre” git --config email “Mi email” git --config list 2. Flujo de trabajo habitual en local crear/editar los archivos locales con mi editor favorito. git add (pasa a INDEX -stage área-) git add -A (pasa TODOS los ficheros modificados a la stage área) git commit -m “Comentario” (pasa al HEAD o repo local TODOS los archivos del stage área) git status (muestra estado actual del repositorio) git log (muestra historial de cambios) git log --oneline (muestra historial de cambios simplificado) 3. Configurar repositorios remotos git clone (crea copia local de repositorio remoto) git remote (muestra repos remotos actualmente configurados) git remote add (añade repositorio remoto) (ej: git remote add mi-repo git://github.com/pepitoperez/mi-proyecto) 4. Enviar a repositorio remoto git push ( será “master” si no hemos hecho ramas) 5. Traer desde repositorio remoto git fetch (trae los ficheros del repo remoto pero los deja en otro branch) git merge FETCH_HEAD (fusiona los ficheros que has traído con la rama principal) git pull (abreviatura de las dos anteriores ejecutadas consecutivamente) Más info: https://git-scm.com/book/es/v2 ",
    "url": "/scv-git/",
    "relUrl": "/scv-git/"
  },"52": {
    "doc": "About",
    "title": "About",
    "content": "Estos apuntes han sido elaborados por [Alfredo Moreno Vozmediano](https://ensegundapersona.es) y se publican aquí con licencia [CC BY 4.0](https://creativecommons.org/licenses/by/4.0/), lo que quiere decir que eres libre de usar este material, copiarlo, distribuirlo y modificarlo siempre que el resultado de todo eso mantenga la misma licencia y cites la autoría original. Algunos fragmentos (pocos) están tomados y adaptados de otras fuentes. Cuando eso ocurre, lo indico claramente en el texto. Debes atenerte a la licencia de los sitios web de origen para esos fragmentos. ",
    "url": "/about/",
    "relUrl": "/about/"
  },"53": {
    "doc": "1.1 Algunas cosas que debes saber sobre los CMS",
    "title": "1.1 Algunas cosas que debes saber sobre los CMS",
    "content": "## 1.1. Algunas cosas que debes saber sobre los CMS {: .no_toc } - TOC {:toc} ### 1.1.1. Inconvenientes de desarrollar una web desde cero Desarrollar sitios web programándolos desde cero (o más o menos desde cero, porque la mayor parte de las veces se parte de librerías existentes) tiene varias ventajas, como, por ejemplo: * Permite sacar el máximo partido tanto del servidor como de los clientes. * Nos da un control absoluto sobre el sitio web que estamos desarrollando. * Nos posibilita ajustarnos al máximo a los requerimientos y crear aplicaciones a medida. Pero también tiene inconvenientes: * La creación de un sitio desde cero es un proceso muy largo. * Las ampliaciones y actualizaciones del sitio también resultan lentas y costosas. * Ambas tareas (creación y actualización) requieren personal altamente cualificado, con conocimientos de todas las tecnologías implicadas. Es decir, desarrolladores web. Y eso cuesta dinero. Y, cuando los inconvenientes superan a las ventajas, muchas personas se pasan al CMS. ### 1.1.2. Cómo funciona un CMS **Un CMS (Content Management System)** es una aplicación web que se ejecuta en un servidor y se controla desde un navegador (cliente), y que nos permite: * Crear a través del navegador un sitio web completamente nuevo en muy poco tiempo. * Administrar fácilmente todo lo relacionado con el sitio web: usuarios, privilegios, contenido, apariencia, menús, etc. * Y todo ello sin tener conocimientos de HTML, CSS, PHP ni el resto de tecnologías (ojo: no es necesario, pero sí conveniente) El CMS guarda el **contenido** del sitio web en una **base de datos**. Cuando se solicita una página, un programa escrito en PHP (o en otro lenguaje de servidor) busca el contenido de esa página en la BD y la genera dinámicamente, enviándola al navegador (cliente). Además, otro conjunto de programas permiten agregar nuevo contenido, modificar el contenido existente, crear usuarios, gestionar privilegios, etc. Todo ello altera los datos existentes en la BD, que a su vez alteran la forma en la que el usuario percibe la página cuando la visita. Al sitio web en sí se le denomina a veces ***front-end***. El front-end, en este sentido es lo que ve el visitante de la web. A las páginas de adminsitración del sitio se les llama a veces ***back-end*** o ***dashboard*** (panel de administración). El back-end sólo es accesible a algunos usuarios (administradores, editores, etc). El CMS siempre necesita, por ello, un control de acceso de usuarios o login. ¡Cuidado! Los términos front-end y back-end son confusos. En términos de programación, a menudo se denomina ***front-end*** a la salida de una aplicación web, es decir, al interfaz de usuario, y ***back-end*** a la parte de la aplicación que interactúa con los recursos del servidor (como la base de datos). En este otro sentido, el front-end está escrito en HTML, CSS, JavaScript u otros lenguajes del lado del cliente y el back-end está escrito en PHP, Java, Python u otros lenguajes del lado del servidor. ### 1.1.3. Tipos de CMS Hay un montón (¡pero un montón!) de CMS, y cada uno tiene sus propias características, puntos fuertes y puntos débiles. Podemos clasificarlos según su método de distribución: * Código abierto y software libre. * Código propietario. Pero suele ser más útil clasificarlos por su funcionalidad: * CMS genéricos (para cualquier tipo de sitio web) * CMS para blogs. * CMS para foros. * CMS para wikis. * CMS para e-learning (aprendizaje por internet) * CMS para e-commerce (comercio electrónico) * CMS para publicaciones digitales (periódicos, revistas...) **Los CMS actuales son fuertemente incompatibles.** Cada uno utiliza un interfaz distinto, bases de datos completamente diferentes para almacenar la información, módulos incompatibles, etc. Existen algunas iniciativas para lograr que los servicios desarrollados en un CMS puedan utilizarse en otros, pero todavía están en un estadio muy inicial. Lo que sí existen son familias de CMS relacionados entre sí que pueden compartir algunas características, generalmente porque unos CMS han derivado de otros. ### 1.1.4. Algunos CMS importantes Los CMS propietarios no han podido competir con los CMS libres. Por ello, han evolucionado hacia soluciones cloud computing completas, como Microsoft Azure, Google Cloud o Amazon Web Services (AWS). Entre los verdaderos CMS abundan las soluciones opensource o software libre. Por ejemplo: * Para blogs: * WordPress * Calepin * Scriptogram * Jekyll * Anchor * Etc. * Para wikis: * MediaWiki * WikkaWIki * DokuWiki * Etc. * Para foros: * phpBB * MyBB * VBulletin * Simple Machines Forum * Etc. * Para e-learning: * Moodle * WebCT * Mahara * Claroline * Etc. * Para e-commerce: * PrestaShop * Magento * OsCommerce * Zen Cart * Etc. * Otros CMS específicos: * eGroupWare: para groupware (desarrollo colaborativo) * ownCloud: almacenamiento de archivos. * Coppermine: galerías de imágenes. * PyASC: galerías de arte. Muchos de estos CMS desaparecerán, se fundirán con otros o se dividirán en varios proyectos desde que yo escriba estas líneas hasta que tú las leas. Lo mejor es que eches un vistazo a alguna lista actualizada de CMS, como [esta de Wikipedia](https://en.wikipedia.org/wiki/List_of_content_management_systems). ### 1.1.5. Instalación de un CMS IMPORTANTE: la instalación puede diferir de un CMS a otro, pero, más o menos, todos necesitan los mismos pasos. Hay que leer cuidadosamente las instrucciones de instalación, que encontrarás en la web del desarrollador. Los pasos que suelen ser habituales en casi todos los CMS: 1. Descargar la última versión del programa de la web del desarrollador. 2. Asegurarse de que el servidor cumple los prerrequisitos para ejectuar el CMS (versión de Apache, PHP, MySQL u otro software necesario) 3. Subir el CMS por al servidor (por ftp, vía web o como tu proveedor de hosting te lo permita). 4. Crear la base de datos. 5. Lanzar la instalación del CMS. Esto suele hacerse cargando una dirección concreta en tu navegador. 6. Adapar el archivo de configuración (suele llamarse config.php, config.inc, o algo similar). En los CMS más elaborados este paso no es necesario, pues el programa de instalación se encarga de generar un archivo de configuración válido. 7. A veces, hay que modificar los permisos de algún directorio y/o archivo. 8. Instalar el paquete de idioma español (si está disponible) ### 1.1.6. Explotación de un CMS IMPORTANTE: la explotación puede diferir notablemente de un CMS a otro, pero, en general, todo tienen una serie de elementos en común. Hay que leer cuidadosamente las instrucciones de uso, que encontrarás en la web del desarrollador. Pasos que suelen ser habituales en casi todos los CMS, una vez realizada la instalación: 1. Asignar una password de alta seguridad al usuario administrador que se crea por defecto. 2. Crear otros usuarios y asignarles privilegios. 3. Editar la página de inicio del sitio web. 4. Cambiar la plantilla (apariencia) del sitio. 5. Instalar módulos de ampliación (si es necesario). 6. Crear el contenido y/o revisar el contenido creado por otros usuarios. ",
    "url": "/cms/algunas-cosas-que-debes-saber",
    "relUrl": "/cms/algunas-cosas-que-debes-saber"
  },"54": {
    "doc": "Desarrollo Web en Entorno Servidor",
    "title": "Desarrollo Web en Entorno Servidor",
    "content": "Esta es la documentación (apuntes) del módulo de ***Desarrollo Web en Entorno Servidor*** del Ciclo Formativo de Grado Superior de Desarrollo de Aplicaciones Web impartido en el IES Celia Viñas de Almería (España). 1. TOC {:toc} ",
    "url": "/",
    "relUrl": "/"
  },"55": {
    "doc": "1.3 Moodle",
    "title": "1.3 Moodle",
    "content": "## 1.3. Moodle {: .no_toc } - TOC {:toc} ### 1.3.1. Características de Moodle Moodle es un sistema de gestión de contenidos orientado a **crear comunidades de aprendizaje** en línea. Este tipo de plataformas tecnológicas también se conoce como **LMS (Learning Management System)**. Su licencia es GPL (es decir: es software libre). Está programado en lenguaje PHP y puede usar diferentes gestores de bases de datos para almacenar el contenido: MySQL o PostgreSQL son los más habituales, pero también es posible utilizar Oracle o SQL Server. Las características más destacables de Moodle son: * Su arquitectura y herramientas son apropiadas para la educación a distancia, así como también para complementar el aprendizaje presencial. * Tiene una interfaz de navegador de tecnología sencilla, ligera y compatible con todos los navegadores. Eso sí, es más complejo que otras soluciones como Google Classroom, aunque Moodle también es muchísimo más potente. * La instalación es sencilla (¡casi siempre!), requiriendo tan solo una plataforma que soporte PHP y la disponibilidad de una base de datos. * Da mucha importancia a la seguridad: todos los formularios son revisados, las cookies cifradas, etc. * Las áreas de introducción de texto pueden ser editadas usando un editor WYSIWYG. * Es fuertemente configurable, permitiendo la instalación de módulos adicionales (plugins) para incrementar sus posibilidades. * Es un sistema enorme que consume *muchos* recursos en el servidor. ### 1.3.2. Algunos módulos de Moodle En Moodle, los recursos se organizan en categorías llamadas **módulos**. Cada módulo tiene sus propias características y está orientado a un tipo de actividad distinta: cuestionarios en línea, lecciones, tareas para que los alumnos suban, encuestas y un largo etcétera. Aquí solo mencionaremos los módulos más populares. #### Módulo de archivos Los archivos son documentos que sube el profesor/a y que estarán accesibles al alumnado. * Los documentos pueden ser de cualquier tipo: Word, Libreoffice, Powerpoint, vídeo, audio, etc. #### Módulo de Tareas Este módulo sirve para que el alumnado envíe tareas al profesor/a. Estas tareas pueden constar de un texto en línea o uno o varios archivos subidos a la plataforma. * Puede especificarse la fecha final de entrega de una tarea y la calificación máxima que se le podrá asignar. * Los estudiantes pueden subir sus tareas (en cualquier formato de archivo) al servidor. Se registra la fecha en que se han subido. * Se permite enviar tareas fuera de tiempo, pero el profesor puede ver claramente el tiempo de retraso. * Para cada tarea en particular, puede evaluarse a cada estudiante (calificaciones y comentarios) en una única página con un único formulario. Incluso se puede corregir el documento escribiendo encima, como haríamos con una tarea hecha en papel. * Las observaciones del profesor se adjuntan a la página de la tarea de cada estudiante y se le envía un mensaje de notificación. * El profesor tiene la posibilidad de permitir el reenvío de una tarea tras su calificación (para volver a calificarla). #### Módulo de consultas Las consultas son votaciones. Puede usarse para votar sobre algo o para recibir una respuesta de cada estudiante (por ejemplo, para pedir su consentimiento para algo). * El profesor puede ver una tabla que presenta de forma intuitiva la información sobre quién ha elegido qué. * Se puede permitir que los estudiantes vean un gráfico actualizado de los resultados. #### Módulo de foro Hay diferentes tipos de foros disponibles: exclusivos para los profesores, de noticias del curso y abiertos a todos. * Todos los mensajes llevan adjunta la foto del autor. * Las discusiones pueden verse anidadas, por rama, o presentar los mensajes más antiguos o los más nuevos primero. * El profesor puede obligar la suscripción de todos a un foro o permitir que cada persona elija a qué foros suscribirse de manera que se le envíe una copia de los mensajes por correo electrónico. * El profesor puede elegir que no se permitan respuestas en un foro (por ejemplo, para crear un foro dedicado a anuncios). * El profesor puede mover fácilmente los temas de discusión entre distintos foros. #### Módulo de Cuestionarios Los cuestionarios son los típicos exámenes tipo test. Pueden utilizarse como exámenes, como ejercicios de autoevaluación, como pruebas de evaluación inicial, etc. * Los profesores pueden definir una base de datos de preguntas que podrán ser reutilizadas en diferentes cuestionarios. Esto requiere una gran inversión de tiempo al principio, pero luego pueden reutilizarse las preguntas toda la vida. Y existen bancos de preguntas disponibles en internet. * Las preguntas pueden ser almacenadas en categorías de fácil acceso, y estas categorías pueden ser \"publicadas\" para hacerlas accesibles desde cualquier curso del sitio. * Los cuestionarios se califican automáticamente, y pueden ser recalificados si se modifican las preguntas. * Los cuestionarios pueden tener un límite de tiempo a partir del cual no estarán disponibles. * El profesor puede determinar si los cuestionarios pueden ser resueltos varias veces y si se mostrarán o no las respuestas correctas y los comentarios * Las preguntas y las respuestas de los cuestionarios pueden ser mezcladas (aleatoriamente) para disminuir las copias entre los alumnos. * Las preguntas pueden crearse en HTML y con imágenes. * Las preguntas pueden importarse desde archivos de texto externos. * Las preguntas pueden tener diferentes métricas y tipos de captura. #### Módulo de encuestas * Se proporcionan encuestas ya preparadas (COLLES, ATTLS) y contrastadas como instrumentos para el análisis de las clases en línea. * Se pueden generar informes de las encuestas los cuales incluyen gráficos. Los datos pueden descargarse con formato de hoja de cálculo Excel o como archivo de texto CSV. * La interfaz de las encuestas impide la posibilidad de que sean respondidas sólo parcialmente. * A cada estudiante se le informa sobre sus resultados comparados con la media de la clase. #### Módulo de Wikis * El profesor puede crear este modulo para que los alumnos trabajen en grupo en un mismo documento. * Todos los alumnos podrán modificar el contenido incluido por el resto de compañeros. * De este modo cada alumno puede modificar el wiki del grupo al que pertenece, pero podrá consultar todos los wikis. ",
    "url": "/cms/moodle",
    "relUrl": "/cms/moodle"
  },"56": {
    "doc": "1.4 Prestashop",
    "title": "1.4 Prestashop",
    "content": "## 1.4. Prestashop {: .no_toc } - TOC {:toc} TODO ",
    "url": "/cms/prestashop",
    "relUrl": "/cms/prestashop"
  },"57": {
    "doc": "1.2 Wordpress",
    "title": "\">",
    "content": ". 'Main', 'container' => 'nav' )); ?> . ``` Si analizas el código, verás que, después del doctype, hemos abierto la etiqueta html indicando que seleccione los atributos de idioma de la instalación de WordPress. Para el charset también hemos recurrido a una función de Wordpress, así como para el título de la página. En el caso de estar diseñando un tema responsive, especificaremos el viewport. Para mostrar la URL al favicon.ico le indicamos la ruta a la carpeta \"mitema\" de la instalación de WordPress. Eso se consigue con la función de Wordpress get_stylesheet_directory_uri(). Un poco más abajo se usa la función bloginfo() con el argumento 'stylesheet_directory', que tiene el mismo efecto que get_stylesheet_directory_uri(). Finalmente, se usa la función wp_head() de WordPress, necesaria par que muchos plugins y funcionalidades de WordPress funcionen. A partir de aquí cerramos la etiqueta head y empezamos con los contenidos de body. Quizás aquí te estés preguntando por qué incluir el body en header.php y no en index.php. La razón es sencilla: los contenidos de la cabecera del tema van a estar en todas las páginas, por lo que al incluirlo aquí, evitamos duplicar código y el mantenimiento del tema va a ser mucho más sencillo. Así, dentro de las etiquetas de header incluiremos nuestra cabecera. En este ejemplo, hemos puesto el nombre del sitio web con un enlace a la página de inicio: ```html ",
    "url": "/cms/wordpress",
    "relUrl": "/cms/wordpress"
  },"58": {
    "doc": "1.2 Wordpress",
    "title": "\">",
    "content": "``` Fíjate que en la etiqueta header hemos escrito esta línea: ```php 'Main', 'container' => 'nav' )); ?> ``` Eso debería crear el menú de navegación, pero, para que funcione, primero deberemos añadir al archivo ***functions.php*** (que contiene las funciones propias del tema) este código: ```php 'Main' ) ); } ?> ``` Este código lo que hace es crear un menú llamado \"Main\" que nos aparecerá en el panel de administración de WordPress en Apariencia -> Menús. Lo que este código dice es que si existe una función llamada register_nav_menus, entonces debe crearse un nuevo menú de navegación llamado Main. Además, la función de Wordpress add_theme_support() sirve para indicar que en este tema queremos poder crear menús dinámicos. A partir de aquí, simplemente habremos de ir a Apariencia -> Menús y crear nuestro menú y guardarlo, como con cualquier otro theme. Con esto ya tenemos la cabecera del tema creada junto con su menú de navegación. Recuerda que para añadir páginas al menú de WordPress, primero hay que crear las páginas o no podremos hacerlo. #### **Paso 4: Crear la barra lateral** La mayoría de temas de WordPress incluyen una barra lateral que no tiene por qué aparecer en todas las páginas del tema. En las barras laterales acostumbramos a poder añadir widgets, por lo que se van a tener que habilitar para widgets. Para ello, abriremos nuestro archivo ***functions.php*** e incluiremos esta función: ```php 'Main Sidebar', 'before_widget' => ' . ', 'after_widget' => '', 'before_title' => '', 'after_title' => ' . ', )); ?> ``` Si activamos este tema y vamos a Apariencia -> Widgets, veremos que nos aparece una nueva zona de widgets llamada Main Sidebar. Una vez creada la zona lista para widgets, vamos a tener que llamarla dentro del archivo ***sidebar.php***, otro archivo típico de casi todas las plantillas. Creamos este archivo y escribimos: ```html ``` Hemos utilizado un id teniendo en cuenta que en este tema sólo va a existir una barra lateral, pero si quieres crear más, quizás prefieras crear una clase. Con esto ya tenemos creada la barra lateral lista para widgets. #### **Paso 5: Crear el footer** Hasta aquí hemos creado la cabecera y la barra lateral. Ahora vamos a crear el footer para después integrarlo todo en index.php. Recuerda que WordPress funciona por módulos, y que los módulos son como piezas de un puzle: hasta ahora hemos ido creando esas piezas para luego montarlas todas en index.php. El footer se crea, oh sorpresa, en un archivo llamado ***footer.php*** que puede quedarnos así: ```html &amp;amp;amp;copy; , . Mi primer tema. ``` Fíjate que la capa \"wrapper\" empieza en el header y termina en el footer. Si queremos un header o un footer que se extienda por toda la pantalla, deberemos mover las posiciones de los div que abren y cierran la capa \"wrapper\". Aquí aparece la función wp_footer(), que es semejante a wp_header(). Estas funciones son lo que se llaman **hooks de Wordpress** y hacen funcionar los plugins que instalemos. En el caso de wp_footer() va a ser, además, necesaria si queremos ver la barra de administración de WordPress. No serás el primero que se vuelve loco tratando de averiguar por qué no aparece la barra de administración hasta que descubre que es porque no ha llamado a este hook de WordPress. #### **Paso 6: Crear la página principal** En este tema, la página principal se va a corresponder a los contenidos de ***index.php***. Nuestro index tendrá este aspecto: ```html ``` Observa estas tres funciones: get_header(), get_sidebar() y get_footer(): * get_header() inserta los contenidos del archivo header.php en ese punto. * get_sidebar() hace lo mismo con la barra lateral. * get_footer() hace... bueno, ya te imaginas lo que hace, ¿verdad? De modo que ya hemos montado nuestro puzle. Un puzle muy sencillito porque solo tiene tres piezas, vale. Pero ahora lo puedes complicar todo lo que quieras. #### **Paso 7. El loop de WordPress** En el ***loop*** reside toda la magia de Wordpress. ¿Qué es el loop? Es un bucle (claro) en el que se muestram las entradas almacenadas en la base de datos de Wordpress. Y nosotros podemos decidir cómo se muestran esas entradas. Este código de ejemplo de loop debe añadirse a continuación del anterior en ***index.php***: ```html ",
    "url": "/cms/wordpress",
    "relUrl": "/cms/wordpress"
  },"59": {
    "doc": "1.2 Wordpress",
    "title": "\">",
    "content": "Publicado el por . ``` La primera línea es el auténtico loop: ```html ``` Wordpress mirará si hay alguna entrada disponible (if(have_posts())). Si es así, entramos en un bucle que se repite para todos los posts (while(have_posts())). Y, para cada post, se recupera su contenido de la base de datos (the_post()). Una vez seleccionado el post, se muestra su información: la fecha de publicación (the_time()), los autores (the_author_posts_link()), el extracto (the_excerpt())... Si no hay posts, se muestra el mensaje de error \"No hay entradas\" #### **Paso 8. Añadir thumbnails al loop** Si queremos añadir thumbnails (imágenes destacadas) al loop como sucede en muchos portales WP, lo que haremos es lo siguiente: vamos al archivo functions.php y añadimos este código: ```html ``` Con este código hemos habilitado los thumbnials de nuestras entradas y hemos establecido un tamaño para las mismas de 150 por 150 píxeles. Una vez hecho esto, modificaremos nuestro loop como sigue: ```html ",
    "url": "/cms/wordpress",
    "relUrl": "/cms/wordpress"
  },"60": {
    "doc": "1.2 Wordpress",
    "title": "\">",
    "content": "Publicado el por . ``` Observa que hemos añadido un par de líneas en las que se comprueba si el post tiene thumbnail y, en caso afirmativo, este se recupera. La forma en la que queremos que se visualice todo esto debe establecerse mediante CSS, por supuesto. Podríamos seguir añadiendo cosas al loop. Por ejemplo: podríamos añadir una paginación de las entradas. Encontrarás en la red mucha información sobre el tema, aunque lo más práctico es bajarse una plantilla sencillita ya hecha y curiosear en su código fuente. #### **Paso 9. Resultados de la búsqueda** Los resultados de la búsqueda se especifican en el archivo ***search.php***. He aquí un ejemplo: ```html ",
    "url": "/cms/wordpress",
    "relUrl": "/cms/wordpress"
  },"61": {
    "doc": "1.2 Wordpress",
    "title": "Resultados de la búsqueda",
    "content": " ",
    "url": "/cms/wordpress",
    "relUrl": "/cms/wordpress"
  },"62": {
    "doc": "1.2 Wordpress",
    "title": "\">",
    "content": "Publicado el por max_num_pages); } ?> ``` Fíjate que se parece mucho a index.php. Esta página es la que va a mostrar los resultados de una búsqueda en cuestión. Así, vamos a necesitar que aparezca un buscador en nuestra plantilla. Un buen sitio para colocarlo puede ser el sidebar. Iremos a nuestro archivo sidebar.php y justo antes de la función que habilita la zona de widgets en el sidebar, incluimos este código: ```html /\"> \" name=\"s\" id=\"s\" /> ``` Con esto tenemos un campo de búsqueda en nuestra barra lateral. Para que se visualice como queremos, simplemente hará falta crear el código CSS necesario. #### **Paso 10. Configurar la vista de las entradas (posts)** La página del post es aquella donde vamos a ver una entrada individual, es decir, un post completo. Vamos a poder definir cómo se ve, incluir o no comentarios, etc. El archivo donde se define esto se denomina ***single.php***, y puede ser más o menos así: ```html ",
    "url": "/cms/wordpress",
    "relUrl": "/cms/wordpress"
  },"63": {
    "doc": "1.2 Wordpress",
    "title": "\" rel=\"bookmark\" title=\"Enlace permanente a \">. ",
    "content": "Publicado por el . Categoría: ``` Si has llegado hasta aquí, te resultará fácil comprender el archivo. Si en el loop utilizamos the_excerpt() para mostrar el extracto de la entrada, aquí utilizamos la función the_content() para recuperar el contenido completo de la entrada. Por supuesto, esto se puede complicar hasta el infinito. A modo de ejemplo, mostraremos cómo podríamos mostrar las entradas relacionadas. Bastaría con añadir este código justo después de mostrar el contenidos de la entrada: ```html ID); if ($tags) { $tag_ids = array(); foreach($tags as $individual_tag) $tag_ids[] = $individual_tag->term_id; $args=array( 'tag__in' => $tag_ids, 'post__not_in' => array($post->ID), 'showposts'=>5, // Number of related posts that will be shown. 'caller_get_posts'=>1 ); $my_query = new wp_query($args); if( $my_query->have_posts() ) { echo 'Artículos relacionados . '; while ($my_query->have_posts()) { $my_query->the_post(); ?> | \" rel=\"bookmark\" title=\"Permanent Link to \"> | '; } wp_reset_query(); } ?> ``` #### **Paso 11: Habilitar y mostrar los comentarios** Para permitir los comentarios en una entrada, añadiremos este código a nuestro archivo ***functions.php***: ```php // Permitir comentarios encadenados function enable_threaded_comments(){ if (is_singular() AND comments_open() AND (get_option('thread_comments') == 1)) { wp_enqueue_script('comment-reply'); } } add_action('get_header', 'enable_threaded_comments'); ``` Y en ***single.php***, justo antes de la línea del endwhile, añadiremos: ```html ``` Nuevamente, será el CSS el que determine cómo se verán los comentarios. Aquí tienes un ejemplo de CSS para empezar a trabajar en él: ```css .commentlist li { list-style: none !important; } .comment-body { padding: 15px; } .comment-author { margin-top: 5px; } .reply, .commentmetadata { font-size: 0.9em; } .depth-1, .depth-2, .depth-3, .depth-4 { border: 1px solid #eaeaea; border-radius: 4px; } .depth-1, .depth-3 { background-color: #fafafa; } .depth-2, .depth-4 { background-color: #fff; } .comment-author-eSandra { border: 3px solid #eaeaea; border-left:3px solid #fbc356; } .depth-1 { margin: 20px 0; } /* Respuesta a comentarios*/ .depth-2 { margin:2% 5% !important; } .depth-3 { margin: 2% 7% !important; } .depth-4 { margin:2% 5% 4% 10% !important; } #comment, #author, #email { border-radius: 4px; border:2px solid #ccc; } ``` #### **Paso 12: Crear la página de categorías y etiquetas** Los archivos **category.php** y **tags.php** son prácticamente iguales. Simplemente añadiremos antes del loop: ```html ",
    "url": "/cms/wordpress",
    "relUrl": "/cms/wordpress"
  },"64": {
    "doc": "1.2 Wordpress",
    "title": "Etiqueta &amp;amp;amp;#8216;&amp;amp;amp;#8217;",
    "content": " ",
    "url": "/cms/wordpress",
    "relUrl": "/cms/wordpress"
  },"65": {
    "doc": "1.2 Wordpress",
    "title": "Archivo para :",
    "content": " ",
    "url": "/cms/wordpress",
    "relUrl": "/cms/wordpress"
  },"66": {
    "doc": "1.2 Wordpress",
    "title": "Archivo para :",
    "content": " ",
    "url": "/cms/wordpress",
    "relUrl": "/cms/wordpress"
  },"67": {
    "doc": "1.2 Wordpress",
    "title": "Archivo para :",
    "content": " ",
    "url": "/cms/wordpress",
    "relUrl": "/cms/wordpress"
  },"68": {
    "doc": "1.2 Wordpress",
    "title": "Archivo del autor ",
    "content": " ",
    "url": "/cms/wordpress",
    "relUrl": "/cms/wordpress"
  },"69": {
    "doc": "1.2 Wordpress",
    "title": "Archivos del blog",
    "content": "``` #### **¿Y ahora qué?** Ya tienes una plantilla sencilla y funcional creada desde cero. La creación de plantillas no termina aquí, claro. Solo hemos dado los primeros pasos y sentado unas bases lo más sólidas posible. La API de WordPress es muy amplia, a menudo confusa y casi siempre redundante. Especializarse en el desarrollo para WordPress es una tarea de largo recorrido que no puede aprenderse en unas cuantas horas. Pero, si has llegado hasta aquí, ya has hecho, probablemente, lo más difícil. La mayoría de las plantillas tienen más archivos que la nuestra, como, por ejemplo: * **page.php**, para mostrar páginas estáticas. * **author.php**, para mostrar la página de \"acerca de\". * **404.php**, para crear nuestra propia página de error \"not found\" Por último, aquí tienes un diagrama de las relaciones que existen entre los archivos típicos de una plantilla Wordpress. Recuerda que el único obligatorio (además de styles.css) es index.php, y que una plantilla compleja puede tener otros archivos adicionales a los que aquí se muestran. XXX esquema ### 1.2.3. Plugins de Wordpress (El contenido de esta sección está adaptado de: www.cristalab.com/tutoriales/como-crear-un-plugin-para-wordpress-c54308l/) #### **Los plugins de WordPress** Los plugins, como en cualquier otro sistema, añaden funcionalidades a Wordpress. La arquitectura flexible de Wordpress permite realizar esa ampliación en casi cualquier sentido, dotando a Wordpress de esa capacidad polimórfica que lo hace tan útil en muchas circunstancias. A partir de aquí vamos a crear un sencillo plugin para Wordpress que pueda servir de base para desarrollos posteriores más realistas. El plugin se llamará \"Saludo\" y contendrá algunas funciones para saludar que nos servirán para ilustrar el funcionamiento del sistema de plugins de WordPress. #### **Crear un plugin nuevo** Para crear el plugin \"Saludo\" basta con crear un archivo llamado ***saludo.php*** en una carpeta llamada también \"saludo\" y ubicada a su vez en carpeta_raiz/wp-content/plugins/ Dentro del archivo saludo.php, escribiremos el comentario de cabecera para que WordPress lo reconozca como un plugin válido (igual que sucede con las plantillas). Es importante respetar la sintaxis. ```php ``` #### **Añadir funciones al plugin** Vamos a crear nuestra primera función con un código algo más complejo. Todo lo que sigue se debe escribir en el mismo archivo ***saludo.php***. ```php ``` #### **Instalar y desinstalar el plugin** Para poder instalar y desinstalar el plugin desde el panel de administracion de Wordpress, es necesario crear dos funciones en ***saludo.php***: una para instalar y otra para desinstalar. Estas funciones, por ahora, las dejaremos vacías. Además, al final del archivo ***saludo.php*** hay que usar la funcion del API de Wordpress add_action() para indicar las funciones que activar y desactivan el plugin. ```php ``` #### **Cómo usar las funciones del plugin** Ahora ya puedes usar tu maravilloso plugin. Sólo debes colocar en la sección de tu plantilla que estimes conveniente la siguiente línea: ```php ``` #### **Configurar el plugin desde el panel de administración** Nos falta crear un item dentro del panel de administración que nos permita modificar las opciones de este plugin. El ítem lo daremos de alta dentro del menú \"opciones\", y para esto programaremos tres funciones más en nuestro archivo ***saludo.php***: * saludo_panel(): aquí incluiremos el html que será expresado en nuestro panel. Para no mezclar html dentro del código, usaremos la función include() a modo de template. * saludo_add_menu(): aquí usaremos a su vez la función de WP add_options_page. * saludo_add_action(): para desencadenar todo esto usaremos esta función que es también parte del API de WP. ```php ``` Además, necesitaremos un formulario html para poder visualizar la pantalla de configuración en el panel de administración de Wordpress. Crearemos algo muy sencillo. Por supuesto, se puede mejorar con un poco de HTML y CSS. Lo escribiremos en el archivo ***template/panel.html***: ```html Inserte su saludo ``` Por último, modificaremos la función saludo_panel() para poder visualizar nuestros avances: ```php <?php ... function saludo_panel(){ include('template/panel.html'); } echo \" ",
    "url": "/cms/wordpress",
    "relUrl": "/cms/wordpress"
  },"70": {
    "doc": "1.2 Wordpress",
    "title": "{$_POST['saludo']}",
    "content": "\"; ... ?> ``` Podemos probar que todo funciona escribiendo algo en el formulario (pulsando \"Enviar\"). #### **Acceder a la BD desde nuestro plugin** Vamos a ver cómo se puede acceder a la BD de WordPress desde un plugin. Para ello, antes debemos desinstalar el plugin desde el panel de control. Solo así podremos modificar la función de instalación y ejecutarla más adelante de nuevo. Las funciones de Wordpress que manejan la DB se llaman con una variable global denominada ***$wpdb***: ```php prefix . \"saludos\"; $sql = \" CREATE TABLE $table_name( id mediumint( 9 ) NOT NULL AUTO_INCREMENT , saludo tinytext NOT NULL , PRIMARY KEY ( `id` ) ) ;\"; $wpdb->query($sql); $sql = \"INSERT INTO $table_name (saludo) VALUES ('Hola Mundo');\"; $wpdb->query($sql); } function saludo_desinstala(){ global $wpdb; $tabla_nombre = $wpdb->prefix . \"saludos\"; $sql = \"DROP TABLE $tabla_nombre\"; $wpdb->query($sql); } ... ?> ``` Por supuesto, hay que agregar los datos a la DB desde nuestro panel en opciones/saludo, para lo cual modificaremos la función saludo_panel(): ```php prefix . \"saludos\"; if(isset($_POST['saludo_inserta'])){ $sql = \"INSERT INTO $table_name (saludo) VALUES ('{$_POST['saludo_inserta']}');\"; $wpdb->query($sql); } } ... ?> ``` ¡Ahora que ya podemos insertar saludos en nuestra BD! sólo nos queda poder mostrarlos en nuestra función saludo(). Para esto extraeremos un saludo de manera aleatoria a nuestra BD: ``` prefix . \"saludos\"; $saludo= $wpdb->get_var(\"SELECT saludo FROM $table_name ORDER BY RAND() LIMIT 0, 1; \" ); include('template/saludo.html'); } ... ?> ``` Ahora modifiquemos nuestro ***saludo.html*** para que imprima la variable $saludo: ```html ",
    "url": "/cms/wordpress",
    "relUrl": "/cms/wordpress"
  },"71": {
    "doc": "1.2 Wordpress",
    "title": "",
    "content": "``` Por último, vamos modificar el html de nuestro panel para que se adapte al html del administrador de WP y no quede tan feo: ```html Ingresar Nuevo Saludo Inserte su saludo ``` Con todo esto ya tenemos listo nuestro plugin. Por supuesto, siguiendo la misma lógica podríamos eliminar o modificar registros o hacer cualquier otra operación que necesitásemos con la base de datos. ",
    "url": "/cms/wordpress",
    "relUrl": "/cms/wordpress"
  },"72": {
    "doc": "1.2 Wordpress",
    "title": "1.2 Wordpress",
    "content": "## 1.2. Wordpress {: .no_toc } - TOC {:toc} Wordpress es sin duda el campeón actual de los CMS. Algunas estadísticas afirman que el 90% de los sitios web de internet está hecho con Wordpress. Probablemente son estadísticas un poco infladas, pero la importancia de este CMS es innegable y cualquier desarrollador web debe conocerlo, aunque sea para odiarlo. Wordpress es un CMS enfocado a la creación de blogs, aunque, en su estadio actual, permite crear casi cualquier tipo de sitio web: tiendas online, portales, revistas digitales, álbumes de imágenes o recursos de cualquier tipo... Está desarrollado en PHP bajo licencia GPL y se ha convertido. Tiene detrás una enorme comunidad de desarrolladores y diseñadores, que se encargan de actualizarlo y de crear plugins y temas para la comunidad. ### 1.2.1. Características principales de Wordpress * La estética, tanto de resultado como del código fuente, es fundamental para los desarrolladores de WordPress. * Las entradas publicadas son ordenadas por fecha, aunque esto se puede modificar. * La estructura y diseño visual del sitio depende del sistema de plantillas. * La filosofía de Wordpress apuesta decididamente por la elegancia, la sencillez y las recomendaciones del W3C pero depende siempre de la plantilla. * Separa el contenido y el diseño en XHTML y CSS, aunque, como se ha dicho, depende de la plantilla que se esté usando. * La gestión y ejecución corre a cargo del sistema de administración con los plugins y los widgets que usan las plantillas. #### **Funcionalidades de Wordpress** Wordpress hace magia. Así de sencillo. Si te vas a convertir en desarrollador/a web, Wordpress es tu peor enemigo, porque permite que cualquier usuario medio, sin tener ni idea de programación, pueda crear un sitio web solvente y de aspecto profesional en una tarde. No te voy a engañar: a ti te llevaría meses programar algo parecido desde cero. Pero Wordpress también tiene sus limitaciones, y cuando sus usuarios las descubren, necesitan a un programador que sepa meterse en las tripas de Wordpress para retorcérselas. Ahí es donde entrarás tú. De modo que sí: Wordpress es tu peor enemigo, pero puede convertirse en tu mejor aliado. Para eso, tienes que conocer qué es capaz de hacer y qué no. Entre sus asombrosas funciones podemos contar estas: * Fácil instalación, actualización y personalización. * Posibilidad de actualización automática del sistema implementada en la versión 2.7. * Múltiples autores o usuarios, junto con sus roles o perfiles que establecen distintos niveles de permisos desde la versión 2.0). * Múltiples blogs o bitácoras (desde la versión 1.6). * Capacidad de crear páginas estáticas (a partir de la versión 1.5). * Permite ordenar artículos y páginas estáticas en categorías, subcategorías y etiquetas (\"tags\"). * Cuatro estados para una entrada (\"post\"): Publicado, Borrador, Esperando Revisión (nuevo en Wordpress 2.3) y Privado (sólo usuarios registrados), además de uno adicional: Protegido con contraseña. * Editor WYSIWYG \"What You See Is What You Get\" en inglés, \"lo que ves es lo que obtienes\" (desde la versión 2.0). * Publicación mediante email. * Importación desde Blogger, Blogware, Dotclear, Greymatter, Livejournal, Movable Type y Typepad, Textpattern y desde cualquier fuente RSS. Se está trabajando para poder importar desde pMachine y Nucleus además de la importación a través de scripts o directamente de base de datos. * Guardado automático temporizado del artículo como Borrador (A partir de la versión 2.2). * Permite comentarios y herramientas de comunicación entre blogs (Trackback, Pingback, etc). * Permite \"permalinks\" (enlaces permanentes y fáciles de recordar) mediante mod_rewrite. * Distribución de los artículos mediante RDF, RSS 0.92, RSS 2.0 y Atom 1.0. * Distribución de las discusiones (mediante RSS 2.0 y ATOM 1.0). * Gestión y distribución de enlaces. * Subida y gestión de adjuntos y archivos multimedia. * Admite plugins para aumentar aún más la fucionalidad, a riesgo de convertirlo en una \"monstruo de Frankenstein\" hecho a pegotes. * Admite plantillas y \"Widgets\" para éstas. * Búsqueda en entradas y páginas estáticas y Widget de casa para búsqueda integrada de google desde la versión 2.5.[5] #### **Plantillas de Wordpress** Las plantillas (themes) de Wordpress son diseños CSS que sirven para establecer la apariencia y estructura del blog. Algunas también modifican parte del panel de administración. Hay una gran comunidad oficial, tanto profesional como de usuarios, dedicada al diseño de estas plantillas. Puedes encontrarlas tanto en el sitio de Wordpress (comprobadas y aprobadas oficialmente) como en sitios web de terceros. Muchas son gratuitas, otras de pago y, la mayoría, tienen una versión gratuita con funciones adicionales de pago. Las posibilidades de las plantillas, tanto a nivel de diseño, estructura o gestión, son tan grandes que prácticamente permiten tener desde un simple blog hasta un portal web fuertemente personalizable. Hay un gran campo de trabajo en las plantillas de Wordpress para un desarrollador web. Más adelante veremos como crear plantillas nuevas, algo que también te servirá para modificar plantillas existentes. #### **Widgets** Los widgets son pequeñas aplicaciones que proporcionan nuevas funcionalidades a un programa o que permiten un acceso rápido a funcionalidades usadas con frecuencia. Pueden ser vistosos como, por ejemplo, relojes en pantalla, calculadoras, calendarios o nubes de tags; o pueden ser discretos pero útiles como, por ejemplo, un cuadro con enlaces de interés o con un contador del número de visitas. Wordpress incorpora un sistema de widgets para sus plantillas que ofrece numerosas posibilidades y flexibilidad para el diseño y estructura de sus blogs. Cada plantilla puede soportar un número diferente de Widgets. #### **Plugins** Hay una monstruosa cantidad de plugins que potencian el uso de Wordpress y que lo convierten en un CMS prácticamente de propósito general. Encontrarás un plugin para casi cualquier cosa que se te ocurra. Pero (¡siempre hay un pero!) con los plugins se corre el riesgo de empezar a parchear Wordpress hasta convertirlo en un amasijo informe de código puesto a pegotones. Muchos sitios web montados con Wordpress se vuelven ingobernables (y extraordinariamente lentos y pesados en la carga) por la gran cantidad de plugins que tienen activados. Otro problema de los plugins es que pueden provocar incontables problemas con las actualizaciones del sistema. En el ámbito de los plugins también hay mucho trabajo potencial para un futuro desarrollador/a web como tú: tanto para crear plugins nuevos y adaptados a las necesidades del cliente como para optimizar y racionalizar el uso de plugins existentes en los sitios que ya están en funcionamiento. Por último, y al igual que ocurría con las plantillas, tienes que saber que muchos plugins son gratuitos, otros son de pago, y otros tienen versiones gratuitas que se vuelven de pago cuando queremos utilizar sus características más atractivas. #### **Fallos de seguridad de Wordpress** Las críticas más contundentes contra WordPress se han centrado en sus problemas de seguridad. En mayo de 2007, por ejemplo, un estudio reveló que el 98% de los blogs basados en WordPress eran vulnerables a ataques. Todos los sistemas que se vuelven muy populares se vuelven inseguros por el simple hecho de que se multiplican los ataques contra ellos. La receta para minimizar los posibles problemas de seguridad es sencilla: mantener Wordpress actualizado. No podemos hacer mucho más allá de eso. ### 1.2.2. Cómo crear y modificar una plantilla de Wordpress (Esta sección está redactada a partir de esandra.com/crear-plantilla-wordpress-desde-cero y de manuelvicedo.com/guias/personalizar-wordpress-plantillas) Vamos a ver que Wordpress dispone de una enorme API de funciones útiles para desarrollar nuestros propios temas y plugins. Y lo vamos a ver de forma práctica: creando nuestra propia plantilla desde cero. #### **Las plantillas o temas de WordPress** Como ya hemos dicho, existen muchos sitios web donde adquirir plantillas (themes) de WordPress de gran valor añadido. Algunas son gratuitas, otras de pago, y otras tienen versiones gratuitas incompletas o parcialmente desactivadas, y versiones de pago que permiten usar todas las funcionalidades. Pero, a veces, queremos ir un paso más allá y desarrollar nuestro propio tema. Para ello, se puede usar un framework como Thematic o partir de un tema básico, pensado para desarrollo. Existen muchos temas de ese tipo, algunos muy conocidos, como Bones o Basic. A veces es mejor desarrollar un tema de WordPress desde cero, pues así conseguimos adaptarlo exactamente a lo que estamos buscando, evitando llamar a un montón de funciones innecesarias para las prestaciones que necesitamos. Además, así tendremos el control abosluto sobre los archivos y contenidos de la plantilla. #### **Dónde localizar las plantillas instaladas** Suponiendo que tenemos WordPress instalado y en correcto funcionamiento en un servidor (local o remoto, da lo mismo), lo primero que tendremos que hacer es ir al directorio que contiene los temas de WordPress. Este directorio se encuentra en las siguiente ruta: directoriowordpress -> wp-content -> themes, siendo directoriowordpress el directorio donde tenemos instalado WordPress dentro del htdocs del servidor. Dentro del directorio themes veremos una carpeta para cada tema de WordPress. Ahí tendremos que crear una nueva carpeta con el nombre de nuestro nuevo tema. A partir de ahora supondremos que estamos creando un nuevo tema llamado ***mitema***. Es decir, dentro de themes tendremos que crear un directorio llamado \"mitema\". #### **Archivos de un tema de WordPress** WordPress funciona por módulos. Por ejemplo, para insertar el footer en una página habremos de llamar al archivo footer.php, en caso de que exista. Y lo mismo con el header, la barra de navegación, etc. Así, un tema de WordPress puede estar formado por muchos archivos, pero para que un tema de WordPress funcione, **sólo necesitará dos archivos: index.php y style.css**. Está claro que con sólo estos dos archivos tendremos un tema muy básico, pero será considerado por WordPress un tema válido si estos dos archivos están bien configurados. Para que un tema de WordPress sea reconocido por WordPress deberá incluir sí o sí estos dos archivos, index.php y style.css. Si falta cualquiera de ellos, WordPress no reconocerá la carpeta mitema como un tema de WordPress. A continuación vamos a desarrollar un tema más completo que nos sirva de base para otros proyectos. Y raramente crearemos un tema de WordPress que no contenga una cabecera, un footer y una barra lateral, como mínimo. Tampoco vamos aquí a desarrollar un tema complejo con funciones avanzadas, pero sí que queremos tener lo necesario para crear un tema decente con el que poder desarrollar proyectos más complejos. Así, vamos a desarrollar un tema con la mayoría de archivos y carpetas habituales en otros temas para WordPress profesionales. Son los siguientes: * /images. Carpeta con las imágenes del tema. * /js. Carpeta con los archivos de JavaScript * style.css. Hoja de estilos del tema. Obligatoria para que el tema funcione. * index.php. Obligatorio para que el tema funcione. Por defecto será la página principal. * screenshot.png. Muestra la imagen en miniatura que se verá en el panel de administración en Apariencia -> Temas. * favicon.ico. La imagen que se verá en el navegador y al guardar el marcador. * header.php. Módulo que contiene la cabecera del tema. * sidebar.php. La barra lateral del tema. * footer.php. Módulo que contiene el pie de página del tema. * single.php. Este archivo especifica cómo se verá una entrada. * page.php. Este archivo especifica cómo se verá una página estática. * category.php. Muestra cómo se ve la página de resultados de una categoría. * tag.php. Muestra cómo se ve la página de resultados de una etiqueta. * search.php. Muestra cómo se ve la página de resultados de búsqueda. * functions.php. Archivo con las funciones genéricas de nuestro tema de WordPress. En la plantilla que vamos a desarrollar utilizaremos prácticamente todos estos archivos, para que veamos que no es tan complejo como de entrada pueda parecer. A partir de ahí, es fundamental tener la capacidad de crear un buen código HTML y CSS para obtener resultados profesionales. Para no perdernos en la inmensidad y hacer fácil lo supuestamente difícil, vamos a aplicar la técnica del divide y vencerás dividiendo la creación de la plantilla en 11 pasos #### **Paso 1: Crear el archivo style.css** El primer paso va a consistir en crear dentro de la carpeta \"mitema\" el archivo ***style.css***. Es recomendable utilizar un buen editor de textos para desarrollo web, como Sublime Text 2 o Notepad++, pero puedes hacerlo incluso con el Bloc de Notas de Windows si te va la marcha. Dentro del archivo style.css, en la parte superior deberemos incluir esta información: ```css /* Theme Name: Mitema Theme URI: el lugar donde vayas a alojar el tema para ponerlo a disposición de la comunidad Description: La descripción del tema Author: Tu nombre y apellidos Author URI: la web profesional del creador del tema Version: 1.0 */ ``` Fíjate que este fragmento de texto está comentado con /* ... */. Todos los datos que ponemos aquí van a aparecer junto al tema en Apariencia -> Temas. A partir de aquí, podemos ya crear nuestro propio código de CSS. #### **Paso 2: Imágenes y JavaScript** Este tema lo vamos a desarrollar con HTML5. Vamos a utilizar Modernizr, una librería de JavaScript que detecta las capacidades de HTML5 y CSS3 del navegador. También haremos uso de Respond, otra librería JavaScript que sirve para que Internet Explorer sepa interpretar los media queries de CSS3. De ese modo, nuestro tema funcionará incluso en navegadores muy antiguos. Por supuesto, puede crearse un tema sin estas librerías, pero las usaremos para ilustrar cómo se puede incrustar JavaScript en una plantilla WP. Crearemos las carpetas \"images\" y \"js\" dentro de la carpeta \"mitema\". En la carpeta \"js\" pondremos una copia de las librerías Modernizr y Respond bajadas directamente de las webs de los desarrolladores. En la carpeta \"images\" colocaremos más adelantes todas las imágenes que vayamos necesitando para nuestro CSS. Ten en cuenta que dos archivos llamados ***screenshot.png*** y el ***favicon.ico*** se han de ubicar en la raíz del tema y no dentro de la carpeta images. Wordpress utilizará estos dos archivos para la previsualización del tema y para el icono de la página una vez que el tema se active. #### **Paso 3: Crear la cabecera del tema y el menú de navegación** El archivo header.php contiene la cabecera de nuestro tema. Es aquí donde pondremos nuestro logo, menú principal y aquello que aparezca en la parte superior de nuestro tema. Veamos un código posible para header.php: ```html > \"> | /favicon.ico\" /> | \" /> | \" /> . ",
    "url": "/cms/wordpress",
    "relUrl": "/cms/wordpress"
  }
}
