{"0": {
    "doc": "1 Sistemas gestores de contenido (CMS)",
    "title": "1 Sistemas gestores de contenido (CMS)",
    "content": "# 1. CMS: Sistemas gestores de contenido Vamos a empezar con algo que no tiene nada que ver con la programación: **los CMS**. Los **Sistemas Gestores de Conentido** (CMS = Content Management Systems) son aplicaciones web que permiten montar sitios web sin necesidad de programar una sola línea de código. Así que, sí, **los CMS son tus enemigos**. Y al enemigo hay que conocerlo. Por eso vamos a empezar este curso por aquí. {:toc} ",
    "url": "/cms/",
    "relUrl": "/cms/"
  },"1": {
    "doc": "2.1 Programación cliente-servidor",
    "title": "2.1 Programación cliente-servidor",
    "content": "## 2.1. Programación cliente-servidor {: .no_toc } - TOC {:toc} En los primeros tiempos de Internet, no se ejecutaban programas en el servidor. Solo se pedían páginas estáticas más o menos elaboradas que había sido grabadas en el servidor por un administrador de sistemas. A esto se le denomina web 1.0. A alguien se le ocurrió la idea de que los propios visitantes podrían también crear contenido. Ese contenido se guardaría en el servidor (en archivos o en una base de datos) y posteriormente podría recuperarse para generar con él una web dinámica, que no existía previamente y que nadie, en realidad, ha tecleado. Esa web dinámica estaría generada por un programa ejecutado en el servidor, un programa cuya salida sería HTML válido, comprensible por el navegador que la reciba. A esto se le denomina web 2.0 y supuso una revolución tan grande como el propio nacimiento de Internet. ### 2.1.1. Un poco de jerga informática Antes de continuar, tienes que asegurarte de que comprendes bien el significado de algunos términos: * Un **servidor** es un programa que se ejecuta en una máquina conectada a una red y que permanece dormido hasta que una petición procedente de la red lo despierta. Entonces, el programa hace algo (consulta datos, elabora un cálculo, lo que sea) y devuelve su resultado por la red. * Por extensión, un servidor también es cualquier ordenador donde se ejecute un programa servidor. Es decir, usamos la misma palabra para referirnos a un programa y al ordenador donde se ejecuta ese programa. Mala idea, ya lo sé, pero es lo que hay. * El **cliente** es el programa que envía esas peticiones al programa servidor para despertarlo. También es el programa que recoge el resultado devuelto por el servidor. * Por extensión, la máquina donde se ejecuta un programa cliente también se llama cliente. Pues bien, en programación web, nuestro cliente es el **navegador web** (también llamado cliente web). Cualquier navegador del universo conocido entra en esta categoría (excepto, tal vez, Internet Explorer). Y un servidor es cualquier máquina de la red donde se esté ejecutando un programa servidor web como Apache, Nginx, Tomcat, IIS y otros cuando viejos amigos que irás conociendo a lo largo de este curso. ### 2.1.2. Una petición web en la época 1.0 Ahora que tienes claro qué es un servidor y un cliente web, puedes comprender el siguiente esquema. En él, se ilustra lo que ocurre cuando un cliente web (recuerda: tu navegador) envía al servidor la peiticón de una **página estática**. El servidor, en este caso, se limita a enviar al cliente el documento HTML tal cual está almacenado en su disco duro, sin cambiar una sola coma. ![Ejemplo de servicio www](/assets/images/02-servicio-www-1.jpg) ### 2.1.3. Una petición web en la época 2.0 Con la web 2.0 la cosa cambia bastante porque aparecen las **páginas dinámicas**, aunque tendrás que fijarte bien en el esquema para apreciar la diferencia, ¿verdad? Quédate con lo importante: en este esquema, el cliente web no pide un documento HTML, sino *un programa*, que puede estar escrito en PHP o algún otro lenguaje, eso es lo de menos. Ese programa se ejecuta en el servidor, y *el resultado de esa ejecución* es lo que recibe el cliente, *no el programa en sí*. ![Ejemplo de servicio www](/assets/images/02-servicio-www-2.jpg) Así es como funcionan las aplicaciones web. ",
    "url": "/php/programacion-cliente-servidor",
    "relUrl": "/php/programacion-cliente-servidor"
  },"2": {
    "doc": "2.2 Caja de herramientas",
    "title": "2.2 Caja de herramientas",
    "content": "## 2.2. Caja de herramientas para desarrollar de aplicaciones web {: .no_toc } - TOC {:toc} Para desarrollar apliaciones web necesitamos una caja de herramientas bastante completa. Algunas herramientas son fundamentales, como el martillo o el destornillador de una caja de herramientas convencional. Otras, en cambio, son optativas y dependerán del trabajo que vayamos a realizar y de nuestras propias preferencias como desarrolladores. En esta sección vamos a hacer un repaso de las herramientas fundamentales, las que no pueden faltar en tu caja de herramientas. Algunas ya las conoces y otras las aprenderemos a manejar a lo largo de este curso. Se trata de: * DHTML (HTML, CSS y Javascript) * PHP u otro lenguaje de script de servidor (Python, Ruby, Perl, etc) * MySQL / MariaDB u otro SGBD que permita acceso remoto. ### 2.2.1. HTML DHTML (Dynamic HTML) no es un lenguaje como tal, sino que, como probablemente sabes ya, es la conjunción de tres lenguajes: * HTML * CSS * JavaScript DHTML y PHP son los lenguajes que nos van a permitir ejecutar programas en el servidor y acceder a sus recursos a través de páginas web, pero existen otras posibles combinaciones como: * DHTML con ASP * DHTML con JSP * DHTML con Python, Ruby, Perl, etc. HTML significa \"HyperText Markup Language\" (Lenguaje de Etiquetas de Hipertexto). Como sin duda sabrás, se trata de un lenguaje para formatear documentos: * Permite definir el tipo de letra, tamaño, formato y color de los textos. * Permite insertar imágenes y otro contenido multimedia. * Permite crear listas, tablas, enumeraciones... * Permite crear enlaces entre secciones del mismo documento, o enlaces con otros documentos (hipertexto) HTML **NO** es un lenguaje de programación: no permite programar algoritmos. Pero sí permite incrustar otros lenguajes de programación en su interior, aumentando así su potencia. Los trozos de código embebidos dentro de HTML se denominan ***scripts***. #### Brevísima historia de HTML * En 1990 se crea HTML (procedente de un lenguaje anterior, SGML) junto con la World Wide Web, para formatear los documentos de la www. * Se amplía en sucesivas versiones hasta la 3.0, que no consiguió éxito debido a las limitaciones de los navegadores de la época. * Comienza la guerra de navegadores: Microsoft y Netscape sacan sus propios “dialectos” de HTML y destrozan en estándar. * A partir de HTML 4 se intenta unir las características de los dos, pero el resultado es demasiado complejo. * Se hace evidente que hay que hacer una “limpieza” de HTML * Así surge XHTML, la versión XML de HTML, mucho más estricta y formal, con menos añadidos pero igual de potente. Las versiones actuales de HTML son: * HTML 4.01 transicional: HTML clásico, con todos los elementos del HTML antiguo. En la actualidad está obsoleto, pero aún quedan muchas páginas antiguas que lo utilizan. * HTML 4.01 estricto: también llamado XHTML, no permite usar los elementos HTML desaprobados, tales como definición de formatos. También se considera obsoleto. * HTML5: elimina definitivamente los elementos antiguos del lenguaje e incorpora algunos nuevos para completar la asimilación con XML. Es el estándar actual. * La especificación para HTML6 (o HTML Next) está actualmente en desarrollo. ### 2.2.3. CSS CSS significa \"Cascade Style Sheet\" (Hojas de estilo en cascada). CSS es un lenguaje para la definición de los formatos utilizados en una página web. Sólo permite definir el formato (es decir, el aspecto) de la página, no su contenido. Al definir los formatos en otra parte, se pueden reutilizar a lo largo de una o incluso de varias páginas: si cambiamos la definición CSS del formato, se cambian automáticamente los formatos de todas las páginas que usen esa definición. El objetivo último de CSS es **separar completamente el formato de la página de su contenido**. CSS 2.1 se usaba con HTML 4. CSS3 se usa con HTML5 y se considera el estándar actual. Está soportado universalmente, aunque, como sin duda habrás sufrido en tus carnes, los diferentes navegadores pueden interpretar de forma ligeramente distinta algunas definiciones CSS. ### 2.2.4. Javascript JavaScript es un lenguaje interpretado que puede ser incrustado dentro del código HTML de una página web. El código JavaScript puede interactuar y modificar cualquier parte del documento HTML, por lo que dota a las páginas web de dinamismo e interactividad. **JavaScript no es Java**, por mucho que su nombre se parezca. También su sintaxis puede recordar un poco a Java en algunas ocasiones. Pero déjame que te lo repita de nuevo: Javascript no es Java. La implementación de JavaScript de cada navegador es distinta, obteniéndose resultados que no siempre son iguales, por desgracia para los desarrolladores. Por ejemplo: * V8 = motor JS de Chrome * WebKit = motor JS de Safari * Rhino = motor JS de Mozilla Firefox * WebKit = motor JS de Microsoft Edge ### 2.2.5. PHP PHP es un acrónimo recursivo. Significa “PHP Hypertext Preprocessor” Sí, así es el sentido del humor de los informáticos. Qué le vamos a hacer. Es un lenguaje de programación de propósito general. Junto con librerías como PHP-Qt o PHP-GTK, puedes programar con él cualquier aplicación de escritorio. Pero, por circunstancias más debidas al azar que a otra cosa, se empezó a usar para desarrollo web al comienzo de la web 2.0, y hoy en día se utiliza casi exclusivamente para ese propósito. Cuando se usa en desarrollo web, PHP aparece embebido dentro de documentos HTML. #### Características de PHP * PHP permite conectarse con múltiples bases de datos: MySQL, MariaDB, Oracle, PostgreSQL, SQL Server, DB2, etc. También puede conectar por ODBC. * Se parece mucho a otros lenguajes de tercera generación y orientados a objeto (en particular a C/C++ y, por tanto, a Java). Su curva de aprendizaje para los que ya saben programar es muy plana. #### Brevísima historia de PHP * Surge en 1995 como extensión de CGI (otro lenguaje para acceso a funciones del servidor) * PHP3 (1998) tuvo un gran éxito comercial. * PHP4 (2000) es la versión más extendida (por desgracia): la mayoría de los scripts en PHP que circulan por la red están escritos en esta versión obsoleta. * PHP5 (2004) tiene soporte para orientación a objetos y una biblioteca de clases bastante bien diseñada. Por lo tanto, desde esta versión PHP pasa de ser un lenguaje estructurado (3GL) a ser un lenguaje orientado a objetos. * PHP6 empezó a desarrollarse en 2007 y se canceló en 2014. * PHP7 introdujo novedades menores y estuvo vigente hasta 2020. En el momento de escribi esto (junio de 2021) es la versión dominante en la mayoría de los servidores web. * PHP8 es la última versión (8.0.7 en junio de 2021). Las versiones PHP4 y PHP5 se consideran obsoletas e inseguras. Aún existe soporte para PHP7, pero todas las nuevas aplicaciones se deberían escribir pensando en PHP8. #### Lo nuevo en PHP 8 PHP 8 no tiene demasiadas novedades con respecto a PHP 7, como este no las tenía con respecto a PHP 5. Debes tener en cuenta que el mayor salto evolutivo se produjo entre PHP 4 y PHP 5. A partir de ahí, y para principiantes como nosotros, la cosa no ha cambiado demasiado. Algunas de las novedades más destacables de PHP 8 son: * Mejoras importantes de rendimiento, con la aparición de JIT (Just in Time Compiler), un compilador de PHP que trabaja de forma transparente al programador para incrementar la velocidad de ejecución. * Mejoras menores en el manejo de las clases y métodos abstractos. * Simplificación en la declaración de atributos. * Posibilidad de usar arrays con índices negativos. * Etc #### Ventajas de PHP sobre otros lenguajes * Es un lenguaje libre y abierto. * Es muy eficiente. * Es ejecutable en (casi) cualquier servidor. * Cuenta con una excelente documentación y miles de foros y sitios donde consultar dudas. * La curva de aprendizaje es baja si ya sabes programar. * Existen mogollón de entornos de desarrollo para PHP, para todos los gustos. * Fácil interoperatibilidad con otros sistemas, en particular con bases de datos. * Comunidad muuuy grande. * Aunque llevan décadas diciendo que es un lenguaje moribundo, lo cierto es que sigue siendo líder del mercado de aplicaciones web. #### Inconvenientes de PHP * Fallos de diseño (corregidos en su mayoría a partir de PHP 5), como: * Los métodos para acceso a bases de datos cambian según el SGBD usado. * Nombres de funciones inconsistentes. * No es completamente orientado a objetos. * Tipado confuso y, a veces, impredecible. * Grandes (e incompatibles) cambios entre versiones. * Pérdida lenta pero constante de cuota de mercado. * Pésima relación señal/ruido en la web: ¡hay demasiados *malos* desarrolladores en PHP! ### 2.2.6. MariaDB Otra de las herramientas básicas de nuestra caja de herramientas es el gestor de bases de datos relacionales (SGBD). MySQL / MariaDB es el SGBD líder del mercado de las aplicaciones web. Nos permitirá conectarnos a la base de datos y ejecutar sentencias SQL de forma remota al visitar una aplicación web. Existen otras posibilidades, desde luego, como: * SQL Server * Oracle * PostgreSQL * SQLite También está la posibilidad de usar base de datos no relacionales, como MongoDB, Cassandra o Redis. PHP puede conectarse también a estos sistemas, pero la forma de trabajar es diferente que con bases de datos relacionales. Como estas últimas son, de lejos, las predominantes en el mercado, nos centraremos en ellas. #### Características de MariaDB * MariaDB es un gestor de bases de datos relacional multiusuario y multiplataforma. * Permite mútiples conexiones remotas. * Es software libre. * Existen librerías para acceder a MariaDB desde muchos lenguajes: C/C++, Java, PHP, Perl, Pascal... Además, hay drivers ODBC. * Está muy extendida en aplicaciones web, generalmente en combinación con PHP. * Cuenta un interfaz gráfico programado en PHP, llamado PHPMyAdmin, que se ejecuta en el navegador web. Por supuesto, se puede usar cualquier otro cliente compatible con MySQL, como MySQL Workbench. #### Brevísima historia de MariaDB * MySQL surgió como un proyecto OpenSource en Suecia en 1995. * El objetivo era lograr un SGBD rápido y fiable que cumpliera con el estándar SQL. * Las primeras versiones (que se denominaron mSQL) eran muy ineficientes. * La popularización de PHP y su ganancia en eficiencia a partir de la versión 3 la han hecho muy popular en la actualidad. * Tras su adquisición por Oracle, se intentó relegar al segmento medio-bajo en el mercado de los SGBD y surgió un fork: MariaDB. * Versión más reciente (junio 2021): MariaDB 10.5.10 ",
    "url": "/php/caja-de-herramientas",
    "relUrl": "/php/caja-de-herramientas"
  },"3": {
    "doc": "2.3 Sintaxis de PHP",
    "title": "2.3 Sintaxis de PHP",
    "content": "## 2.3. La sintaxis de PHP {: .no_toc } - TOC {:toc} ### 2.3.1. Cómo embeber PHP dentro de HTML El código PHP se escribe incrustado dentro de un documento de texto mediante estas etiquetas: ```html ``` La sintaxis clásica está obsoleta desde PHP 7: ```html ``` Este archivo debe tener extensión .php. El servidor ejecuta el código PHP que encuentre dentro del archivo, mientras que el código HTML es enviado al cliente sin modificar. ### 2.3.2. Comentarios ```php // Comentario de una línea # Comentario de una línea /* Comentario de una o varias líneas */ ``` ### 2.3.3. Operadores * Operadores: son iguales que los de C/C++: * Asignación: $a = 3; * Comparación: ==, =, !=, , etc. * Operadores aritméticos: +, -, *, /, %... * Operadores lógicos: &&, ||, ! ### 2.3.4. Variables Las variables de una función/clase/método PHP son siempre **locales**, es decir, sólo están disponibles en esa función/clase/método, salvo que se indique otra cosa. Si se definen variables fuera de una función, serán globales a todo el fichero actual, pero no pueden usarse en el código ubicado en otros ficheros. El **identificador** de variable siempre debe empezar por $. Esta es una peculiaridad de PHP que al principio descoloca un poco. No es necesario declararlas: al inicializarlas queda especificado el tipo. A partir de PHP 7 pueden indicarse los tipos predefinidos (int, float, string...) Ejemplos: ```php $a = 4; // Variable entera (PHP 5) int $a = 4; // Variable entera (PHP 7+) $media = 52.75; // Variable real $texto = \"Hoy es lunes\"; // Variable string ``` Cualquier variable puede **cambiarse de tipo** con la función **setType()**: ```php $a = \"10\"; // a es una cadena setType($a, \"integer\"); // a se convierte a entero ``` Los **tipos de datos** predefinidos en PHP son: * integer (entero) * double (real) * bool (booleano) * string (cadena) * array (pues eso) ### 2.3.5. Arrays Los arrays en PHP son colecciones de variables del mismo o de distinto tipo identificadas por un índice. Se parecen más a los ArrayList de Java que a los arrays clásicos propiamente dichos. ```php $a[1] = \"lunes\"; $a[2] = \"martes\"; $a[3] = \"miércoles\"; ``` El índice no tiene por qué ser un número entero: puede ser un String (array asociativo): ```php $a[\"ESP\"] = \"España\"; $a[\"FRA\"] = \"Francia\"; $a[\"POR\"] = \"Portugal\"; ``` ### 2.3.6. Estructuras de control #### Condicionales ```php if (condición) { acciones-1; } else { acciones-2; } ``` #### Bucle while ```php while (condición) { acciones; } ``` #### Bucle repeat ```php do { acciones; } while (condición); ``` #### Bucles for y foreach El bucle for controlado por contador es idéntico a C/C++ y Java: ```php for (inicialización; condición; incremento) { acciones; } ``` Hay una variedad de bucle for muy interesante: el bucle foreach para recorrido de arrays asociativos: ```php foreach ($array as $índice=>$var) { acciones; } ``` El bucle foreach se repite una vez para cada valor guardado en el array. Ese valor se asigna a la variable $var en cada repetición. ### 2.3.7. Funciones y procedimientos Los subprogramas (funciones y procedimientos) se escriben en PHP con la misma palabra: function. * Las **funciones** deben devolver un valor en su última línea con return. Si necesitas devolver varios valores, puedes empaquetarlos en un array. * Los **procedimientos** no tienen return. Realizan su función y terminan. Los **parámetros** de la función en PHP siembre se pasan por valor. Por ejemplo: ```php function calcular_iva($base, $porcentaje) { $total = $base * $porcentaje /100; return $total; } ``` ### 2.3.8. Clases y objetos (¡solo en PHP5 y PHP7!) Las clases, métodos y atributos se declaran de forma muy semejante a C++ y Java: ```php class miClase { // Declaración de propiedades (atributos) public $var = 'soy una variable de clase'; // Método constructor (siempre se llama __construct) public function __construct($valor) { $var = $valor; } // Declaración de métodos public function mostrarVar() { echo $this->var; } private function resetVar() { $this->var = ''; } } ``` Para instanciar un objeto de una clase, se usa la palabra new. El constructor puede llevar parámetros o no, como en Java. Por ejemplo: ```php $miObjeto = new miClase('Estoy aprendiendo PHP'); $miObjeto->mostrarVar(); ``` La salida de este programa sería \"Estoy aprendiendo PHP\". ### 2.3.9. Salida de datos PHP puede hacer salidas de datos como cualquier otro lenguaje de programación: puede enviar texto a una impresora, datos a un fichero o puede dibujar ventanas y componentes en un entorno gráfico de usuario. Pero cuando PHP se ejecuta como parte de una aplicación web, nada de eso tiene sentido: esa salida se produciría en el servidor, y nosotros no estamos allí para verla. Nosotros estamos en nuestro cliente (navegador web), pidiendo al servidor que ejecute un programa PHP. Recuerda que, en este contexto, la salida PHP es siempre código HTML válido. Ese código HTML será recibido por tu navegador, interpretado y mostrado en la ventana del navegador. Observa el uso de \"echo\" para producir una salida HTML desde este pequeño script PHP: ```html esto en negrita\" ?> ``` ### 2.3.10. Paso de parámetros por la URL Las aplicaciones web pueden recibir parámetros a través de la propia URL de invocación del servidor. Imagina que tenemos este link en un documento HTML: ```html ``` Al hacer clic en él, pediremos al servidor que ejecute el programa cuyo código fuente está en el archivo \"pagina.php\", ¿verdad? Pues bien, ese programa \"pagina.php\" puede acceder a las variables \"variable1\", \"variable2\", etc. Esto se hace a traves del array global de PHP **$_GET**, que se indexa con el nombre de las variables. Así: ```php \"; ?> ``` ### 2.3.11. Entrada de datos a través de formulario (1) Como PHP se ejecuta dentro de HTML, sólo puede recibir datos del usuario de la aplicación a través del navegador web. Y sólo hay una forma de introducir datos en una página web: a través de un formulario. Veámoslo con un ejemplo. Supongamos que hemos definido en HTML este sencillo formulario: ```html Nombre Apellidos ``` Al pulsar el botón \"Enviar\", se cargará el script destino.php en el servidor. Ese script recibirá dos variables HTML llamadas nombre y apellido, con el valor que el usuario haya introducido en el formulario. Para acceder a las variables HTML, se usa el array del sistema **$_POST**, indexándolo con el nombre de la variable: ```php \" ?> ``` Observa que $_POST es una variable semejante a $_GET. Puedes utilizar una u otra según el valor del atributo *method* de tu formulario HTML. La variable **$_REQUEST** sirve tanto para POST como para GET. **Por eso será la que nosotros usaremos preferentemente en nuestros programas**. ",
    "url": "/php/sintaxis-de-php",
    "relUrl": "/php/sintaxis-de-php"
  },"4": {
    "doc": "2.4 Interacción con la base de datos",
    "title": "2.4 Interacción con la base de datos",
    "content": "## 2.4. Interacción entre MariaDB y PHP {: .no_toc } - TOC {:toc} A partir de ahora, vamos a referirnos a MySQL/MariaDB indistintamente. Este será el gestor de bases de datos relacionales que vamos a usar a lo largo del curso. La adaptación a otros gestores, en cualquier caso, es muy simple. MySQL/MariaDB es un SGBD profesional, por lo que la interacción con él busca ser eficiente y segura, pero no necesariamente fácil. Hay básicamente tres métodos de utilizar MySQL: * **A través de la línea de comandos:** Iniciamos una sesión en MySQL con: ``` $ mysql -h servidor -u nombre_usuario -p ``` Y luego tenemos a nuestra disposición montones de comandos para hacer cosas con la base de datos, incluyendo cualquier instrucción válida en SQL. * **A través de una aplicación con interfaz gráfico como PHPMyAdmin**, una aplicación web escrita en PHP que proporciona un interfaz muy cómodo para trabajar con MySQL o MariaDB. * **A través de un programa escrito en PHP** o algún otro lenguaje con posibilidad de acceso a MySQL. Este método de acceso será el que nosotros practicaremos a lo largo del curso. Por ahora, vamos a ver lo fundamental. ### 2.4.1. MySQL/MariaDB con PHP4 El modo en que se accedía a bases de datos en PHP4 era mediante bibliotecas de funciones diferentes para cada SGBD. Este tipo de codificación está obsoleta y se desaconseja su uso. Ya no tiene soporte oficial, por lo que no se resolverán futuros problemas de seguridad o estabilidad. **Lo mostramos aquí para que sepáis lo que NO se debe hacer.** **Encontraréis mucho código de esta naturaleza en la red que DEBE SER EVITADO.** #### Acceso a MySQL con PHP4 (¡OBSOLETO!) PHP4 utiliza una biblioteca de funciones PHP cuyo nombre empieza por mysql_. Por ejemplo, para insertar un registro en una BD MySQL, se hacía así: ```php ``` Y para ejecutar consultas (SELECT), se recogía el resultado en un cursor. Observa cómo se hacía en este ejemplo: ```php ... continúa en la pág. siguiente ... Consultas SQL con PHP4 (2/2) ... viene de la pág. anterior ... | Nombre | Teléfono | . | '.$registro[\"nombre\"].' | '; echo ' | '.$registro[\"telefono\"].' | . '; } mysql_free_result($result) ?> ``` **RECUERDA: esta forma de operar con la base de datos está OBSOLETA y DEBE SER EVITADA.** Te la mostramos aquí solo para que sepas reconocerla si te la encuentras por las procelosas aguas de internet. ### 2.4.2. MySQL/MariaDB con PHP5+ Desde PHP5, se utiliza una biblioteca de clases para acceder a los diferentes SGBDs. Todos los nuevos desarrollos deberían usar las bibliotecas de clases y prescindir de las viejas librerías de funciones. *Vuelvo a repetirlo: mucho código de ejemplo de PHP que circula por la red es PHP4 y DEBE SER EVITADO.* #### Conectar a MySQL con PHP5+ Por ejemplo, para insertar un registro en una BD MySQL: ```php query(\"INSERT INTO clientes (nombre,telefono) VALUES ('$nombre','$telefono')\"); ?> ``` PHP proporciona varios mecanismos para acceder a bases de datos (¡demasiadas formas de hacer lo mismo!): * **La extensión mysqli en su forma procedimental.** Es idéntica a la de PHP4, pero cambiando la palabra “mysql” por “mysqli”. Por ejemplo, mysql_connect() cambia a mysqli_connect(). Esta forma es apta para programadores perezosos y anticuados, que no quieren pasarse a la programación orientada a objetos. * **La extensión mysqli en su forma orientada a objetos.** Es la que nosotros estamos usando y usaremos todo el curso. * **La extensión PDO.** Se trata de una clase genérica que permite acceder a cualquier gestor de bases de datos mediante el mismo conjunto de métodos. En funcionalidad y rendimiento es idéntica a mysqli. #### Consultas SQL con PHP5+ La ejecución de consultas (SELECT) produce la devolución de un conjunto de registros. Esos registros se manejan en PHP con un cursor. Observa cómo se hace en este ejemplo: ```html connect_error){ die(\"Error en la conexion : \".$db->connect_error); } //Ejecutamos la consulta SQL $result=$db->query(\"SELECT * FROM Clientes\"); ?> | Nombre | Teléfono | . fetch_array()) { echo ' | '.$registro[\"nombre\"].' | '; echo ' | '.$registro[\"telefono\"].' | . '; } $db->free($result); // Libera memoria usada por cursor $db->close(); // Cierra la conexión con el servidor ?> ``` ",
    "url": "/php/interaccion-con-php",
    "relUrl": "/php/interaccion-con-php"
  },"5": {
    "doc": "2.5 Ejercicios resueltos",
    "title": "Biblioteca",
    "content": "\"; // Buscamos todos los libros de la biblioteca if ($result = $db->query(\"SELECT * FROM libros INNER JOIN escriben ON libros.idLibro = escriben.idLibro INNER JOIN personas ON escriben.idPersona = personas.idPersona ORDER BY libros.titulo\")) { // La consulta se ha ejecutado con éxito. Vamos a ver si contiene registros if ($result->num_rows != 0) { // La consulta ha devuelto registros: vamos a mostrarlos // Primero, el formulario de búsqueda echo \" \"; // Ahora, la tabla con los datos de los libros echo \"\"; while ($fila = $result->fetch_object()) { echo \"\"; echo \" | \" . $fila->titulo . \" | \"; echo \" | \" . $fila->genero . \" | \"; echo \" | \" . $fila->numPaginas . \" | \"; echo \" | \" . $fila->nombre . \" | \"; echo \" | \" . $fila->apellido . \" | \"; echo \" | idLibro . \"'>Modificar | \"; echo \" | idLibro . \"'>Borrar | \"; echo \" . \"; } echo \"\"; } else { // La consulta no contiene registros echo \"No se encontraron datos\"; } } else { // La consulta ha fallado echo \"Error al tratar de recuperar los datos de la base de datos. Por favor, inténtelo más tarde\"; } echo \"Nuevo . \"; break; // --------------------------------- FORMULARIO ALTA DE LIBROS ---------------------------------------- case \"formularioInsertarLibros\": echo \" ",
    "url": "/php/ejercicios-resueltos",
    "relUrl": "/php/ejercicios-resueltos"
  },"6": {
    "doc": "2.5 Ejercicios resueltos",
    "title": "Modificación de libros",
    "content": "\"; // Creamos el formulario con los campos del libro echo \" Título: Género: País: Año: Número de páginas:\"; // Añadimos un selector para el id del autor o autores $result = $db->query(\"SELECT * FROM personas\"); echo \"Autores: \"; while ($fila = $result->fetch_object()) { echo \"idPersona . \"'>\" . $fila->nombre . \" \" . $fila->apellido . \"\"; } echo \"\"; echo \"Añadir nuevo\"; // Finalizamos el formulario echo \" \"; echo \"Volver . \"; break; // --------------------------------- INSERTAR LIBROS ---------------------------------------- case \"insertarLibro\": echo \" ",
    "url": "/php/ejercicios-resueltos",
    "relUrl": "/php/ejercicios-resueltos"
  },"7": {
    "doc": "2.5 Ejercicios resueltos",
    "title": "Alta de libros",
    "content": "\"; // Vamos a procesar el formulario de alta de libros // Primero, recuperamos todos los datos del formulario $titulo = $_REQUEST[\"titulo\"]; $genero = $_REQUEST[\"genero\"]; $pais = $_REQUEST[\"pais\"]; $ano = $_REQUEST[\"ano\"]; $numPaginas = $_REQUEST[\"numPaginas\"]; $autores = $_REQUEST[\"autor\"]; // Lanzamos el INSERT contra la BD. echo \"INSERT INTO libros (titulo,genero,pais,ano,numPaginas) VALUES ('$titulo','$genero', '$pais', '$ano', '$numPaginas')\"; $db->query(\"INSERT INTO libros (titulo,genero,pais,ano,numPaginas) VALUES ('$titulo','$genero', '$pais', '$ano', '$numPaginas')\"); if ($db->affected_rows == 1) { // Si la inserción del libro ha funcionado, continuamos insertando en la tabla \"escriben\" // Tenemos que averiguar qué idLibro se ha asignado al libro que acabamos de insertar $result = $db->query(\"SELECT MAX(idLibro) AS ultimoIdLibro FROM libros\"); $idLibro = $result->fetch_object()->ultimoIdLibro; // Ya podemos insertar todos los autores junto con el libro en \"escriben\" foreach ($autores as $idAutor) { $db->query(\"INSERT INTO escriben(idLibro, idPersona) VALUES('$idLibro', '$idAutor')\"); } echo \"Libro insertado con éxito\"; } else { // Si la inserción del libro ha fallado, mostramos mensaje de error echo \"Ha ocurrido un error al insertar el libro. Por favor, inténtelo más tarde.\"; } echo \"Volver . \"; break; // --------------------------------- BORRAR LIBROS ---------------------------------------- case \"borrarLibro\": echo \" ",
    "url": "/php/ejercicios-resueltos",
    "relUrl": "/php/ejercicios-resueltos"
  },"8": {
    "doc": "2.5 Ejercicios resueltos",
    "title": "Borrar libros",
    "content": "\"; // Recuperamos el id del libro y lanzamos el DELETE contra la BD $idLibro = $_REQUEST[\"idLibro\"]; $db->query(\"DELETE FROM libros WHERE idLibro = '$idLibro'\"); // Mostramos mensaje con el resultado de la operación if ($db->affected_rows == 0) { echo \"Ha ocurrido un error al borrar el libro. Por favor, inténtelo de nuevo\"; } else { echo \"Libro borrado con éxito\"; } echo \"Volver . \"; break; // --------------------------------- FORMULARIO MODIFICAR LIBROS ---------------------------------------- case \"formularioModificarLibro\": echo \" ",
    "url": "/php/ejercicios-resueltos",
    "relUrl": "/php/ejercicios-resueltos"
  },"9": {
    "doc": "2.5 Ejercicios resueltos",
    "title": "Modificación de libros",
    "content": "\"; // Recuperamos el id del libro que vamos a modificar y sacamos el resto de sus datos de la BD $idLibro = $_REQUEST[\"idLibro\"]; $result = $db->query(\"SELECT * FROM libros WHERE libros.idLibro = '$idLibro'\"); $libro = $result->fetch_object(); // Creamos el formulario con los campos del libro // y lo rellenamos con los datos que hemos recuperado de la BD echo \" Título:titulo'> Género:genero'> País:pais'> Año:ano'> Número de páginas:numPaginas'>\"; // Vamos a añadir un selector para el id del autor o autores. // Para que salgan preseleccionados los autores del libro que estamos modificando, vamos a buscar // también a esos autores. $todosLosAutores = $db->query(\"SELECT * FROM personas\"); // Obtener todos los autores $autoresLibro = $db->query(\"SELECT idPersona FROM escriben WHERE idLibro = '$idLibro'\"); // Obtener solo los autores del libro que estamos buscando // Vamos a convertir esa lista de autores del libro en un array de ids de personas $listaAutoresLibro = array(); while ($autor = $autoresLibro->fetch_object()) { $listaAutoresLibro[] = $autor->idPersona; } // Ya tenemos todos los datos para añadir el selector de autores al formulario echo \"Autores: \"; while ($fila = $todosLosAutores->fetch_object()) { if (in_array($fila->idPersona, $listaAutoresLibro)) echo \"idPersona' selected>$fila->nombre $fila->apellido\"; else echo \"idPersona'>$fila->nombre $fila->apellido\"; } echo \"\"; // Por último, un enlace para crear un nuevo autor echo \"Añadir nuevo\"; // Finalizamos el formulario echo \" \"; echo \"Volver . \"; break; // --------------------------------- MODIFICAR LIBROS ---------------------------------------- case \"modificarLibro\": echo \" ",
    "url": "/php/ejercicios-resueltos",
    "relUrl": "/php/ejercicios-resueltos"
  },"10": {
    "doc": "2.5 Ejercicios resueltos",
    "title": "Modificación de libros",
    "content": "\"; // Vamos a procesar el formulario de modificación de libros // Primero, recuperamos todos los datos del formulario $idLibro = $_REQUEST[\"idLibro\"]; $titulo = $_REQUEST[\"titulo\"]; $genero = $_REQUEST[\"genero\"]; $pais = $_REQUEST[\"pais\"]; $ano = $_REQUEST[\"ano\"]; $numPaginas = $_REQUEST[\"numPaginas\"]; $autores = $_REQUEST[\"autor\"]; // Lanzamos el UPDATE contra la base de datos. $db->query(\"UPDATE libros SET titulo = '$titulo', genero = '$genero', pais = '$pais', ano = '$ano', numPaginas = '$numPaginas' WHERE idLibro = '$idLibro'\"); if ($db->affected_rows == 1) { // Si la modificación del libro ha funcionado, continuamos actualizando la tabla \"escriben\". // Primero borraremos todos los registros del libro actual y luego los insertaremos de nuevo $db->query(\"DELETE FROM escriben WHERE idLibro = '$idLibro'\"); // Ya podemos insertar todos los autores junto con el libro en \"escriben\" foreach ($autores as $idAutor) { $db->query(\"INSERT INTO escriben(idLibro, idPersona) VALUES('$idLibro', '$idAutor')\"); } echo \"Libro actualizado con éxito\"; } else { // Si la modificación del libro ha fallado, mostramos mensaje de error echo \"Ha ocurrido un error al modificar el libro. Por favor, inténtelo más tarde.\"; } echo \"Volver . \"; break; // --------------------------------- BUSCAR LIBROS ---------------------------------------- case \"buscarLibros\": // Recuperamos el texto de búsqueda de la variable de formulario $textoBusqueda = $_REQUEST[\"textoBusqueda\"]; echo \" ",
    "url": "/php/ejercicios-resueltos",
    "relUrl": "/php/ejercicios-resueltos"
  },"11": {
    "doc": "2.5 Ejercicios resueltos",
    "title": "Resultados de la búsqueda: \\\"$textoBusqueda\\\"",
    "content": "\"; // Buscamos los libros de la biblioteca que coincidan con el texto de búsqueda if ($result = $db->query(\"SELECT * FROM libros INNER JOIN escriben ON libros.idLibro = escriben.idLibro INNER JOIN personas ON escriben.idPersona = personas.idPersona WHERE libros.titulo LIKE '%$textoBusqueda%' OR libros.genero LIKE '%$textoBusqueda%' OR personas.nombre LIKE '%$textoBusqueda%' OR personas.apellido LIKE '%$textoBusqueda%' ORDER BY libros.titulo\")) { // La consulta se ha ejecutado con éxito. Vamos a ver si contiene registros if ($result->num_rows != 0) { // La consulta ha devuelto registros: vamos a mostrarlos // Primero, el formulario de búsqueda echo \" \"; // Después, la tabla con los datos echo \"\"; while ($fila = $result->fetch_object()) { echo \"\"; echo \" | \" . $fila->titulo . \" | \"; echo \" | \" . $fila->genero . \" | \"; echo \" | \" . $fila->numPaginas . \" | \"; echo \" | \" . $fila->nombre . \" | \"; echo \" | \" . $fila->apellido . \" | \"; echo \" | idLibro . \"'>Modificar | \"; echo \" | idLibro . \"'>Borrar | \"; echo \" . \"; } echo \"\"; } else { // La consulta no contiene registros echo \"No se encontraron datos\"; } } else { // La consulta ha fallado echo \"Error al tratar de recuperar los datos de la base de datos. Por favor, inténtelo más tarde\"; } echo \"Nuevo . \"; echo \"Volver . \"; break; // --------------------------------- ACTION NO ENCONTRADA ---------------------------------------- default: echo \" ",
    "url": "/php/ejercicios-resueltos",
    "relUrl": "/php/ejercicios-resueltos"
  },"12": {
    "doc": "2.5 Ejercicios resueltos",
    "title": "Error 404: página no encontrada",
    "content": "\"; echo \"Volver\"; break; } // switch ?> . ``` ``` ",
    "url": "/php/ejercicios-resueltos",
    "relUrl": "/php/ejercicios-resueltos"
  },"13": {
    "doc": "2.5 Ejercicios resueltos",
    "title": "2.5 Ejercicios resueltos",
    "content": "## 2.5. Ejercicios resueltos de PHP {: .no_toc } - TOC {:toc} En esta sección vamos a mostrar algunos ejemplos sencillos de aplicaciones web muy, muy básicas programadas con PHP. La última de ellas incluye un acceso a una base de datos. Mira con detenimiento el código y asegúrate de entenderlo. Para empezar a programar con PHP, no hay nada mejor que echar un vistazo a algunos programas fáciles que luego puedas utilizar como plantilla para los tuyos. ### 2.5.1. Tabla de multiplicar Vamos a escribir un programa en PHP que pida un número al usuario y muestre su tabla de multiplicar hasta el 25 en una tabla HTML de 5 por 5 casillas. En la siguiente solución utilizaremos un solo archivo para implementar tanto el formulario HTML como la recogida de datos del formulario más el cálculo de la tabla de multiplicar. Observa como se usa la función isset() para averiguar si estamos enviando los datos del formulario o si, por el contrario, acabamos de lanzar la aplicación y tenemos que mostrar ese formulario al usuario. ```html . Introduce un número: \"; } else { // Ya tenemos número pasado por GET. Vamos a procesarlo. $n = $_REQUEST[\"numero\"]; echo \"\"; echo \" | Tabla de multiplicar del número $n | . \"; echo \"\"; for ($i = 1; $i \"; echo \" | $n x $i = \" . $n * $i . \" | \"; } echo \" . \"; echo \"\"; } ?> . ``` ### 2.5.2. Juego del número secreto Vamos a escribir una aplicación web en PHP para jugar al número secreto. El juego consiste en lo siguiente: el ordenador \"pensará\" un número al azar entre 1 y 100 y el jugador tendrá que averiguarlo. Cada vez que el jugador haga un intento, la aplicación le indicará si el número secreto es mayor o menor que el número introducido. Cuando el jugador por fin acierte, la aplicación le dará la enhorabuena y le indicará cuántos intentos ha necesitado para averiguar el número secreto. Vamos a ver dos soluciones para este programa. En la primera, utilizaremos variables de la URL para mantener vivos los datos del programa. En la segunda, utilizaremos variables de sesión para lograr el mismo efecto de forma mucho más limpia. #### Juego del número secreto: solución sin variables de sesión Este juego necesita que algunas variables, como el número secreto (variable $aleatorio) o el número de intentos (variable $intentos) persistan entre una solicitud al servidor y la siguiente. Para lograrlo, haremos que el script se envíe a sí mismo el valor de esas variables. Es una solución poco elegante que se dejó de usar hace años, pero que ilustra perfectamente cuál es el primer problema al que nos enfrentamos al desarrollar aplicaciones web: que se ejecutan en el servidor \"a tirones\", un trozo cada vez, y para el servidor cada uno de esos trozos es un programa independiente, aunque el usuario tenga la sensación de que forman una aplicación coherente. ```html . Adivina mi número: \"; } else { $n = $_REQUEST[\"numero\"]; $aleatorio = $_REQUEST[\"aleatorio\"]; $intentos = $_REQUEST[\"intentos\"]; $intentos++; echo \"Tu número es: $n\"; if ($n > $aleatorio) { echo \"Mi número es MENOR\"; } else if ($n ENHORABUENA, HAS ACERTADO . \"; echo \"Has necesitado $intentos intentos\"; } echo \"Sigue jugando...\"; } ?> ``` #### Juego del número secreto: solución con variables de sesión En esta solución, se ha sustituido la chapuza de las variables pasadas por URL por **variables de sesión**. Aunque las veremos con más detalle en el siguiente tema, te puedo adelantar que las variables de sesión permiten almacenar datos persistentes entre sucesivas ejecuciones de scripts desde el mismo cliente. Es decir, el servidor **recuerda** el valor de determinadas variables para que ese programa ejecutado a tirones se comporte como un todo unificado de cara al usuario. Observa detenidamente cómo se usan las variables de sesión con PHP mediante el array global $_SESSION. ```html . Adivina mi número: \"; } else { $n = $_REQUEST[\"numero\"]; $aleatorio = $_SESSION[\"aleatorio\"]; $intentos = $_SESSION[\"intentos\"]; $intentos++; echo \"Tu número es: $n\"; if ($n > $aleatorio) { echo \"Mi número es MENOR\"; echo \"Sigue jugando...\"; } else if ($n Sigue jugando...\"; } else { echo \"ENHORABUENA, HAS ACERTADO . \"; echo \"Has necesitado $intentos intentos\"; $intentos = 0; unset($_SESSION[\"aleatorio\"]); echo \"Jugar de nuevo\"; } $_SESSION[\"intentos\"] = $intentos; } ?> . ``` ### 2.5.3. Biblioteca Este es un ejemplo muy importante por dos razones: 1. Porque es nuestra primera aplicación web \"de verdad\", con una base de datos detrás 2. Porque volveremos sobre ella varias veces para hacerle sucesivas mejoras, hasta dejarla presentable. Se trata de escribir una aplicación web en PHP que gestione (de forma muy simplificada) una biblioteca. La aplicación trabajará con una base de datos compuesta de solo dos tablas (ya te dije que estaría muy simplificada): libros y autores. Esta aplicación nos permitirá, en principio, ver la lista de todos los libros disponibles, así como dar de alta libros nuevos y modificar o borrar los libros existentes. De momento no trabajaremos con los autores, pero sería fácil extenderla para que también nos dejase hacer altas, bajas y modificaciones de los autores. Lee este código con especial atención (aunque sea un poco largo), y observa como utilizamos una variable muy especial llamada $action para saber qué tiene que hacer la aplicación en cada momento. Esa variable es el germen de la arquitectura modelo-vista-controlador con la que trabajaremos una y otra vez más adelante. ```php . <?php $db = new mysqli(\"localhost:3386\", \"root\", \"bitnami\", \"biblioteca\"); if (isset($_REQUEST[\"action\"])) { $action = $_REQUEST[\"action\"]; } else { $action = \"mostrarListaLibros\"; // Acción por defecto } switch ($action) { // --------------------------------- MOSTRAR LISTA DE LIBROS ---------------------------------------- case \"mostrarListaLibros\": echo \" ",
    "url": "/php/ejercicios-resueltos",
    "relUrl": "/php/ejercicios-resueltos"
  },"14": {
    "doc": "2 Introducción a PHP",
    "title": "2 Introducción a PHP",
    "content": "# 2. Introducción a PHP En este capítulo vamos a conocer la sintaxis básica de PHP y cómo este lenguaje trabaja en el lado del servidor para ayudarnos a crear aplicaciones web dinámicas, es decir, aplicaciones que generan un HTML distinto según los datos de entrada. También conoceremos el kit de herramientas básico que vamos a necesitar para convertirnos en desarrolladores/as web y nos conectaremos a una base de datos remota para enviar y recuperar información. Por último, veremos algunos ejemplos de aplicaciones web sencillas que puedes utilizar como base para tus propios desarrollos. {:toc} ",
    "url": "/php/",
    "relUrl": "/php/"
  },"15": {
    "doc": "3 Cookies, sesiones y seguridad",
    "title": "3 Cookies, sesiones y seguridad",
    "content": "# 3. Cookies, sesiones y seguridad {: .no_toc } - TOC {:toc} ## 3.1. Autenticación mediante ACL Casi todas las aplicaciones web incluyen un subsistema de autenticación de usuarios (ACL = Access Control List). Ese subsistema suele estar basado en este diseño de base de datos: ![Tablas ACL](/assets/images/03-acl.jpg) Esto significa que necesitamos **cinco tablas** para implementar un ACL completo. Sin embargo, la mayor parte de las veces tendremos suficiente con solo tres tablas (usuarios, roles y usuarios-roles), o incluso solo con una (usuarios, añadiendo quizá un campo \"tipo\"). Optar por una solución más o menos compleja dependerá del tipos de sistema que estemos implementando. En cualquier caso, es conveniente que conozcas el esquema ACL completo (5 tablas) para que lo pongas en práctica cuando lo necesites. ## 3.2. Cookies ### 3.2.1. ¿Qué son las cookies? Las cookies son pequeños archivos de texto enviados desde el servidor que se almacenan en el lado del cliente. Permiten guardar información de forma persistente, de manera que se mantenga entre una petición al servidor y otra. Una cookie puede durar minutos, horas, días o incluso indefinidamente. PHP soporta cookies de forma transparente. Se pueden configurar Cookies usando las funciones setcookie() o setrawcookie() y el array global $_COOKIE. ### 3.2.2. Manejando cookies con PHP #### Enviar una cookie: setcookie() Esta función define una cookie que se enviará al cliente junto con el resto de las cabeceras de HTTP. Devuelve *true* si la cookie se envía con éxito o *false* en caso contrario. Su sintaxis es: ```php bool setcookie ( string $name [, string $value [, int $expire = 0 [, string $path [, string $domain [, bool $secure = false [, bool $httponly = false ]]]]]] ) ``` Las cookies deben enviarse antes de que el script genere ninguna salida. Esto es una restricción del protocolo http. Por lo tanto, debes llamar a esta función antes de hacer *cualquier* salida, incluidos espacios en blanco. En caso contrario, la cookie no estará disponible hasta que la página se recargue. La función setcookie() admite un montón de parámetros, la mayor parte de ellos optativos: * **name**: El nombre de la cookie. Este es el único obligatorio. * **value**: El valor de la cookie. * **expire**: El tiempo que la cookie tardará en expirar. Se trata de una fecha expresada en formato Unix. * **path**: La ruta del servidor para la que la cookie estará disponible. Si se utiliza '/', la cookie estará disponible en la totalidad del dominio. * **domain**: El dominio para el cual la cookie está disponible. * **secure**: Si la cookie solo debería enviarse en caso de conexión https, pon este argument a *true*. * **httponly**: Esta cookie solo será accesible a través de http. Es decir, no podrá utilizarse desde Javascript. Aquí tienes tres ejemplos de envío de la misma cookie: ```php ``` #### Recuperar una cookie: $_COOKIES[] Para ver el contenido de una cookie, simplemente hay que acceder al array global $_COOKIES. Por ejemplo: ```php ``` #### Borrar una cookie Para forzar el borrado de una cookie en el cliente basta con enviarla con una fecha de expiración anterior a la fecha actual. Por ejemplo: ```php ``` ## 3.3. Sesiones Las sesiones en PHP habilitan un mecanismo para que un script almacene variables (llamadas **variables de sesión**) en el servidor de manera persistente, de modo que posteriores peticiones de scripts procedentes de un cliente puedan acceder a esas variables. Cada cliente tiene su propio espacio de variables de sesión en el servidor, de manera que no se mezclan unas con otras, ni un cliente puede acceder a las variables de otro cliente. La forma en la que PHP logra distinguir a los clientes entre sí es enviándoles una cookie con un valor aleatorio diferente para cada cliente. En el archivo php.ini se puede configurar la manera en la que PHP almacenará las variables de sesión (en memoria, en un fichero, etc), pero esto es irrelevante de cara a su funcionamiento y compete más al administrador del sistema que al programador. Lo que a nosotros nos interesa es aprender a crear variables de sesión, asignarles valor y recuperarlo posteriormente. ### 3.3.1. Abrir sesiones: session_start() Antes de acceder a cualquier variable de sesión (ya sea para crearla, para modificarla o para eliminarla) necesitamos indicarle a PHP que queremos usar variables de sesión en ese scrpit. La función **session_start()** se usa para eso: habilita el acceso a las variables de sesión, es decir, crea una nueva sesión o reanuda una sesión preexistente. Las sesiones admiten un nombre, por si necesitas crear sesiones separadas para el mismo cliente. No obstante, la mayor parte de las veces te bastará con crear sesiones sin nombre, sin necesidad de pasar ningún argumento a session_start(). ### 3.3.2. Usar variables de sesión: $_SESSION Las variables de sesión se manipulan a través del array superglobal **$_SESSION**. Si necesitas una variable de sesión llamada, por ejemplo, nombre_usuario, simplemente haz esto: ```php session_start(); $_SESSION['nombre_usuario'] = \"lo-que-sea\"; ``` Por supuesto, el valor de esa posición del array $_SESSION puede consultarse o modificarse cuando lo necesitemos. ### 3.3.3. Eliminar variables de sesión: unset() y session_destroy() La función **unset()** se utiliza para destruir cualquier variable, incluidas las de sesión: ```php unset($_SESSION['nombre_usuario']); ``` Si lo que deseas es destruir todas las variables de sesión, es preferible recurrir a **session_destroy()**. Ahora bien, session_destroy() destruye la información asociada a la sesión actual, pero no elimina realmente las variables de la memoria del servidor ni borra la cookie de sesión del cliente. Para asegurarte de destruir todas las variables de sesión, puedes usar la función **session_unset()**. Y, para borrar la cookie de sesión, debes usar **setcookie()**, como en este ejemplo: ```php ``` ## 3.4. Sesiones, cookies y seguridad Cookies y variables de sesión se usan a menudo para controlar la seguridad de la aplicación web. Por ejemplo, tras el login, el ID del usuario puede almacenarse en: * **Una cookie**. Si existe esa cookie, significa que el login ha sido correcto y la aplicación puede continuar. * **Una variable de sesión**. Si existe determinada variable (por ejemplo, una con el id del usuario), el login ha sido correcto. Cuando el usuario abandona la aplicación, el programa debe destruir la cookie o cerrar la sesión. Pues bien: **ninguno de estos métodos es completamente seguro**. Las cookies pueden rastrearse o modificarse en el ordenador del cliente. Además, algunos clientes las tienen desactivadas. ¡No te puedes fiar de ellas! Las variables de sesión, en principio más seguras, pueden ser atacadas capturando el ID de sesión, como veremos más adelante. El método más seguro, y el más complicado de programar, es el que combina: * Cookies y/o variables de sesión. * Variables guardadas en una tabla de la BD. El uso de frameworks solventes (como los que veremos este curso) hace innecesario tomarse este trabajo, puesto que todos habilitan un mecanismo de sesiones seguras que mejora notablemente las prestaciones de las sesiones nativas de PHP. ## 3.5. Técnicas de ataque frecuentes (Esta sección está adaptada de [securitybydefault.com](securitybydefault.com)) Uno de los fallos más graves y más frecuentes a la hora de escribir aplicaciones PHP es olvidarse de la seguridad. Cualquier aplicación web, por el mero hecho de estar abierta a recibir información procedente de la red, es susceptible de ser atacada. Y te aseguro que, antes o después, cualquier aplicación que está online acaba por ser atacada. Es una certeza matemática. En esta sección vamos a describir qué tipos de ataque son los más frecuentes. Aunque proporcionaremos algunas estrategias de defensa (que debes tener en cuenta en tus desarrollos), hay una estrategia común a todos estos ataques: utilizar un framework potente como Laravel, Symfony o Zend, debidamente actualizado. Los mecanismos de seguridad que implementan estos frameworks son suficientes para la mayor parte de los casos y se mejoran cada vez que se descubre una vulnerabilidad. ### 3.5.1. Captura de ID de sesión Como ya hemos visto, el ID de sesión se guarda como una cookie en el cliente. Por lo tanto, viaja en el paquete http desde el servidor hasta el cliente. Un atacante que esté escuchando en esa red puede **leer el ID de sesión del paquete http** y, de ese modo, **suplantar la identidad** de la persona que inició la sesión. También puede inyectar Javascript a su víctima para capturar de ese modo el ID de sesión, con idénticos resultados. Soluciones: * Combinar las variables de sesión con cookies o con entradas en la base de datos. * Cambiar el ID de sesión periódicamente. * No confiar en variables de sesión de PHP para almacenar información muy sensible. * Denegar el acceso a la cookie de sesión desde Javascript (usando el atributo httponly). * Acceder solo a webs que usen https, no http. De ese modo, la cookie de sesión viaja encriptada hasta el navegador. ### 3.5.2. Inyección de SQL Este ataque consiste en que **un usuario malintencionado ejecuta sentencias SQL contra la base de datos** del sitio web insertándolas en un formulario. Por ejemplo, si un atacante supone que nuestra tabla de usuarios se llama *users* (una suposición muy razonable), podría inyectar SQL en el formulario de login. Imaginemos un formulario de login donde se introduzcan el *nick* del usuario y la contraseña. El atacante nos atacaría escribiendo algo como esto en el campo *nick*: ``` nada'; DELETE * FROM users; # ``` Imagina lo que pasaría si esta cadena se enviase sin filtrar a una variable php (por ejemplo, $nick) y se lanzase una consulta más o menos así: ``` $sql = \"SELECT * FROM users WHERE nick = '$nick' and passwd = '$pass'\"; ``` ¿Te lo ha imaginado ya? Lo que sucedería es que, al expandir la varible $nick en ese string, se obtendría esta concatenación de sentencias sql: ``` SELECT * FROM users WHERE nick ='nada'; DELETE * FROM users; #'and passwd = '$pass' ``` Cuando el gestor de base de datos reciba esas sentencias, las ejecutará en orden. El primer SELECT no devolverá ningún resultado, pero es sintácticamente correcto y, en cualquier caso, al atacante no le interesan esos resultados. Luego ejecutará el DELETE y ¡bingo! El simpático atacante acaba de cepillarse nuestra tabla de usuarios. (La tercera línea se ignorará, porque empieza por un símbolo de comentario). El atacante no solo puede ejecutar un DELETE, sino que puede llevar a cabo otras acciones destructivas (¿qué tal un DROP DATABASE?) o instrusivas (puede intentar insertar un usuario administrador fraudulento en la tabla users). Y todo ello partiendo de una suposición bastante plausible: que la tabla de usuarios se llama *users*. Para blindarse frente a inyecciones de SQL, se recomienda: * **Filtrar los datos. SIEMPRE**. Por ejemplo, si tenemos en nuestro formulario un campo *username* y sabemos que los usuarios sólo pueden estar compuestos por letras y números, no se deben permitir caracteres como comillas, puntos y coma, asteriscos, etc. * **Escapar los caracteres especiales** de cualquier dato de entrada antes de enviarla al gestor de bases de datos. Por ejemplo, mysql_real_escape_string() coloca barras invertidas antes de ciertos caracteres. addslashes() hace algo parecido. En las versiones recientes de PHP, el escape de caracteres especiales se hace automáticamente con cualquier dato que llegue por GET o POST. * **Usar nombres poco habituales para las tablas** de la base de datos. Una estrategia frecuente es utilizar un identificador significativo (como *users* para la tabla de usuarios) y añadirle varios caracteres o números aleatorios (así, la tabla se convertiría en algo como *users_58283*). Ese sufijo aleatorio se suele almacenar en un archivo de configuración para que esté accesible para todos los scripts del programa. ### 3.5.3. XSS (cross site scripting) El ataque por XSS consiste **ejecutar código de scripting malicioso** (básicamente, Javascript) en el contexto del sitio web. Hay muchas formas de hacer XSS. Por ejemplo, imagínate que tenemos un portal tipo blog de noticias, y que un usuario malicioso publica, dentro del texto de una entrada, este string: ```javascript ``` ¿Qué ocurriría? Pues que cada vez que alguien visite nuestro portal y cargue esa noticia, será redirigido a otrosition.com, donde probablemente pretenderán vendernos medicamentos de dudosa procedencia o algo por el estilo. Otra cosa que suele hacerse con XSS es robar datos de las cookies del cliente. Para ello, el atacante solo tiene que inyectar un código como este: ```javascript ``` Para evitar los ataques XSS, la estrategias más útil, otra vez, es **filtrar todos los datos externos**. El filtrado de datos es la práctica más importante que se puede adoptar: nunca te fíes de ningún dato que provenga de un formulario. ### 3.5.4. CSRF o XSRF (cross site request forgery) Este tipo de ataques **explota la confianza que tiene un sitio web en la identidad de un usuario**. Es decir, se toma a un usuario válido registrado en un sitio (por ejemplo, sitio-confiable.com) y, desde otro sitio (por ejemplo, sitio-maligno.com) se le fuerza a hacer algo chungo en sitio-confiable.com. Veámoslo con un ejemplo. Supón que eres un usuario administrador en sitio-confiable.com. Para borrar a un usuario de tu web (o cualquier otro recurso), lanzas una URL como https://sitio-confiable.com/usuario/delete/28 (donde 28 es el id del usuario). Pues bien, imagina que has abierto una sesión como administrador en sitio-confiable.com y, sin cerrarla, navegas por otra web llamada sitio-maligno.com. Y un atacante súpermalvado, conocedor de tu propensión a navegar por sitios chungos sin cerrar la sesión en sitio-confiable.com, ha colocado este código como parte del código fuente de sitio-maligno.com: ```html ``` Cuando tu navegador cargue esa página, lanzará una petición GET a sitio-confiable.com, resultando en la eliminación del usuario 28 sin que tú te enteres de cómo ha podido suceder semejante desgracia. Esto es solo un ejemplo. Por supuesto, el atacante puede hacer un montón de cosas desagradables en sitio-confiable.com, porque ese sitio está confiando en ti, que eres un usuario legímito. Algunas técnicas para dificultar el ataque por CSRF: * **Utilizar POST en lugar de GET** para recibir datos. * **Generar tokens únicos para cada petición**. Un tóken es una cadena alfanumérica aleatoria generada por el servidor cuando sirve el código HTML de un formulario. El cliente debe enviar de vuelta ese tóken junto con los datos del formulario para que el servidor acepte la petición como válida. Si un atacante intenta efectuar un ataque CSRF, enviará sus peticiones sin el tóken y serán rechazadas. ### 3.5.5. DT (directory transversal) Este ataque se produce cuando el atacante logra **acceder a ficheros del servidor que están fuera del directorio de la aplicación** y que, teóricamente, no deberían ser accesibles desde esta. Es fácil comprender cómo puede montarse un ataque así. Imagina un programa PHP que haga un include de este estilo: ```php include (\"views/\" . $viewName); ``` Si un atacante logra manipular la variable $viewName para asignarle, por ejemplo, el valor \"../../../../otro-fichero.php\", nuestro programa hará un include de un fichero que está claramente fuera de los directorios de la aplicación. Para evitar este tipo de ataques, algunas estrategias son: * **Tener un array de páginas válidas**. Si un include trata de usar un fichero que no está en la lista, se sospechará de un ataque. * **Buscar caracteres sospechosos en los nombres de los archivos**. Si la variable *$viewName* del ejemplo anterior incluye los caracteres \"../\", la cosa se pone fea. No en vano, el ataque Directory Transversal también se denomina \"ataque punto punto barra\". ### 3.5.6. RFI (remote file inclusion) Este ataque se produce cuando **se incluye un archivo remoto** explotando una vulnerabilidad del código fuente. Imagina, como antes, un programa PHP que haga un include tan común como este: ```php include (\"views/\" . $viewName); ``` Imagina también que este código se invoque mediante una petición del estilo: https://sitio-confiable.com?view=main.php, algo perfectamente posible. Pues bien, un atacante puede hacer lo siguiente: https://sitio-confiable.com?view=https://sitio-malicioso/soy-un-script-malvado.php De ese modo, la aplicación cargará el código soy-un-script-malvado.php y lo ejecutará en el servidor sitio-confiable.com. Este código puede entonces hacer cosas terribles, como esta: ```php ``` (No te digo lo que hace por si se te ocurre probarlo) Para prevenir los ataques por RFI, algunas estrategias válidas son: * **No confiar en los datos** que no provengan de nuestro sistema. * **Validar y filtrar los datos** que introduce el usuario (sí, otra vez: validar, validar y validar cualquier cosa que provenga del usuario). ",
    "url": "/cookies-sesiones-seguridad/",
    "relUrl": "/cookies-sesiones-seguridad/"
  },"16": {
    "doc": "4 Arquitectura MVC",
    "title": "Listado de Artículos",
    "content": "| Fecha | Titulo | . fetch_array()) { echo \"\"; echo \" | \".$fila['fecha'].\" | \"; echo \" | \".$fila['titulo'].\" | \"; echo \" . \"; } echo \"\"; // Cerramos la conexión con la BD $db->close(); ?> ``` Esta solución se denomina **monolítica**, porque incluye todo el código necesario en el mismo bloque. Por supuesto, para un ejemplo tan simple como este, el código monolítico es más que suficiente, pero en un sistema más complejo pronto empieza a convertirse en un monstruo inmanejable. ### 4.5.2. Primera mejora: controlador + vista Vamos a aproximarnos un poco a la solución MVC separando ese código monolítico en dos bloques (que guardaremos en archivos distintos): * Un controlador. * Una vista. Primero, el **controlador**. Se encargará de recuperar los datos, pero *no de mostrarlos*. Generar el interfaz de usuario, es decir, el HTML, será la labor que le dejaremos a la vista. El controlador preparará esos datos y los empaquetará en un array para que estén disponibles en la vista. Y la vista la insertaremos en el controlador con un include(). ```php query('SELECT fecha, titulo FROM articulo'); $articulos = array(); while ($fila = $resultado->fetch_array()) { $articulos[] = $fila; } $db->close(); include('vista.php'); ?> ``` La **vista** que mostrará los datos del array contiene un código muy semejante al de la solución monolítica, solo que ahora estará ubicada en un archivo aparte, llamado vista.php, y hará un bucle sobre el array de resultados que le ha preparado el controlador: ```php ",
    "url": "/mvc/",
    "relUrl": "/mvc/"
  },"17": {
    "doc": "4 Arquitectura MVC",
    "title": "Listado de Articulos",
    "content": "| Fecha | Titulo | . | | . ``` ### 4.5.3. Segunda mejora: modelo, vista y controlador En esta segunda mejora, dividiremos el código en tres bloques (ubicados, de nuevo, en archivos diferentes): * Un modelo (archivo model.php) --> Contendrá una clase con un método que se encargará de acceder a la base de datos y empaquetar el resultado de la consulta en un array. * Una vista (archivo view.php) --> Se encargará de generar el HTML con el resultado de la consulta. * Un controlador (archivo index.php) --> Se encargará de invocar al modelo y a la vista en el orden correcto. Por lo tanto, el **controlador** se queda en algo tan sencillo como esto: ```php include('model.php'); // En este archivo estará el modelo $articulos = Model::getAll(); require('view.php'); // En este archivo estará la vista ``` El **modelo** consta de una clase con un método (de momento) encargado de consultar todos los artículos y devolverlos empaquetados en un array: ```php query('SELECT fecha, titulo FROM articulo'); $articulos = array(); while ($fila = $resultado->fetch_array()) { $articulos[] = $fila; } $db->close(); return $articulos; } } ?> ``` Por último, la **vista** será exactamente igual que en la versión anterior: un recorrido por el array de artículos para mostrarlos en formato HTML: ```php ",
    "url": "/mvc/",
    "relUrl": "/mvc/"
  },"18": {
    "doc": "4 Arquitectura MVC",
    "title": "Listado de Articulos",
    "content": "| Fecha | Titulo | . | | . ``` ### 4.5.4. Tercera mejora: añadiendo capa de abstracción de datos Como no sabemos lo que es el miedo, vamos a complicar nuestro patrón modelo-vista-controlador con una cuarta capa: la capa de abstracción de datos. La idea de esta capa adicional es proporcionar un mecanismo de abstracción respecto del gestor de base de datos concreto que estemos utilizando. Si te fijas en el **modelo** de la solución anterior, verás que estamos usando una clase (mysqli) y unos métodos que solo funcionan con MySQL o MariaDB. Si quiséramos cambiar el gestor de base de datos, tendríamos que revisar todos nuestros modelos. Una forma de independizar la aplicación del gestor de base de datos es programar una **capa de abstracción** que contenga dos o tres métodos genéricos (como consultar() para lanzar SELECT o manipular() para lanzar INSERT, UPDATE o DELETE). De ese modo, cuando queramos hacer una consulta desde el modelo, no lo haremos con los métodos de MySQL o de otro gestor de bases de datos, que traduzcan una petición genérica (como consultar(\"SELECT * FROM users\")) a una petición concreta para un gestor de base de datos (new mysqli(...), $db->query(), etc). Por lo tanto, en esta tercera mejor vamos a dividir el código en cuatro bloques: * Un controlador (archivo index.php). * Una vista (archivo view.php). * Un modelo en dos capas * Capa de abstracción de datos (dbabstract.php) * Capa de acceso a datos (el modelo propiamente dicho) (model.php). El código de la **capa de abstracción** sería algo así: ```php class DbAbstract { private $db; function crearConexion($servidor, $usuario, $clave, $dbname) { $db = new mysqli($servidor, $usuario, $clave, $dbname); } function cerrarConexion() { if ($db) $db->close(); } function consulta($consulta) { $res = $db→query($consulta); $resArray = array(); if ($res) { $resArray = $res->fetch_all(); } return $resArray; } ...etc... (añadimos cualquier función que acceda directamente a MySQL) } ``` El código del **modelo** va a hacer uso de la capa de abstracción: ```php include \"DbAbstract.php\"; class Model { public function getAllArticulos() { $db = new dbAbstract(); $db->crearConexion('localhost', 'usuario', 'clave', 'dbName'); $articulos = $db->consulta('SELECT fecha, titulo FROM articulo'); $db->cerrarConexion(); return $articulos; } } ``` El **controlador** y la **vista** son exactamente los mismos que en la solución anterior. ### 4.5.5. Cuarta (y última) mejora: transformación en clases y objetos reutilizables Para terminar, vamos a dejar el código bien organizado y a mostrarlo completo. Lo que haremos en esta última etapa es empaquetarlo todo en clases reutilizables. Observa que sigue siendo el mismo código fuente, solo que empaquetado en clases y métodos. Lo único que queda fuera de una clase es la instanciación del objeto controlador. Fíjate bien en cómo hemos convertido las vistas en una clase con un método show() que nos servirá para mostrar cualquier vista y reutilizar el mismo header y el mismo foorter. Cada vista se programará en un archivo independiente que deberemos organizar el directorios y subdirectorios. Otra cosa que quiero que observes con atención es el controlador, porque lo hemos dejado preparado para poder añadir nuevas funciones al programa con posterioridad. Este controlador te servirá de esqueleto para montar tus propias aplicaciones MVC. **index.php** ```php $controlador = new Controller(); $controlador->main(); ``` **controller.php** ```php include (\"View.php\"); include (\"Model.php\"); class Controller { public function main() { $estado = (isset($_REQUEST['do']) ? $_REQUEST['do'] ; \"formLogin\"); switch ($estado) { case \"formLogin\": ... case \"checkLogin\": ... case \"showAllArticles\": $articulos = Articulos::getAllArticulos(); View::show(\"showAllArticles\"); break; case \"...etc...\": ... } } } ``` **view.php** ```php ``` **showAllArticles.php** ```html ",
    "url": "/mvc/",
    "relUrl": "/mvc/"
  },"19": {
    "doc": "4 Arquitectura MVC",
    "title": "Listado de Articulos",
    "content": "| Fecha | Titulo | . | | . crearConexion('localhost', 'usuario', 'clave','dbName'); $articulos = $db->cosulta('SELECT fecha, titulo FROM articulo'); $db->cerrarConexion(); return $articulos; } } ``` **dbabstract.php** ```php class DbAbstract { private $db; function crearConexion($servidor, $usuario, $clave, $dbname) { $db = new mysqli($servidor, $usuario, $clave, $dbname); } function cerrarConexion() { if ($db) $db->close(); } function consulta($consulta) { $res = $db→query($consulta); $resArray = array(); if ($res) { $resArray = $res->fetch_all(); } return $resArray; } ...etc... (añadimos cualquier función que acceda directamente a MySQL) } ``` ## 4.6. El patrón MVC en la teoría Ahora que hemos aprendido a manejarnos con el patrón MVC por medio de un ejemplo, estamos en condiciones de definirlo de manera más teórica y, oh maravilla, incluso entender esa definición. El patrón MVC divide la aplicación en tres capas: * **Los modelos**, donde se programa la *lógica de negocio*. De esa forma tan rimbombante se refiere la literatura técnica al acceso a los datos con los filtros, algoritmos y restricciones que el sistema imponga. En la práctica, esto significa que en los modelos debemos colocar todo el código de acceso a la base de datos o a cualquier otro recurso del servidor (como las variables de sesión, por ejemplo). Los modelos deben empaquetarlos en objetos estándar de PHP (como arrays) y devolverlos al controlador. Lo más práctico es crear un modelo para cada tabla maestra de la base de datos. Los frameworks automatizan los métodos más típicos de cada modelo, como insertar un registro, borrar, actualizar, consultar uno o consultar todos. * **Las vistas**, donde se programan todas las salidas HTML que el usuario final va a ver y con las que va a interactuar. El código Javascript y CSS, por lo tanto, forma parte de las vistas. En las vistas estará el grueso del código de cualquier aplicación. Los frameworks más avanzados incluyen sistemas de plantillas y lenguajes adicionales para simplificar este proceso, pero si programamos en PHP clásico, tendremos que construir las vistas manualmente. * **Los controladores**, donde se captura cada petición del usuario y se dirige el flujo de ejecución, invocando a los modelos y a las vistas en el orden adecuado. En una aplicación pequeña, bastará con tener un controlador para todo. Cuando la aplicación crece, suele hacerse un controlador por cada modelo, es decir, un controlador por cada tabla maestra. Nuestros controladores van a estar compuestos por un switch muy grande con un case para cada funcionalidad de la aplicación. Ese switch estará dirigido por una variable de control. En los frameworks, este switch se transforma en una colección de métodos, lo cual proporciona un código mucho más elegante, pero que funcionalmente hace lo mismo. ",
    "url": "/mvc/",
    "relUrl": "/mvc/"
  },"20": {
    "doc": "4 Arquitectura MVC",
    "title": "4 Arquitectura MVC",
    "content": "# 4. Arquitectura MVC {: .no_toc } - TOC {:toc} Cuando hablamos de arquitectura de una aplicación web nos referimos a la estructura básica que la sustenta, como los pilares de un edificio en construcción. Si quitas las paredes, las ventanas, las puertas, los azulejos de la cocina... todavía pueden distinguirse las formas fundamentales, ¿verdad? En este tema, hablaremos mucho de la arquitectura más popular en aplicaciones web (llamada MVC; no te preocupes, pronto se convertirá en tu mejor amiga). Pero, antes, vamos a darle una vuelta al término \"arquitectura\", porque en aplicaciones web se usa con dos significados distintos que conviene que tengas claros para no hacerte un lío. ## 4.1 Arquitecturas FÍSICAS multinivel (multitier) Hablamos indistintamente de \"arquitectura de una aplicación web\" para referirnos a dos cosas distintas: la arquitectura física y la arquitectura lógica. Y ahí empiezan los líos. Vamos a intentar desliarnos antes de apretar el nudo. Una **arquitectura física de varios niveles** (multinivel o multitier, en inglés) consiste en un conjunto de ordenadores conectados a una red que ejecutan de forma conjunta una aplicación. El ejemplo más sencillo es la arquitectura cliente-servidor, la más popular en aplicaciones web sencillas: una máquina cliente y una máquina servidor ejecutan alternativamente fragmentos del código, proporcionando al usuario final la sensación de una aplicación unificada. ![Arquitectura en 2 niveles](/assets/images/04-arquitectura-2-niveles.png) Por supuesto, nada impide que tengamos más de dos máquinas colaborando en red par ejecutar una aplicación web. Podemos tener, por ejemplo, un cliente, un servidor web y un servidor de bases de datos (estos dos últimos en dos máquinas físicas diferentes). Esto sería una arquitectura de 3 niveles físicos. La arquitectura de N niveles tendría este aspecto: ![Arquitectura en N niveles](/assets/images/04-arquitectura-N-niveles.png) ## 4.2 Arquitecturas LÓGICAS multicapa (multilayer) Ahora viene la vuelta de tuerca: la arquitectura de una aplicación también puede referirse a sus capas (layers) lógicas. Es decir, a las capas de software que nosotros, como desarrolladores, crearemos. Dividir una aplicación en capas que colaboran entre sí por medio de interfaces bien definidos no es una idea nueva, ni pertenece exclusivamente al ámbito de la programación web. Pero la mayor parte de las aplicaciones web hacen uso de este mecanismo de abstracción. La idea es dividir nuestra aplicación en capas de niveles de abstracción cada vez mayor. La capa superior (la más abstracta) es la que interacciona con el usuario: ahí se implementará nuestro interfaz de usuario, o lo que en aplicaciones web se llama *front-end*. La capa inferior (la menos abstracta) es la que está en contacto con el hardware de la máquina. Bueno, con el hardware no: debajo de ella habrá otras capas que ya no pertenecen a nuestra aplicación y que se encargarán de ello: el sistema operativo, el servidor, el gestor de bases de datos, o lo que sea. Pero nuestra capa inferior será la que interactúe con esas otras capas que escapan a nuestros dominios y que están en contacto con la máquina. Esta división en capas de abstracción, que puede parecer al neófito una complicación innecesaria, tiene un montón de ventajas y por eso se usa en cualquier aplicación un poco más complicada que \"Hola, mundo\". ### 4.2.1. Ventajas de las arquitecturas multicapa Las arquitecturas multicapa permiten varias cosas que no pueden hacerse con los códigos monolíticos. Entre otras: * Desarrollar en paralelo cada capa (mayor rapidez de desarrollo). * Aplicaciones más robustas (gracias al encapsulamiento. ¿Te suena? ¡Programación orientada a objetos!). * Matenimiento más sencillo. * Más flexibilidad para añadir módulos. * Más escalabilidad para aumentar rendimiento. * Más seguridad, al poder aislar (relativamente) cada capa del resto. * Mejor escalabilidad: es más fácil hacer crecer al sistema. * Mejor rendimiento (aunque esto podría discutirse: puedes hacer un sistema multicapa con un rendimiento desastroso y un sistema monolítico que vaya como un tiro. Pero, en general, es más fácil mejorar el rendimiento trabajando en cada capa por separado). * Es más fácil hacer el control de calidad, incluyendo la fase de pruebas. ### 4.2.2. Esquema Modelo-Vista-Controlador (MVC) Y por fin llegamos a la palabreja: Modelo-Vista-Controlador o MVC. ¿Qué narices es esto? Tan solo una arquitectura multicapa estandarizada. Una arquitectura de 3 capas, para ser exactos. Este es el esquema de una arquitectura en 3 capas. Recuerda: cada capa ejecuta una parte de la solución, y entre ellas colaboran para formar la aplicación completa. La capa superior interactúa con el usuario; la capa inferior, con la máquina (donde dice \"hardware\", debería decir \"cualquier cosa menos abstracta que nuestro programa\"). Tienes permiso para imaginar cada capa como una clase con sus métodos y atributos. ![Arquitectura en 3 capas](/assets/images/04-arquitectura-3-capas.png) Pues bien, si a esas tres les ponemos nombres exóticos como modelo, vista y controlador, y remeneamos un poco el esquema, ya lo tenemos: la arquitectura MVC. ![Arquitectura MVC](/assets/images/04-arquitectura-mvc.png) Es decir, la arquitectura MVC solo es un caso particular de la arquitectura en 3 capas. ¿Y ya está? Bueno, no. Ahora tienes que aprender qué signfica *en realidad* esta palabrería. Para que tengas una idea completa del asunto, ahora tienes que aprender qué parte de la aplicación se ejecuta en cada una de las capas. Pero es más simple de lo que parece. Y lo maravilloso es que el 99,99% de las aplicaciones web encajan como un guante en esta arquitectura. Es decir, apenas tendremos que hacer trabajo de diseño previo, porque, si es una aplicación web, ya sabemos qué clases tendremos que construir: los que nos indique la arquitectura MVC. Antes de entrar en profundidad, un breve apunte: por supuesto, nada impide construir arquitecturas con más de 3 capas. De hecho, nosotros vamos a usar una variante del MVC en el que se añade una capa adicional por debajo del modelo, es decir, una arquitectura con 4 capas. Pero ya llegaremos a eso. ## 4.3. Patrones de software Los **patrones de software** son soluciones comprobadas a problemas comunes en el desarrollo de software. Para que un patrón pueda considerarse tal cosa, tiene que cumplir estas condiciones: * Debe haber sido comprobado en otros sistemas. * Debe ser fácilmente reutilizable. * Debe ser aplicable a diferentes circunstancias. * Debe estar bien documentado. La documentación típica de un patrón de software incluye: * Problema que resuelve. * Contexto en el que es aplicable. * Fuerzas, objetivos y restricciones. * Solución que propone. * Ejemplos. * Contexto resultante. * Exposición razonada. * Otros patrones relacionados. ### 4.4.2. Tipos de patrones: Dependiendo del grado de abstracción del patrón, existen patrones de diverso tipo: * De arquitectura * De diseño * De creación de objetos * De estructura de clases * De comportamiento * De dialectos * De interacción o interfaz de usuario * De análisis * De dominio Quizá no te sorprenda oír que el esquema MVC se considera un **patrón de software de arquitectura**. ### 4.4.3. Ejemplo de patrón: el patrón Singleton Antes de centrarnos en MVC, vamos a ver, solo a modo de ejemplo, otro tipo de patrón: **el patrón Singleton**. Algunos recursos en una aplicación son de tal naturaleza que sólo puede existir una instancia de ese tipo de recurso. Por ejemplo, la conexión a la base de datos a través de un manejador de base de datos. A veces interesa compartir un manejador de base de datos para que el resto de recursos no tengan que conectarse y desconectarse continuamente de la BD, y sólo debería existir una instancia de ese manejador. El patrón Singleton cubre esta necesidad. Un objeto es “singleton” si la aplicación puede generar una y sólo una instancia del mismo. Esta es una implementación reutilizable de ese patrón: ```php _handle =& DB::Connect( $dsn, array() ); } public function handle() { return $this->_handle; } } print( \"Handle = \".DatabaseConnection::get()->handle().\"\\n\" ); print( \"Handle = \".DatabaseConnection::get()->handle().\"\\n\" ); ?> ``` ## 4.5. El patrón MVC en la práctica Tras esta introducción, vamos a estudiar a fondo el patrón MVC. Y lo vamos a hacer por medio de un ejemplo, que es como mejor suelen comprenderse estas cosas. Una vez terminado y comprendido el ejemplo, daremos una definición forma del patrón MVC. Si lees el código fuente con atención, verás como, al acabar, entenderás perfectamente en qué consiste el MVC y podrás empezar a aplicarlo en tus proyectos. El ejemplo con el que vamos a trabajar es este: supongamos que queremos programar una pequeña aplicación web que nos permita hacer publicaciones en una especie de blog simplificado. Esas publicaciones se guardan como registros en una tabla de una base de datos. En el código de ejemplo sobre el que vamos a trabajar, nos vamos a centrar en obtener de la base de datos el listado de los artículos existentes para mostrarlo en una página HTML. ### 4.5.1. Código monolítico Una primera aproximación a la solución, sin usar ningún patrón de arquitectura en absoluto, podría ser esta (échale un vistazo y asegúrate de entenderlo): ```php query('SELECT fecha, titulo FROM articulo'); ?> // Generamos una tabla con el resultado de la consulta ",
    "url": "/mvc/",
    "relUrl": "/mvc/"
  },"21": {
    "doc": "5 Laravel",
    "title": "5 Laravel",
    "content": "# 5. Laravel Laravel es un framework PHP MVC diseñado para agilizar el desarrollo de aplicaciones web. En los últimos años ha tenido una gran penetración en la industria. Empezaremos por aprender qué es un framework PHP MVC, qué frameworks existen y en qué circunstancias resulta interesante utilizar una de estas herramientas para desarrollar una aplicación. Dedicaremos el resto del tema a estudiar todas las peculiaridades de Laravel para aprender a desarrollar aplicaciones con este poderoso framework. ",
    "url": "/laravel/",
    "relUrl": "/laravel/"
  },"22": {
    "doc": "6 Servicios web",
    "title": "6 Servicios web",
    "content": "# 6. Servicios web {: .no_toc } - TOC {:toc} ## 6.1. ¿Qué es un servicio web? Como dijimos al estudiar el patrón MVC, esta arquitectura no es la única manera de plantear las aplicaciones web. En este tema vamos a hablar de otra manera en la que las aplicaciones web funcionan muy frecuentemente: como simples servicios. ### 6.1.1. Una definición de servicio web Un **servicio web** es una forma de permitir que una aplicación cliente y una aplicación servidor se comuniquen entre sí e intercambien información independientemente de la plataforma en la que cada una se ejecute. Los mensajes que las aplicaciones se intercambiar generalmente tienen formato XML o JSON. Hay dos estándares principales en la industria para implementar servicios web: **SOAP** y **REST**. ### 6.1.2. Diferencias entre servicios web y aplicaciones web Llegados a este punto, puede que estés pensando: \"Vale, pero ¿en qué se diferencia todo esto de una aplicación web MVC? ¿No intercambian también el cliente y el servidor información independientemente de la plataforma en la que se ejecuta cada uno?\". Pues sí, pero hay algunas **diferencias fundamentales entre un servicio web y una aplicación web**: * Una aplicación web está diseñada para que un ser humano interactúe con ella a través de un interfaz DHTML. Un servicio web, en cambio, está pensado para que lo use otra aplicación (el cliente), no un ser humano. * Por ese motivo, los servicios web carecen de interfaz de usuario y no produce salidas HTML legibles. Es decir, un servicio web **no tiene vistas**. * En cambio, los servicios web suelen producir salidas XML o JSON, pensadas para que los clientes las procesen. Una aplicación web solo hace esto cuando responde a una petición Ajax, algo que veremos más adelante. Por lo demás, un servicio web puede tener una arquitectura *aproximadamente* MVC, y digo *aproximadamente* porque el servicio web, como acabo de contarte, carece de vistas. Pero puede seguir conservando sus controladores y sus modelos. Los controladores se encargarán de convertir los datos de los modelos a JSON o XML y devolverlos al cliente. ## 6.2. SOAP **SOAP (Single Object Access Protocol)** es un mecanismo estandarizado para la implementación, descripción y publicación de servicios en red. SOAP establece el modo en el que deben comportarse el cliente y el servidor para hablar entre sí, así como la forma en la que el servidor debe dar a conocer sus servicios. Es un mecanismo orientado al proceso, a diferencia de REST, que está orientado a los datos y que veremos después. ### 6.2.1. La pila de protocolos de SOAP El estándar SOAP define una serie de protocolos de niveles de abstracción crecientes. Esta colección de protocolos suele denominarse **pila de protocolos SOAP**, y son los siguientes: XXX imagen Vamos a explicar brevemente en qué consiste cada protocolo de la pila, y lo vamos a hacer, como en otras ocasiones, por medio de un ejemplo en lugar de perdernos en largas y farragosas explicaciones. ### 6.2.2. Los protocolos SOAP y WSDL Para ver cómo funciona el protocolo SOAP (el más importante de la pila de protocolos SOAP, como ya te habrás imaginado por su nombre), utilizaremos tres ejemplos: * En el primero, veremos cómo construir un servidor que duelva colecciones de datos en forma de array. * En el segundo, veremos cómo puede un servidor devolver datos con estructura más compleja formateados con JSON. * En el tercero, veremos un servidor extremadamente simple con un fichero WSDL. #### Ejemplo 1: Consulta de una BD de marcas y modelos de coches. Vamos a programar un servicio web muy sencillo capaz de servir a los clientes que nos lo pidan un listado de las marcas de coches que existen y otro con los modelos registrados que pertenecen a una marca en concreto. El servidor, por lo tanto, necesita dos funciones: * ObtenerMarcas * ObtenerModelos($marca) El cliente, como es lógico, debe conocer cómo utilizar el servidor. Esto puede hacerse mediante el protocolo WSDL (que ya veremos un poco después) por otras vías más tradicionales: documentación de la API, guía del desarrollador, manual de usuario... En estos ejemplos, tanto el servidor como el cliente estarán escritos en PHP. Por supuesto, puede usarse cualquier otro lenguaje para ello, en particular en el lado del cliente. Para saber cómo hacer un cliente SOAP en otros lenguajes, consulta la documentación de tu lenguaje preferido. **En el lado del servidor** necesitaremos crear un objeto de tipo SoapServer y definir los métodos a los que el servidor va a responder. Vamos a empezar por los métodos. Crearemos un fichero (por ejemplo, llamado **GestionAutomoviles.class.php**) en cuyo interior escribiremos una clase con los métodos que necesitemos. Para nuestro ejemplo de marcas y modelos de coches, podrías ser algo así: El servidor se crea con una clase que contenga los métodos necesarios: ```php class GestionAutomoviles { public function ObtenerMarcas() { $db = new mysqli(); $marcas = array(); if( $db ) { $result = $db->query('select id, marca from marcas'); while( $row = $result->fetch_array() ) $marcas[$row['id']] = $row['marca']; $db->close(); } return $marcas; } public function ObtenerModelos($marca) { $db = new mysqli(); $marca = intVal($marca); $modelos = array(); if( $marca !== 0 ) { $result = $db->query('select id, modelo from modelos where marca = ' . $marca ); while( $row = $result->fetch_array() ) $modelos[$row['id']] = $row['modelo']; } $db->close(); return $modelos; }} ``` Ahora, en otro archivo aparte, que llamaremos, por ejemplo, *webservice.php*, *registramos el servicio* usando la clase SoapServer de PHP y asignándole la clase anterior GestionAutomoviles. Así: ```php 'http://localhost/')); $soap->setClass('GestionAutomoviles'); $soap->handle(); ?> ``` El constructor de SoapServer tiene dos argumentos: * El fichero WSDL donde se describe el servicio. Como aún no vamos a usar fichero WSDL, ese argumento lo dejaremos, de momento, a null. * La URL donde el servidor va a estar escuchando. Puede ser el directorio raíz de nuestro servidor o cualquier subdirectorio o archivo. Por último, y para comprobar que nuestro servidor SOAP funciona bien, necesitamos crear un secillo cliente que consuma ese servicio. Como hemos dicho antes, esta parte también la vamos a programar en PHP, aunque podría hacerse en cualquier otro lenguaje con soporte SOAP. **En la parte cliente**, necesitamos crear un objeto de tipo SoapClient: ```php $soapS = new SoapServer(null, \"URI del servidor\"); ``` Nuevamente, el primer argumento del constructor es el fichero WSDL. Como aún no trabajamos con ellos, lo dejamos a null. Si tuviéramos fichero WSDL, no necesitaríamos indicar la URI del servidor, porque el propio fichero WSDL lo establecería de forma inequívoca. Una vez hecho eso, podemos consumir los servicios del cliente. Por ejemplo: ```php 'http://localhost/', 'location' => 'http://localhost//webservice.php')); $marcas = $client->ObtenerMarcas(); foreach($marcas as $key => $value ) echo $value; ?> ``` Observa cómo hemos indicado la localización del servidor: en un array, indicamos su ubicación y la ruta de acceso al fichero que maneja el servicio (en nuestro ejemplo, webservice.php). #### Ejemplo 2: Lista de libros de una biblioteca. El ejemplo anterior funciona porque tanto cliente como servidor trabajan en PHP. Pero si el cliente no fuera PHP, podría tener problemas al recibir los datos de respuesta del servidor, que son arrays PHP. Lo más adecuado cuando se responden datos complejos es enviarlos en algún formato de intercambio de información, como XML o JSON. En este nuevo ejemplo, vamos a crear un servidor que nos devuelva la lista de libros de una biblioteca (lo que incluirá el id, el título y el ISBN de cada libro) empaquetada en un string JSON. De momento, tampoco usaremos WSDL (fichero de descripción del servicio). **Servidor** (archivo *libros.class.php*): ```php class libros { private function getLibrosJSON() { $sql = \"SELECT * FROM libros\"; $db = new dbAbstract(); // Suponemos que existe una capa // de abstracción de datos return json_encode($db->consulta($sql)); } ...aquí irían más métodos que pudiera tener el servidor } Registramos el servidor en otro archivo (que llamaremos *libros.server.php*): ```php 'http://localhost/')); $soap->setClass('libros'); $soap->handle(); ?> ``` **Cliente** De nuevo, lo vamos a crear en PHP, aunque no sea lo más habitual. Al ser un programa PHP, tendrás que ejecutarlo contra un servidor web, o bien directamente desde la línea de comandos. ```php 'http://localhost/', 'location' => 'http://localhost/libros.server.php')); $listaLibros = $libros->getLibrosJSON(); ?> ``` A partir de ahí, el cliente dispondrá en $listaLibros de la información recibida del servidor (id, titulo, isbn de todos los libros) empaquetada en formato JSON. #### Ejemplo 3: Servicio de calculadora Este será un servicio mucho más simple y hasta un poco tontorrón, pero no te lo tomes a mal: solo es un ejemplo. El servicio simple y tontorrón proporcionará dos métodos: * sumar (op1, op2) --> Devuelve la suma de op1 y op2 * restar (op1, op2) --> Devuelve la diferencia entre op1 y op2 Ahora sí usaremos WSDL para definir el servicio y que los clientes sepan cómo usarlo. Así, a través de un ejemplo simple (y tontorrón) podrás conocer cuál es la estructura de estos ficheros. **Servidor** El código del servidor es extremadamente simple. Fíjate en que ahora, el crear el objeto SoapServer, sí indicamos el archivo WSDL: ```php AddFunction(\"sumar\"); $server->AddFunction(\"restar\"); $server->handle(); ?> ``` **Cliente** ```php sumar(2.7, 3.5); $resultado_resta = $clienteSOAP->restar(2.7, 3.5); echo \"la suma de 2.7 mas 3.5 es: \" . $resultado_suma . \"\"; echo \"la diferencia de 2.7 menos 3.5 es: \" . $resultado_resta . \"\"; ?> ``` **Documento WSDL** El documento WSDL es un archivo de texto alojado en el servidor donde se describen todos los aspectos del servicio: * Los mensajes que se pueden intercambiar entre el cliente y el servidor. * Los argumentos y tipos de datos de esos mensajes. * Las operaciones y sus tipos * Las rutas donde puede encontrarse el servidor Se trata de un documento en formato XML que resulta bastante farragoso de leer, así que tómatelo con calma (ahora entiendes por qué hemos elegido un servicio tan simple como el de este ejemplo para ver su archivo WSDL: si usáramos un servicio más realista, el archivo resultaría un monstruo de miles de líneas). Aquí lo tienes: ```xml . ``` Escribir los documentos WSDL a mano es casi imposible. Y hacerlo sin cometer errores, es imposible del todo. Para eso existen herramientas automatizadas que toman el archivo con la clase que contiene los métodos del servicio y generan automáticamente el archivo WSDL. Puedes encontrar estas herramientas de creación automática del archivo WSDL en cualquier IDE avanzado (como Netbeans o Eclipse) y también en mucho sitios web. Por lo tanto, no es un documento que vayas a tener que redactar tú, ni siquiera que leer tú: se trata de una descripción del servicio escrita por y para programas informáticos. Por eso no tiene un formato demasiado legible para un humano. ### 6.2.3. UDDI Este protocolo, que también forma parte de la pila SOAP, es muy fácil de explicar. Olvídate de que existe. Fin de la explicación. Fácil, ¿verdad? Pero si esta explicación te sabe a poco, te cuento que UDDI fue un intento de la industria por estandarizar repositorios de servicios, de manera que cualquier cliente pudiera lanzar una petición a la red para descubrirlos y usarlos. Imagina que tienes una web que necesita conocer la previsión del tiempo en una zona, la que sea. Puedes localizar un servicio web que te proporcione esa información (ya sea de forma gratuita o mediante una suscripción, eso es irrelevante). Hay, de hecho, muchos servidores que ofrecen este servicio, empezando por el de la Agencia Estatal de Meteorología. Para usar ese servicio, tienes que conocer el servidor que lo ofrece y luego bucear en su API para avieriguar cómo narices debes pedirle la información y en qué formato te la va a devolver. Y, una vez hecho eso, ya estás listo para programar tu cliente y consumir ese servicio. Pues bien: el servicio UDDI buscaba implementar una manera para que el servidor publicara el tipo de servicio que está ofertando y los clientes pudieran escanear la red en busca de esos servicios, para luego seleccionar uno y lanzar peticiones contra él, todo ello de forma más o menos transparente al programador. Era una idea interesante, ¿verdad? Pero murió hace mucho. De hecho, entró en punto muerto en el año 2006, cuando Microsoft e IBM decidieron abandonarlo. Así que, lo dicho: aunque en teoría el protocolo UDDI forma parte de la pila SOAP, puedes actuar como si no existiera. ## 6.3. REST ### 6.3.1. ¿Qué es REST? **REST (Representational State Transfer)** es un mecanismo de intercambio de información entre clientes y servidores de una red. A diferencia de SOAP, está orientado a los datos, esto eso, proporciona siempre los mismos tipos de acceso a los recursos, sin posibilidad de definir nuevas operaciones. Por esa razón se dice que **REST está orientado a los datos** mientras que **SOAP está orientado a los procesos**. Actualmente, gran parte de las APIs, ya sean públicas o privadas, se programan según el diseño RESTful para que los programadores que las usen sepan qué esperar de la API. ### 6.3.2. Las 7 operaciones REST Un servidor REST (también llamado **RESTful**) debe implementar siete operaciones de acceso a cada tipo de recurso. Los nombres de las operaciones, los datos que se esperan que se devuelvan y el método de acceso (si se accede al servidor por http, que es lo que nosotros haremos) deben respetarse escrupulosamente. Imagina que estamos programando un servidor RESTful para acceder, por ejemplo, a un recurso llamado *Producto* dentro de una aplicación más grande (por ejemplo, una tienda online). En la siguiente tabla tienes las siete operaciones que un servidor RESTful puede realizar con ese recurso, es decir, con los productos de la base de datos. También te indico qué significa cada operación y un ejemplo típico de la URL que permitirá el acceso a través de https. |Operación|Significado|Verbo|URL típica|---|---|---|---|index|Listar todos los producto|GET|https://servidor/producto/|show|Mostrar un producto|GET|https://servidor/producto/id|create|Mostrar formulario de creación de un producto|GET|https://servidor/producto/create|store|Crear un producto con los datos procedentes de un formulario|POST|https://servidor/producto/store|edit|Mostrar el formulario de edición de un producto|GET|https://servidor/producto/edit/id|update|Actualizar el producto con los datos procedentes del formulario|PUT|https://servidor/producto/update/id|destroy|Eliminar un producto|DESTROY|https://servidor/producto/destroy/id| (Las operaciones *create* y *edit* podrían no estar disponibles en algunas APIs RESTful, cuando estas están diseñadas para que las usen otras aplicaciones y no seres humanos). Soy consciente de que esta tabla necesita algunas explicaciones adicionales, así que vamos a ello. En primer lugar, ¿qué es eso de los *verbos* que figura en cada petición? ### 6.3.3. Los verbos http: GET, POST, PUT y DESTROY El protocolo http define dos tipos de petición al servidor, GET y POST. El estándar REST aumenta estos tipos en otros dos, PUT (o PATCH, en algunas implementaciones) y DESTROY: * **GET** se utiliza para solicitar datos al servidor. Por ejemplo: \"Dame toda la información de un producto\". * **POST** se utiliza para enviar datos al servidor. Por ejemplo: \"Aquí tienes toda la información de un producto; anda, almacénalo en tu base de datos\". * **PUT/PATCH** se utiliza para solicitar al servidor la modificación de datos que ya existen. Por ejemplo: \"Este es el nuevo precio de un producto que ya estaba en tu base de datos. Tómalo y actualízalo\". * **DESTROY** se utiliza para solicitar la eliminación de datos en el servidor. Por ejemplo: \"Elimina este producto\". Por ese motivo, en algunas URLs de la tabla anterior enviamos un id como parte de la ruta. Ese id (que debe ser sustituido por un número real, es decir, por el id de un producto) indicará al servidor qué producto le estamos pidiendo que nos busque, modifique o elimine. Si ya has trabajado con HTML antes, seguro que conocías el significado de GET y POST, pero probablemente nunca habías oído hablar de PUT y DESTROY, ¿verdad? ### 6.3.4. El problema de PUT y DESTROY Cuando solicitamos una URL a un servidor sin indicar otra cosa, el protocolo http asumirá que se trata de una petición GET. Si en un formulario indicamos que el método de envío de los datos al servidor es POST, conseguiremos hacer una petición POST, y los datos que el usuario rellene en ese formulario se enviarán al servidor como parte del paquete http, en una zona especialmente dedicada a empaquetarlos: ```html ...cuerpo del formulario ``` Pero **con HTML5 *no hay manera de hacer una petición al servidor por PUT ni por DESTROY***. Esto se debe a que la implementación actual de http no contempla los verbos PUT ni DESTROY. Pero, en el estándar REST, estos verbos son fundamentales. Como a nosotros nos interesa construir servidores RESTful con acceso por http, es decir, vía web, aquí tenemos un grave problema. Mientras llega una nueva implementación de http y/o de HTML, **este problema tiene dos soluciones temporales**: * Sustituir las llamadas con PUT y DESTROY por llamadas POST convencionales. Esto hará que, en la práctica, nuestro servidor deje de ser RESTful, claro. * Parchear las llamadas con PUT y DESTROY mediante un campo oculto (de tipo *hidden*) en el formulario. Esta es la forma en la que se realizan las implementaciones RESTful vía web en la actualidad. Tienes un ejemplo en este formulario: ```html ...cuerpo del formulario... ``` ### 6.3.5. REST y JSON REST y JSON tienen una relación especial: todas las APIs RESTful devolverán sus datos formateados en JSON, por lo que, si vas a construir un servidor RESTful, harías bien en devolver todos tus datos en ese formato. Entiéndeme: si a tu servidor le llega una petición de tipo GET a través de esta ruta: https://servidor/producto/18, no hay nada que te impida devolver los datos del producto 18 formateados en XML, por ejemplo, pero tienes que ser consciente de que tu servidor habrá dejado de ser RESTful. Devolver un producto (o lo que sea) formateado en JSON mediante PHP resulta tan sencillo como hacer esto: ```php $producto = modelo-de-productos::get($id); // Obtenemos los datos del producto $id pidiéndoselos a nuestro modelo echo json_encode($producto); ``` ### 6.3.6. REST vs SOAP **SOAP es más flexible que REST**: permite definir nuevas operaciones sobre los recursos, mientras que REST está limitado a las 7 operaciones predefinidas. **REST es mucho más sencillo de usar e implementar que SOAP**: las operaciones son bien conocidas y no es necesario describirlas (WSDL) ni publicarlas de ningún modo. No hay que estudiarse ninguna API ni pelearse con estructuras de datos desconocidas, puesto que todo el intercambio de información se hace con JSON. Por todo ello, para la mayor parte de las aplicaciones REST es más que suficiente, y de ahí su mayor implantación en la actualidad. ### 6.3.7. Algunos trucos para implementar un servidor RESTful Para implementar un servidor RESTful, basta con: * Crear una arquitectura MVC para los recursos/datos que deseemos servir. Con Laravel, esto se puede conseguir con el comando: ``` $ php artisan make:controller --resource ``` * En lugar de mostrar los recursos en una vista, los mostraremos mediante JSON con un sencillo echo (recuerda que esa salida la recibirá el cliente, no un ser humano) Si estamos trabajando con Laravel, en lugar de echo usaremos return al final de cada método del controlador. Laravel se encargará de enviar ese valor devuelto al cliente. * Es importante respetar los nombres de las peticiones HTTP, así como los verbos (GET, POST, PUT y DESTROY), puesto que serán los que el cliente utilice. ",
    "url": "/servicios-web/",
    "relUrl": "/servicios-web/"
  },"23": {
    "doc": "7 Ajax",
    "title": "7 Ajax",
    "content": "# 7. Ajax {: .no_toc } - TOC {:toc} ## 7.1. Un poco de introducción al asunto ## 7.1.1. ¿Qué es Ajax? **Ajax** significa **Asynchronous Javascript And XML**. Qué bien, ¿no? ¿Y eso qué quiere decir? Ajax es una tecnología javascript para lanzar y recibir las peticiones al servidor en segundo plano. La página sigue funcionando con normalidad mientras la petición al servidor se resuelve: el usuario puede interactuar con ella y la página responde y no se queda *congelada* a la espera de que el servidor conteste. **Todo eso es lo que significa \"de forma asíncrona\"**. Esta forma de trabajar, que puede parecer una chorrada, se creó para que las páginas dieran la impresión de ser más ágiles de lo que en realidad eran (sobre todo en una época en la que las redes eran más lentas y los servidores podían tardar bastante en responder). En la actualidad, Ajax ha permitido algo que parecía impensable hace una década: que gran parte de la página se ejecute en el cliente y que se pidan al servidor solo los fragmentos de la página que necesitan ser actualizados. Ajax permite actualizar las páginas sin necesidad de recargarlas por completo, lo que mejora la usabilidad y velocidad de respuesta, y cambia radicalmente nuestra forma de programar una aplicación web. ### 7.1.2. Ajax no sirve, en realidad, para nada Esa es la pura verdad. Puedes programar una aplicación web completa, compleja y profesional sin hacer una sola petición Ajax. Pero Ajax mejora el rendimiento y la experiencia del usuario. Puedes sustituir unas pocas peticiones convencionales por peticiones Ajax sin cambiar demasiado en tu aplicación. Por ejemplo, para borrar un recurso, puedes lanzar la petición DESTROY por Ajax y actualizar tu vista para eliminar el recurso del documento HTML cuando el servidor responda. Esto es fácil de hacer. Y muy recomendable. Te aconsejo empezar a trastear con Ajax de este modo. ### 7.1.3. Y, sin embargo, Ajax ha cambiado la forma en la que desarrollamos aplicaciones web Como algo que, en realidad, no sirve para nada ha logrado cambiar la forma en la que desarrollamos aplicaciones web puede parecer un misterio a simple vista, pero existe una razón muy simple para ello: La mayoría de las aplicaciones web se pasan todo el tiempo haciendo lo mismo: accediendo a recursos de una base de datos para consultarlos, crearlos, modificarlos o borrarlos, todo ello mediante un interfaces de usuario básicamente semejantes. Es decir, el interfaz de usuario para crear, modificar y borrar productos de una base de datos es prácticamente el mismo que el que se usa para crear, modificar y borrar proveedores, por decir algo. Así que alguien se preguntó: ¿por qué estamos programando todo el tiempo lo mismo? Ajax nos permite hacer algo muy ingenioso para evitar este engorro: diseñar un interfaz de usuario genérico y vacío, solo compuesto por contenedores preparados para nutrirse de datos del servidor. Por ejemplo, podemos diseñar un típico interfaz de usuario HTML que nos muestre una lista de recursos (productos, proveedores, o lo que sea) junto con los botones de \"Update\" y \"Delete\", además de un botón de \"Add new\". Pero ese interfaz estará vacío, y mediante Ajax lo cargaremos con productos, con proveedores o con lo que necesitemos. Crearemos el interfaz una vez y lo podemos reutilizar miles de veces, para todo tipo de recursos. Este tipo de aplicaciones, también llamadas **SPA (Single-page applications)**, necesitan una arquitectura algo distinta de la que usamos en las aplicaciones web tradicionales, además de una librería en el lado del cliente para ayudarnos en la creación de contenedores genéricos (librerías como **Angular**, **React** o **Vue.js**). Aunque excede a nuestros propósitos profundizar en estas librerías, hemos visto algunos fundamentos sobre el uso de Vue.js con Laravel en el capítulo dedicado a Laravel. Consútalo si quieres profundizar en esta forma de uso masivo de Ajax. En lo que sigue de este capítulo, utilizaremos Ajax de forma puntual en el entorno de una aplicación web convencional con arquitectura MVC. ## 7.2. Cómo enviar peticiones Ajax al servidor ### 7.2.1. Peticiones sin datos al servidor La forma más sencilla (y primitiva) de usar Ajax es lanzar una petición asíncrona al servidor sin que el usuario de la web se percate de ello (porque se hará en segundo plano). El servidor no sabrá si la petición se lanzó en primer o en segundo plano y, en realidad, no le importa: él se limitará a atender la petición. Para lanzar una petición mediante Ajax usando JavaScript tradicional (luego veremos cómo hacerlo con jQuery, que simplifica bastante el proceso), necesitamos crear un objeto de tipo XMLHttpRequest. Este objeto nos permitirá controlar todo el proceso de envío de la petición, recepción de la posible respuesta y control de los errores que hayan podido ocurrir. Observa detenidamente este fragmento de código JavaScript: ```javascript peticion_http = new XMLHttpRequest(); peticion_http.onreadystatechange = procesa_respuesta; peticion_http.open('GET', 'http://servidor/recurso'); peticion_http.send(null); function procesa_respuesta() { if(peticion_http.readyState == 4) { if(peticion_http.status == 200) { alert(peticion_http.responseText); } } } ``` En las cuatro primeras líneas se crea el objeto de tipo XMLHttpRequest y luego se hacen tres cosas clave con él: 1. Se le indica qué función se debe ejecutar cuando el servidor responda. Recuerda que esta función se ejecutará también en segundo plano, sin que el usuario de la página se percate de que está sucediendo algo. 2. Se le indica qué recurso del servidor se quiere invocar (típicamente, una URL). Para ello se usa el método open(). Ahí también se indica el método de envío de datos al servidor (GET o POST), incluso si no se envían datos al servidor en absoluto, como en este ejemplo. 3. Por último, se lanza la petición al servidor con el método send(). El argumento \"null\" debe sustituirse por los datos que se envían al servidor mediante GET en caso de que los hubiera. Eso deja lista la petición. JavaScript permanecerá a la escucha en segundo plano hasta que el servidor responda. Cuando lo haga, se ejecutará la función procesa_respuesta(). En esa función se hacen tres cosas muy importantes: 1. Se comprueba si el estado de la petición (readyState) es 4. Eso significa que el servidor ha terminado de procesarla. La petición pasa por varios estados hasta completarse, y el servidor informa de todos ellos. Es decir, la función procesa_respuesta() se ejecuta al menos una vez para cada uno de estos estados: * readyState == 1 -> OPENED: Se acaba de abrir la comunicación con el servidor. Es decir, se acaba de ejecutar open(). * readyState == 2 -> HEADERS_RECEIVED: Se acaba de enviar la petición al servidor. Es decir, se acaba de ejecutar send(). * readyState == 3 -> LOADING: Se está recibiendo la respuesta del servidor. * readyState == 4 -> DONE: Se ha recibido la respuesta del servidor. Por eso es necesario comprobar que readyState == 4 antes de hacer ninguna otra cosa. 2. Se comprueba que la respuesta del servidor es 200. Esto, según el protocolo http, significa que no hay errores en la página. El servidor puede responder con otros códigos, como 404 (recurso no encontrado) o 403 (prohibido el acceso a ese recurso). Puedes encontrar en miles de sitios de internet todas las posibles respuestas de una petición http. 3. Si readyState == 4 y status == 200, significa que todo ha ido bien y el servidor ha respondido. Ya podemos hacer lo que sea que tengamos que hacer con esa respuesta. En este ejemplo, nos hemos limitado a mostrar esa respuesta en un alert. Observa en el ejemplo como la respuesta del servidor se recibe en forma de String en el atributo responseText. ### 7.2.2. Peticiones con datos al servidor (GET) Si has entendido el ejemplo anterior, este te va a costar muy poco. Simplemente, vamos a enviar algunos datos al servidor por GET, exactament igual que lo haríamos si los enviáramos mediante un formulario. De hecho, el servidor no notará la diferencia. El código para lograrlo es este: ```javascript var cp = document.getElementById(\"codigo_postal\"); var telefono = document.getElementById(\"telefono\"); query_string = \"&codigo_postal=\" + encodeURIComponent(cp.value) + \"&telefono=\" + encodeURIComponent(telefono.value); peticion_http = new XMLHttpRequest(); peticion_http.onreadystatechange = procesa_respuesta; peticion_http.open('GET', 'http://servidor/scrip.php'); peticion_http.send(query_string); function procesa_respuesta() { .... } ``` No ponemos la función procesa_respuesta() porque es la misma de antes. En cambio, sí que hay algunos añadidos en el código de preparación de la solicitud, ¿verdad? Para empezar, hemos cogido un par de datos de un formulario: el código postal y el teléfono (puede ser un formulario de alta de usario o algo por el estilo: recuerda que esto solo es un ejemplo). Luego hemos creado una variable llamada queryString que contiene el string con los datos que queremos enviar al servidor por GET. Como los datos por GET se codifican en la URL, es necesario usar el formato de la URL (separando las variables con el carácter &) y codificar cualquier carácter especial (con la función encodeURIComponente() de Javascript). Por último, en el momento de hacer send(), hemos agregado nuestra query_string para que sea enviada al servidor. Una vez allí, PHP la podrá procesar como cualquier otra string enviada por GET, es decir, usando las variables superglobales $_GET o $_REQUEST. ### 7.2.3. Peticiones con datos al servidor (POST) Si, en lugar de enviar datos al servidor por GET, preferimos enviarlos por POST, la técnica es muy similar a la anterior, con un par de variaciones: 1. Debemos indicar \"POST\" en lugar de \"GET\" en el método open(), como es lógico. 2. Debemos indicarle a Ajax que el paquete http llevará variables POST en su cabecera. Para eso se usa el método setRequestHeader(). Lo puedes ver en el siguiente ejemplo: ```javascript var cp = document.getElementById(\"codigo_postal\"); var telefono = document.getElementById(\"telefono\"); query_string = \"&codigo_postal=\" + encodeURIComponent(cp.value) + \"&telefono=\" + encodeURIComponent(telefono.value); peticion_http = new XMLHttpRequest(); peticion_http.onreadystatechange = procesa_respuesta; peticion_http.open(\"POST\", \"http://servidor/script.php\"); peticion_http.setRequestHeader(\"Content-Type\", \"application/x-www-form-urlencoded\"); peticion_http.send(query_string); function procesa_respuesta() { .... } ``` ### 7.2.4. Peticiones con datos al servidor (XML) Todo esto está muy bien si lo que enviamos al servidor son un par de datos sueltos, como el código postal y el teléfono en los ejemplos anteriores. Pero ¿y si tenemos que enviar mucha información? Digamos, por ejemplo, un array de códigos postales y teléfonos. En ese caso, usar GET se hace inviable (por la limitación de caracteres), así que recurriremos a POST y empaquetaremos nuestros datos en un string XML o JSON. En este ejemplo, vamos a usar XML: ```javascript var cp = document.getElementById(\"codigo_postal\"); var telefono = document.getElementById(\"telefono\"); xml = \"\" + \"\" + cp + \" + + telefono + + \"\"; peticion_http = new XMLHttpRequest(); peticion_http.onreadystatechange = procesa_respuesta; peticion_http.open(\"POST\", \"http://servidor/script.php\"); peticion_http.setRequestHeader(\"Content-Type\", \"application/x-www-form-urlencoded\"); peticion_http.send(xml); function procesa_respuesta() { .... } ``` ## 7.3. Cómo recibir la respuesta del servidor En todos los ejemplos anteriores, el servidor conestaba con un simple texto que mostrábamos por medio de un alert() de Javascript. Ni siquiera nos preocupamos por el contenido de ese texto. Podría ser cualquier cosa: algo como \"petición procesada\", \"usuario borrado\" o cosas por el estilo. Pero ¿y si el servidor tiene que contestar algo complejo? Por ejemplo, una tabla completa. En ese caso, como es lógico, necesitamos recurrir a XML o JSON para empaquetar todos los datos de la respuesta y enviarlos desde el servidor hacia el cliente. Vamos a ver un par de ejemplo, uno resuelto con XML y otro con JSON. En ninguno de los dos casos mostraremos cómo lo hace el servidor para crear los datos: supondremos que eso ya sabes hacerlo, puesto que se trata de PHP. Nos centraremos en cómo procesa Ajax, es decir, Javascript, esa respuesta. ### 7.3.1. Recepción de datos XML En este ejemplo, el servidor nos devuelve un String XML consistente en un array de códigos postales y teléfonos (de clientes, de usuarios, de lo que sea. Recuerda -otra vez- que solo es un ejemplo). Observa cómo esa respuesta se accede por medio de responseXML (no responseText, como hasta ahora). A partir de ahí, Javascript puede usar esa respuesta como un objeto XML cualquiera: puede buscar hijos de un nodo, puede buscar nodos por su tag, etc. En el ejemplo, nos limitamos a recuperar el código postal y el teléfono del primer elemento del array y a mostrarlo en el documento preexistente, en una capa con el ID \"respuesta\". ```javascript function procesaRespuesta() { if(peticion_http.readyState == 4) { if(peticion_http.status == 200) { var xml = peticion_http.responseXML; var datos = xml.getElementsByTagName(\"datos\")[0]; var telefono = datos.getElementsByTagName(\"telefono\")[0]. firstChild.nodeValue; var cp = datos.getElementsByTagName(\"cp\")[0]. firstChild.nodeValue; document.getElementById(\"respuesta\").innerHTML = \"Codigo postal = \" + codigo_postal + \"\" + \"Telefono = \" + telefono; } } } ``` ### 7.3.2. Recepción de datos JSON Javascript prefiere JSON a XML, es no es un secreto. Casi todos los programadores lo prefieren, en realidad. Así que veamos cómo hacer lo mismo que antes, pero ahora con JSON. La respuesta JSON llegará en responseText, no en responseXML. Eso significa que Javascript la recibe como un String cualquiera. Luego, con la función eval() de Javascript, podemos convertir ese String en un objeto complejo y, a partir de ahí, usar ese objeto para acceder a todos sus elementos. En el ejemplo, como antes, solo accederemos al primer código postal y al primer teléfono y los mostraremos en la capa \"respuesta\" de nuestro documento. ```javascript function procesaRespuesta() { if(http_request.readyState == 4) { if(http_request.status == 200) { var json = http_request.responseText; var objeto_json = eval(\"(\"+json+\")\"); var telefono = objeto_json.datos.telefono; var codigo_postal = objeto_json.datos.cp; document.getElementById(\"respuesta\").innerHTML = \"Codigo postal = \" + codigo_postal + \"\" + \"Telefono = \" + telefono; } } } ``` ## 7.4. Ajax y jQuery El uso de jQuery facilita enormemente la programación de llamadas Ajax al servidor. El decir: se puede manejar Ajax al 100% sin recurrir a jQuery, pero con jQuery es más fácil. jQuery ofrece varias funciones para hacer llamadas Ajax: * $.ajax() → La más configurable pero también la más compleja. * $.get() → Para lanzar peticiones GET sencillas. * $.post() → Para lanzar peticiones POST sencillas * $.load() → Para lanzar peticiones GET y cargar la respuesta en una capa. Vamos a verlas una por una. ### 7.4.1. Función $.ajax() Tiene esta sintaxis: ```javascript $.ajax({ url: '/ruta/hasta/script.php', type: 'POST', data: 'parametro1=valor1&parametro2=valor2', contentType: 'tipo de contenido que enviamos al servidor', dataType: 'tipo de contenido con el que responde el servidor', success: function(data) { // Aquí el código para procesar la respuesta }, fail: function() { // Aquí el código para procesar el error } }); ``` Bueno, en realidad $.ajax() admite más argumentos aparte de los que te muestro aquí arriba, pero estos son los principales. Si quieres verlos todos, te sugiero que te des una vuelta por la documentación oficial de jQuery, que por cierto es fantásticamente buena. Observa como, en una sola invocación, conseguimos hacerlo todo: indicar la URL donde se dirigirá la petición, el tipo de envío de datos (GET o POST), los datos que enviamos al servidor, el tipo de datos que recibiremos como respuesta, el nombre de la función que procesará la respuesta e, incluso, el nombre de la función que procesará el error, en caso de que el servidor responda con un código de error. En ***contentType*** puedes indicar el tipo de datos que vas a enviar al servidor. Por defecto, se supone que es 'application/x-www-form-urlencoded; charset=UTF-8', pero te puede interesar cambiarlo por 'multipart/form-data', por ejemplo, si vas a enviar un archivo binario (como una imagen). En ***dataType*** puedes indicar el tipo de datos que se espera que te devuelva el servidor. Por defecto será 'text', es decir, texto plano, pero puedes indicar cosas muy variadas, como 'xml', 'json', 'html' o incluso 'script' si el servidor te va a devolver un fragmento de código JavaScript. Esto ayuda a su procesamiento posterior en la sección ***success***. Por último, en la sección ***success*** puedes acceder a los datos devueltos por el servidor a través de la variable ***data***, que tendrá el formato correspondiente al tipo de datos que hayas indicado en ***dataType***. Por ejemplo, si en ***dataType*** especificaste que el servidor iba a responder con un objeto json, jQuery tratará de convertir la respuesta a un objeto asumiendo el formato json y te la dejará preparada y lista para usar en el parámetro ***data***. Aquí vemos un ejemplo de uso de $.ajax(): ```javascript $(document).ready(function () { $.ajax({ type: \"POST\", url: \"mi-script.php\", data: {email: $(\"#email\").val()}, success: function (data) { $(\"#message\").html(data); }, error: function (req, status, error) { alert(req + \" \" + status + \" \" + error); } }); }); ``` Si es la primera vez que ves código jQuery, esto te sonará tanto como el chino mandarín. Pero no te agobies, que en realidad es muy fácil. Te lo explico en cuatro frases. La primera línea, ***$(document).ready()***, sirve para indicar al navegador que no debe ejecutar la función que haya ahí dentro hasta que el documento no se haya cargado por completo y el árbol DOM desplegado en la memoria del cliente. Solo entonces se lanzará el resto del código. Es algo muy común en el código jQuery. Después viene la llamada Ajax, con varios de los atributos que mencionábamos antes. Fíjate que no hemos usado ni ***dataType*** ni ***contentType***, por lo que se asumirán los valores por defecto. En la sección ***data*** se especifican los datos que se envían a mi-script.php. Solo enviamos un email, pero podríamos enviarle más cosas. Observa que lo hemos formateado en json. Es lo más habitual. En la sección ***success*** hemos colocado directamente el código de la función que se lanzará al recibir la respuesta del servidor. Esa forma de inyectar funciones sin nombre directamente es muy habitual de jQuery. La función se limita a tomar la respuesta del servidor y mostrarla en una capa con el ID \"#message\", pero, por supuesto, podría hacer cualquier otra cosa más compleja. En la sección ***error***, por último, lanzamos un mensaje de error mediante un alert(), que solo saltará si ocurre algún error durante la petición Ajax. Fíjate en que esa función tiene tres parámetros (optativos) que utilizamos para informar al usuario con más detalle de qué error se ha producido. ### 7.4.2. Funciones $.get() y $.post() En muchas ocasiones, no necesitamos usar ni la mínima parte de las posibilidades de la función $.ajax(). Cuando tenemos que hacer una llamada sencillita por Ajax al servidor y no queremos complicarnos la vida, puede ser más útil y rápido recurrir a las funciones $.get() y $.post(). Como su propio nombre indica, $.get() lanza una petición Ajax mediante GET y $.post() hace lo mismo, pero con POST. Su sintaxis es esta: ```javascript $.get(url, datos, funcion_manejadora); $.post(url, datos, funcion_manejadora); ``` Aquí tienes un ejemplo en el que llamamos por Ajax a ***mi-script.php***, enviándole mediante GET un nick de usuario. El servidor responderá con un texto plano que contendrá el nombre de ese usuario y lo mostrará mediante un alert(): ```javascript $.get('mi-script.php', { user: 'juanperez03' }, function(username) { alert('Hola, ' + username); } ); ``` ### 7.4.3. Función $.load() Un caso particularmente simple (y habitual) de uso de Ajax es aquel en el que lanzamos una petición al servidor para rellenar una capa de nuestra página con la información que el servidor nos devuelve. Por ejemplo, imagina que tenemos un formulario de registro de usuarios y, en el campo del nick del usuario, deseamos comprobar si ese nick ya está en uso en la base de datos. Mediante Ajax, se puede hacer de forma dinámica y atractiva capturando el evento onblur en del campo nick y lanzando en ese momento una petición Ajax al servidor para que haga la consulta a la base de datos. Si el usuario ya existe, el servidor puede responder con un texto el tipo \"Ese usuario ya existe\". En caso contrario, puede responder con \"Ese nick está disponible\" o algo así. En ambos casos, ese String puede mostrarse en una capa junto al cuadro de texto, una capa que, hasta ese momento, habrá estado vacía. Este escenario tan habitual se puede resolver con $.ajax(), con $.get() o con $.post(), pero existe una función jQuery específica para ello. Se llama $.load() y tiene esta sintaxis: ```javascript $('#info').load('mi-script.php'); ``` Simplemente, se ejecuta ***mi-script.php*** en el servidor y se carga el texto de respuesta en la capa #info. Sin funcion manejadora ni historias. Más fácil, imposible, ¿verdad? ## 7.5. Ajax y Laravel Al trabajar con Laravel, estamos acostumbrados a que cada método del controlador termine devolviendo una vista completa (retur view...). ¿Pero qué pasa si hacemos una petición Ajax a una aplicación web escrita con Laravel en el lado del servidor? Laravel puede continuar devolviendo una vista completa, pero es no suele ser lo que Ajax espera recibir como respuesta. Ajax espera respuestas cortas y concisas: algo como 'true' o 'false', o un número, o un String o, como mucho, una estructura de datos más compleja formateada en XML o JSON. Pero no una página web completa con su cabecera, su cuerpo y toda la parafernalia. Y eso es precisamente lo que devuelve Laravel al rederizar cualquier vista. Así que, ¿cómo lo hacemos? ### 7.5.1. Paso 1. Crear un controlador para las peticiones Ajax Esto no es imprescindible, pero sí suele ser una práctica habitual: reunir todas las peticiones Ajax en un único controlador. Ten en cuenta que, para el servidor, no hay diferencia entre una petición Ajax y una petición normal. El servidor recibe su petición por http o https y la atiende, ejecutando en enrutador, el controlador y todo lo que venga detrás, y produciendo una salida como resultado que se envía de vuelta al cliente. Punto. Así que suele ser buena idea separar las peticiones Ajax de las peticiones normales mediante la diferenciación de controladores, salvo que tengas una muy biena razón para no hacerlo. Por lo tanto, crearemos un controlador AjaxController y añadiremos a nuestro enrutador (/routes/web.php) las líneas correspondientes, como esta: ```php Route::post('miJqueryAjax','AjaxController@miMetodo'); ``` ### 7.5.2. Paso 2. Crear los métodos del controlador Lo siguiente sería crear los métodos que necesitemos en AjaxController (o, si hemos decidido no crear un controlador específico para Ajax, crear los métodos en los controladores que corresponda). Solo hay que tener una cosa clara: estos métodos que responderán a las peticiones Ajax **no pueden terminar con una vista**. Imagina un método que reponderá a una petición Ajax y que solo deba responder con un String, cuyo valor pueda ser \"Ese usuario ya existe\" o \"Usuario disponible\". Lo haríamos así: ```php class AjaxController extends Controller { public function miMetodo() { ...aquí va mi código... if ($lo_que_sea) $result = \"Ese usuario ya existe\"; else $result = \"Usuario disponible\"; return $result; } } ``` Imagina ahora que queremos devolver algo más complicado, como un array o una colección de datos. No pasa nada: los formateamos como json y los enviamos de regreso al cliente, así: ```php class AjaxController extends Controller { public function miMetodo() { ...aquí va mi código... return response()->json($mi_variable_compleja); } } ``` Por supuesto, esta última manera también te funcionará para devolver un simple String, un booleano o un entero. Es la forma más conveniente de terminar un método de un controlador que va a ser invocado por Ajax y no mediante una petición normal al servidor. Ten en cuenta que: * La salida de una petición Ajax suele ser JSON, pero podría ser otra cosa: HTML, XML o simple texto plano. * Lo repetimos una vez más: para responder a una petición Ajax no se debe renderizar una vista (¡salvo que tengas una muy buena excusa para hacerlo!), sino que basta con un return response(). ### 7.5.3. Paso 3. Agregar el token CSRF a las peticiones Como vimos al estudiar Laravel, las peticiones enviadas por POST con Laravel deben llevar el token CSRF o serán rechazadas. Esto se hacía para prevenir cierto tipo de ataques frecuentes a través de formularios HTML. Los detalles no son importantes aquí y, en todo caso, puedes repasar el capítulo sobre Laravel o sobre Sesiones, Cookies y Seguridad para revisar el concepto. Lo importante ahora es esto: cuando lances una petición POST mediante Ajax, Laravel la rechazará porque no llevará el token CSRF. Recuerda que el servidor no tiene ni idea de si la petición llega desde Ajax o no: para él, se trata de datos que provienen de un formulario HTML, y si no lleva ese token, automáticamente se convierte en un formulario sospechoso. Así que, si tienes Laravel en el lado del servidor, necesitas agregar el token CSRF a las peticiones por POST, así: ```javascript $.ajax({ method: \"POST\", url: \"mi-url\", data: { \"_token\": \"{{ csrf_token() }}\" }, ...etc... }); ``` Por supuesto, puedes añadir más ***data*** a tu petición: tantos datos como necesites enviar al servidor. Como esto puede ser un poco engorroso, hay una forma de agregar automáticamente el token CSRF a **todas** las peticiones. Basta con escribir esto en el header de nuestro layout: ```html ``` A partir de ahora, podremos hacer las peticiones Ajax normalmente, porque el token CSRF se añadirá él solito a cada petición Ajax. ",
    "url": "/ajax/",
    "relUrl": "/ajax/"
  },"24": {
    "doc": "8 Otras tecnologías",
    "title": "8 Otras tecnologías",
    "content": "# 8. Otras tecnologías En esta sección vamos a hacer un repaso rápido a otras tecnologías para desarrollo web del lado del servidor diferentes de Apache (o similar) y PHP. Será solo una pasada superficial, para que te hagas una idea de cómo huelen y a qué saben estas tecnologías y veas que, en lo sustancial, no difieren mucho unas de otras, al menos desde el punto de vista del programador. Todas las diferencias se centran en los detalles, no en el meollo del asunto. Esto quiere decir que, si te manejas bien con PHP, podrás pasarte a cualquiera de estos lenguajes con muy poco esfuerzo y en solo unos días. ",
    "url": "/otras-tecnologias/",
    "relUrl": "/otras-tecnologias/"
  },"25": {
    "doc": "5.1 Frameworks PHP MVC",
    "title": "5.1 Frameworks PHP MVC",
    "content": "## 5.1. ¿Qué es un framework? Un framework es un conjunto estandarizado de prácticas de programación para resolver un problema concreto. El framework proporciona una serie de clases, librerías y otros componentes para facilitar el desarrollo ágil, seguro y escalable de nuevas aplicaciones. Un framework MVC PHP es un tipo de framework concreto, destinado a servir de base para desarrollar aplicaciones en PHP con arquitectura MVC. ### 5.1.1. ¿Realmente necesito un framework para desarrollar una aplicación web? No, pero en ciertas ocasiones es muy conveniente. Hay programadores pro-frameworks y anti-frameworks. Los programadores anti-frameworks realmente acaban desarrollando su propio framework después de varias aplicaciones MVC. Para decidir si necesitas un framework o no, tienes que conocer antes cómo funcionan y qué ventajas e inconvenientes presentan. Usar un framework tiene ciertas ventajas, como: * Reutilización del trabajo ya hecho (no reinventar la rueda). * Extensa documentación. * Separación en capas. * Seguimiento de buenas prácticas de programación. * Escalabilidad y mantenimiento. * Desarrollo más rápido. Pero también tiene algunos inconvenientes: * A veces pueden limitar el desarrollo. * Curva de aprendizaje costosa (más en unos frameworks que en otros) * Puede llegar a implicar más trabajo, dependiendo del proyecto. * Preferencias personales: algunos programadores solo se sienten cómodos si todo el código es suyo. * Ocultan gran parte del funcionamiento de la aplicación: no son aptos para aprender a programar. En resumen: la idea es que, al usar un framework, solo te centras en desarrollar lo importante. El resto (lo que ya estaba desarrollado) no te quita tiempo. ### 5.1.2. ¿Qué framework escoger? Existen multitud de frameworks MVC PHP. Estos son algunos de gran implantación actual: * Symfony: el más extendido desde hace alos. * Laravel: el que tiene un crecimiento más rápido. * CodeIgniter: el más sencillo, aunque su implantación en la industria el menor. * Otros framworks MVC PHP importantes son Zend Framework, Yii o CakePHP. Puedes pasar el resto de tu vida leyendo en foros y en blogs, descargando e instalando varios frameworks para desecharlos a los dos días, esperando a que salga una nueva versión o un framework nuevo... No hay respuesta a la pregunta: ¿qué framework es mejor? Además, el framework por sí sólo puede no ser suficiente para un desarrollo completo, y probablemente harán falta otros componentes como: * Librerías del lado del servidor (pear, pChart, doctrine...) * Librerías del lado del cliente (jQuery, vue.js, bootstrap...) ",
    "url": "/laravel/1",
    "relUrl": "/laravel/1"
  },"26": {
    "doc": "5.10 Migraciones",
    "title": "5.10 Migraciones",
    "content": "## 5.10. Migraciones ### 5.10.1. ¿Qué son las migraciones? Las migraciones constituyen una especie de control de versiones para la base de datos de la aplicación. Permiten crear y modificar tablas de la BD con independencia del SGBD que estemos usando. Con las migraciones no solo podrás reconstruir la base de datos en menos de lo que tarda en decirse \"Von Neumann\" (algo muy práctico cuando estás en fase de desarrollo), sino que podrás parchear la base de datos de una aplicación en producción en un tiempo record y con riesgo cero. Solo el que ha tenido que parchear la base de datos de una aplicación en producción antes de la existencia de las migraciones sabe la tranquilidad de espíritu que esto produce y la cantidad de problemas embarazosos que te quita de encima. Antes de empezar, recuerda que, para que cualquier operación sobre la base de datos funcione, debes tener bien configurados estas variables de entorno del archivo .env de Laravel: ``` DB_HOST=localhost DB_DATABASE=mi-base-de-datos DB_USERNAME=mi-usuario-de-BD DB_PASSWORD=mi-password-de-BD ``` ### 5.10.2. Crear tablas mediante las migraciones Si, por ejemplo, quisiéramos crear las migraciones de una tabla llamada Clients, los pasos a seguir serían: **Paso 1**: Inicializar el sistema de migraciones de Laravel (si ya lo hemos hecho antes, nos dará un error al intentar hacerlo otra vez): ``` $ php artisan migrate:install ``` **Paso 2**: Crear la migración para la tabla Clients: ``` $ php artisan make:migration create_clients_table ``` Esto generará un fichero en /database/migrations cuyo nombre contendrá un timestamp. Algo como /database/migrations/20201226072434createclientstable.php Si editas ese fichero, verás dos métodos: * up() → se ejecuta cuando se lanza la migración. * down() → se ejecuta cuando se cancela la migración. **Paso 3**: Editar el fichero /database/migrations/createclientstable.php: En el método up() tienes que indicar las columnas que tendrá la tabla. Por ejemplo: ```php public function up() { Schema::create('clients', function (Blueprint $table) { $table->bigIncrements('id')->index();// UNSIGNED BIGINT AUTOINC. $table->string('name',75)->unique(); // VARCHAR $table->text('address')->nullable(); // TEXT $table->integer('level'); // INT $table->date('brith_date'); // DATE // La siguiente línea crea campos created_at y updated_at. Si la borras // esos campos no existirán en tu tabla $table->timestamps(); }); } public function down() { Schema::drop('clients'); } ``` **Paso 4**: Lanzar las migraciones. ``` $ php artisan migrate ``` Esto creará las tablas que no se hayan creado aún. Es decir, si una migración ya se ha lanzado con anterioridad, no se vuelve a ejecutar para no perder los datos que pudieran existir en esas tablas. **Paso 5**: Revertir las migraciones (si es necesario) Si necesitas revertir la creación de todas las tablas: ``` $ php artisan migrate:rollback ``` Para revertir solo el último paso en la creación de tablas: ``` $ php artisan migrate:rollback --step=1 ``` Para dejar la BD a su estado original (vacía): ``` $ php artisan migrate:reset ``` ¡Cuidado! Estas acciones son destructivas. Pero, por supuesto, hay una forma de modificar una tabla sin borrarla y volver a crearla. ### 5.10.3. Modificar tablas mediante migraciones Si necesitas modificar una tabla que ya existe (por ejemplo, para añadir o eliminar campos), tienes dos opciones: 1. Modificar la migración original (en la que se crea la tabla) para añadir o eliminar el campo afectado. Esto te obligará a lanzar la migración de nuevo y, por lo tanto, la tabla se reconstruirá y todos los datos que pudiera contener se perderán. 2. Crear una nueva migración en la que únicamente se haga la modificación de la tabla, sin tocar el resto. Esto respetará los datos que la tabla ya pudiera contener. Como es lógico, la opción 2 será la que preferiremos si la aplicación ya está en producción y necesitamos modificar la estructura de la base de datos. En cambio, durante el desarrollo, puede ser más simple utilizar la opción 1. Supongamos que queremos añadir un campo \"email\" a la tabla \"Clients\" del apartado anterior. Si optas por la opción 2, es decir, por crear una nueva migración que se encargue de hacer esa modificación en la tabla sin alterar sus datos, la forma de proceder es la siguiente: **Paso 1**. Crear la migración: ``` $ php artisan make:migration add_email_to_clients --table=clients ``` (Nota: puedes asignar el nombre que quieras a las migraciones, pero Laravel aconseja utilizar las convenciones que ves en estos ejemplos para simplificarnos la vida) **Paso 2**: Editar la migración /database/migration/add_email_to_clients.php para añadir, en el método up(), el campo nuevo; y, en el método down(), especificaremos qué hay que hacer en caso de que se fuerce un rollback de esta migración: ```php public function up() { Schema::table('clients', function (Blueprint $table) { $table->string('email')->after('address'); }); } public function down() { Schema::table('clients', function (Blueprint $table) { $table->dropColumn('email'); }); } ``` ### 5.10.4. Otras operaciones en las migraciones Las migraciones pueden usarse para cualquier otra operación sobre la estructura de la base de datos, como: * Cambiar tipos de columnas. * Cambiar atributos de columnas (null, unique, default...) * Cambiar o asignar claves primarias y ajenas. Las migraciones construídas de este modo nos permitirán reproducir la base de datos en cualquier servidor o actualizarla en cualquier momento sobre una aplicación en producción sin necesidad de programar parches o exportar la BD a un archivo SQL para importarlo en otro servidor. Más info en: [https://laravel.com/docs/8.x/migrations](https://laravel.com/docs/8.x/migrations) ### 5.10.5. Seeding El seeding es una técnica adicional a la de las migraciones que permite cargar con datos las tablas de la base de datos. Es muy práctico en estos supuestos: * Si quieres tener un conjunto de datos de prueba en tu base de datos de desarrollo (esa que destrozas periódicamente cuando haces pruebas). Con un solo comando, tendrás la base de datos reconstruída como si no hubieras ejecutado un \"DELETE * FROM users\" sin querer. * Si necesitas cargar algunos datos mínimos en algunas tablas para que la aplicación, una vez desplegada en un servidor de producción, funcione (por ejemplo, para crear un usuario administrador en la tabla \"Users\" o para crear algunas entradas en una tabla \"Options\") Para crear un seeder (por ejemplo, para la tabla users), sigue estos pasos: **Paso 1**. Ejecuta el comando: ``` $ php artisan make:seeder UsersTableSeeder ``` **Paso 2**. Editar el seeder /database/seeds/UsersTableSeeder.php y añade algo como esto al método up() (por supuesto, modifica el código para adaptarlo a tu tabla y a tus datos): ```php public function run() { Users::truncate(); // Opativo: vacía la tabla antes de rellenarla DB::table('users')->insert([ 'name' => 'Stephen Falken', 'address' => ' Oregon 97, Goose Island', 'email' => 'sfalken@norad.com', 'brith_date' => '1932-09-03', ]); } ``` **Paso 3**. Ejecuta este comando para lanzar el seeder y que los datos se carguen en tu tabla: ``` $ php artisan db:seed --class=UsersTableSeeder ``` Esto cargará un solo registro en la tabla users. Si quieres más, solo tienes que crear nuevas líneas insert() en el método up(). ### 5.10.5. Automatizar el seeding Lanzar los seeders de uno en uno puede ser muy tedioso. Puedes lanzar varios seeders con un solo comando si haces lo siguiente: **Paso 1**. Edita el fichero /database/seeds/DatabaseSeeder.php **Paso 2**. Añade a la función run() una línea como esta por cada seeder que quiera ejecutar automáticamente: ```php $this->call(UsersTableSeeder::class); ``` **Paso 3**. ¡Y listo! Al ejecutar el comando db:seed de Artisan, sin indicar la clase, se lanzarán todos los seeders que hayas aladido a run(): ``` $ php artisan db:seed ``` ### 5.10.6. Lista de comandos superútiles para manejar migraciones ``` $ php artisan migrate → Lanza todas las migraciones. ``` ``` $ php artisan make:migration --create= → Crea una migración para la tabla indicada. ``` ``` $ php artisan make:migration --table= → Modifica una migración para la tabla indicada. ``` ``` $ php artisan migrate:rollback → Retrocede UN paso en todas las migraciones. ``` ``` $ php artisan migrate:rollback --step= → Retrocede N pasos en todas las migraciones. ``` ``` $ php artisan migrate:reset → Deshace todas las migraciones que se hayan ejecutado hasta ahora. ``` ``` $ php artisan migrate:refresh → Reset + migrate en un solo comando. ``` ``` $ php artisan migrate:refresh --seed → Reset + migrate + seed en un solo comando. ``` ``` $ php artisan migrate:fresh → Elimina todas las tablas y lanza todas las migraciones. ``` ``` $ php artisan migrate:fresh --seed → Elimina todas las tablas, lanza todas las migraciones y todos los seeders. ``` ",
    "url": "/laravel/10",
    "relUrl": "/laravel/10"
  },"27": {
    "doc": "5.11 Usando la BD con Eloquent",
    "title": "5.11 Usando la BD con Eloquent",
    "content": "## 5.11. Usando la BD con Eloquent ### 5.11.1. ¿Qué es Eloquent? Eloquent uno de los componentes de Laravel que permiten al desarrollador manipular los datos de la BD sin rebajarse a escribir sucio SQL. Eloquent es un ORM (Object-Relational Mapping), es decir, una librería que mapea los objetos de nuestra aplicación con una BD relacional. Sí, lo has entendido bien: podrás manejar los datos de tu base de datos como si fueran objetos de tu aplicación. Y, cuando los modifiques, borras o crees, se ejecutará el código SQL necesario (sin que tú te enteres) para traducir esas operaciones en sentencias para la base de datos. Te lo muestro con un ejemplo. Imagina que tenemos una tabla Articles(id, title, body). Con Eloquent, usar esa tabla desde un controlador es tan fácil como hacer algo así: ```php $art = Article::find('7'); // Buscamos un artículo por su id echo $art->title; // Accedemos a los campos de ese artículo $art->body = \"Texto del cuerpo\"; // Modificamos los campos del artículo $art->save(); // Guardamos la modificación en la BD ``` ### 5.11.2. Mola. ¿Cómo puedo usar Eloquent en mi aplicación? Tienes que crear un modelo. ¿Qué te creías? Pero con Artisan es así de fácil: ``` $ php artisan make:model ``` Por ejemplo: ``` $ php artisan make:model Article ``` El modelo se creará en /app/Article.php Nota: si creas el modelo con la opción -m, se creará atomáticamente su migración, lo cual resulta tremendamente práctico: ``` $ php artisan make:model Article -m ``` Ya tienes tu modelo. Si no puedes contener tu curiosidad insaciable y lo abres, verás un archivo bastante decepcionante con este aspecto: ```php ', 100)->get(); // Select con where Article::where('id', '>', 100)->take(10)->get(); // Select con where y take Article::max('id'); // Último id asignado ``` ### 5.11.5. Inserciones y borrados con Eloquent Podemos usar Eloquent para insertar un nuevo artículo desde nuestro controlador: ```php $art = new Article; $art->title = 'Los Chitauri invaden Nueva York'; $art->body = 'Bla, bla, bla'; $art->save(); ``` Si los datos del artículo vienen de un formulario, fíjate en lo alucinantemente fácil que es recoger todos esos datos, crear un objeto Article con ellos y guardar el artículo en la BD: ```php public function store(Request $request) { Article::create($request->all()); // Esto es una ASIGNACIÓN MASIVA de las que hablábamos más arriba!! return ; } ``` Ojo: solo los campos que hayas indicado como \"fillables\" en el modelo se podrán asignar al artículo de este modo. Mira el apartado 5.11.3 si no sabes de qué estamos hablando. Y, por supuesto, también podemos modificar y borrar artículos de la base de datos: ```php $art = Article::find(18); // MODIFICAR $art->body = 'Nuevo cuerpo'; $art->save(); $art = Article::find(13); // BORRAR $art->delete(); ``` ### 5.11.6. Lista de los métodos más útiles de Eloquent * all() → Recupera todos los registros de una tabla. * where(\"campo\", valor) → Aplica claúsula where. * orderBy(\"campo\", \"asc|desc\") → Aplica claúsula order by. * get() → Recupera registros seleccionados. Se suele usar con where y/o order by: * Ciudades::where(\"ciudad\", \"Madrid\")->orderBy(\"id\", \"asc\")->get(); * first() → Recupera el primer registro. * latest() → Recupera el último registro. * find(valor) → Busca registros con ese valor en el campo id. * findOrFail(valor) → Lanza un error 404 si no encuentra el registro. * count(), max(), min()… → Utiliza funciones de agregado de SQL. * save() → Inserta o actualiza registros. * update() → Actualiza registros. * delete() → Elimina registros. ### 5.11.7. Relaciones entre tablas con Eloquent Las relaciones entre tablas también se pueden manejar con Eloquent sin necesidad de andar con INNER JOIN y otros miembros de su nutrida familia. Aunque te parezca al principio que definir las relaciones entre tablas con Eloquent necesita mucho trabajo previo, te garantizo que después te alegrarás de haberlo hecho. Porque las relaciones, una vez definidas, se comportan como consultas y se puede operar con ellas como si lo fueran. En los siguientes ejemplos, vamos a suponer que tenemos estas tablas: * usuarios(id#, nombre, passwd) * emails(id#, email, usuario_id) → Relación 1:1 con usuarios * articulos(id#, titulo, texto, idUsuario) → Relación 1:N con usuarios * roles(id#, nombre) → Relación N:N con usuarios ATENCIÓN: en la tabla “artículos” hemos usado a propósito un nombre no estándar para la clave ajena. La convención de Laravel es usuario_id, como en la tabla “emails”. #### 5.11.7.1. Relaciones 1:1 (usuarios emails) Para definir un relación 1:1 con Eloquent debes hacer lo siguiente: **Paso 1**. En el modelo de la tabla maestra (class Usuario, en nuestro ejemplo) añadimos este método: ```php public function email() { return $this->hasOne('App\\Email'); } ``` **Paso 2**. En el modelo de la tabla relacionada (class Email) añadimos este método: ```php public function usuario() { return $this->belongsTo('App\\Usuario'); } ``` A partir de ahora, se puede recuperar el email de un usuario (o a la inversa) de forma tan sencilla como esta: ```php $email = Usuario::find(1)->email; $user = Email::all()->first()->user; ``` #### 5.11.7.2. Relaciones 1:N (usuarios artículos) Si tienes una relación 1:N (como la que hay entre las tablas de usuarios y artículos de nuestro ejemplo), para definirla en Eloquent tienes que hacer esto: **Paso 1**. En el modelo de la tabla maestra (class Usuario), añade este método: ```php public function articulos() { return $this->hasMany('App\\Articulo', 'idUsuario'); } // ATENCIÓN: hemos tenido que indicar el nombre de la clave foránea // (idUsuario) porque no habíamos respetado la convención de Laravel // (usuario_id) al crear la tabla de artículos ``` **Paso 2**. En el modelo de la tabla relacionada (class Articulo), añade este otro método: ```php public function usuario() { return $this->belongsTo('App\\Usuario'); } ``` Y listo. Ya puedes recuperar los artículos a partir del usuario o a la inversa. Por ejemplo: ```php $articulos = Usuario::find(1)->articulos; foreach ($articulos as $articulo) { // Procesar cada artículo } ``` #### 5.7.11.3. Relaciones N:N (usuarios roles) Si lo que tienes es una relación con cardinalidad N:N (como la que hay entre usuarios y roles en nuestro ejemplo), los pasos a seguir para construirla con Eloquent son estos: **Paso 1**. En el modelo de una de las tablas (class Usuario) añadimos este método: ```php public function roles() { return $this->belongsToMany('App\\Rol'); } ``` **Paso 2**. En el modelo de la otra tabla (class Rol) añadimos este método: ```php public function usuarios() { return $this->belongsToMany('App\\Usuario'); } ``` Ahora, ya se pueden recuperar los roles a partir del usuario o a la inversa. Por ejemplo: ```php $roles = Usuario::find(1)->roles; foreach ($roles as $rol) { // Procesar cada rol } ``` #### 5.7.11.4. Insertar, modificar y borrar en relaciones N:N Insertar, modificar y borrar en relaciones N:N implica escribir datos (normalmente, ids) en la tabla intermedia o tabla pivote. Ese proceso también se puede automatizar con Eloquent. Lo vemos con un ejemplo entre nuestras tablas usuarios y roles. **Para insertar** un usuario y sus roles se usa el método attach(): ```php public function store(Request $r) { $user = new User($r→all()); $user->roles()→attach($r->roles); $user->save(); } ``` **Para actualizar** un usuario y sus roles se usa el método sync(): ```php public function update(Request $r, $id) { $user = User::find($id); $user->fill($r->all()); $user->roles()->sync($r->roles); $user->save(); } ``` **Para eliminar** un usuario y sus roles se usa el método detach(): ```php public function destroy($id) { $user = User::find($id); $user->roles()->detach(); $user->delete(); } ``` #### 5.7.11.5. Problemas frecuentes en relaciones N:N Eloquent supondrá que el nombre de la tabla de la relación se ha formado con los nombres de las dos tablas maestras en snake case y ordenadas alfabéticamente. Por ejemplo, en la relación N:N entre “usuarios” y “roles”, Eloquent supondrá que existe una tabla llamada “roles_usuarios”. Si no es así, la relación fallará. Se puede indicar otro nombre de tabla al definir la relación. Por ejemplo, en el modelo de usuarios (class Usuario): ```php public function roles() { return $this->belongsToMany('App\\Rol', 'usuarios_roles'); } ``` También se pueden indicar los nombres de las claves foráneas si no siguen la convención de Laravel (usuario_id, rol_id, etc) ```php public function roles() { return $this->belongsToMany('App\\Rol', 'usuarios_roles', 'id_usuario', 'id_rol'); } ``` ¿Te has fijado en que hemos creado un método para acceder a la tabla relacionada, pero estamos usando un atributo en su lugar? ```php public function articulos() { return $this->hasMany('App\\Articulo'); } public function loQueSea() { $arts = Usuario::find(1)->articulos; // articulos, no articulos() } ``` Pues bien, el atributo articulo es un “atributo virtual” creado por Eloquent. Pero el método articulos() también existe, y puede usarse como una consulta, extendiéndola como necesitemos. Por ejemplo: ```php $arts = Usuario::find(1)->articulos()->where('titulo','foo')->first(); ``` ",
    "url": "/laravel/11",
    "relUrl": "/laravel/11"
  },"28": {
    "doc": "5.12 Usando la BD con QueryBuilder",
    "title": "5.12 Usando la BD con QueryBuilder",
    "content": "## 5.12. Usando la BD con QueryBuilder ### 5.12.1. ¿Qué es y cómo se utiliza QueryBuilder? Eloquent permite usar la BD de forma simple y elegante en la mayor parte de las circunstancias. Aún así, puede haber situaciones en las que queramos un acceso de más bajo nivel a la BD. Para eso existe QueryBuilder. El grado de abstracción de QueryBuilder es mucho menor que el de Eloquent. Es decir, estaremos CASI escribiendo SQL, sin llegar a hacerlo. Algunos ejemplos de uso te darán una pista de qué tipo cosas se pueden hacer con QueryBuilder: ```php $users = DB::table(\"users\")->get(); $users = DB::table(\"users\")->where(\"name\", \"=\", \"Ana\")->first(); $users = DB::table(\"users\")->where(\"edad\", \">=\", 18)->orderBy(\"apellidos\"); $maxId = DB::table(\"users\")->max(\"id\"); $existe = DB::table(\"users\")->where(\"id\", \"=\", $id)->exists(); $users = DB::table(\"users\")->select(\"nombre, apellidos as apell\")->get(); ``` En la documentación oficial encontrarás una referencia completa de todas las funciones de QueryBuilder, pero con estas que ves en el ejemplo puedes construir prácticamente cualquier consulta sencilla. El resultado de estas consultas es bastante intuitivo: o bien un dato simple (como el $maxId, que es un entero) o bien un objeto de tipo Collection. Las colecciones de Laravel tienen un montón de métodos útiles para procesarlas y puedes echarle un vistazo a la documentación oficial para ello, pero la mayor parte de las veces basta con hacer un foreach sobre la variable para ir accediendo a cada uno de los elementos, que se comportarán como objetos del tipo adecuado. Por ejemplo, para acceder a todos los registros de la tabla de usuarios: ```php $users = DB::table(\"users\")->get(); foreach ($users as $user) { echo $user->name; echo $user->email; ...etc... } ``` ### 5.12.2. Ventajas de QueryBuilder sobre SQL Como ves, QueryBuilder te permite construir sentencias SQL sin necesidad de escribir SQL. La ventaja de esto es triple: 1. No tendremos que depurar nuestros errores sintácticos en SQL, con el ahorro de tiempo que eso conlleva. 2. El SQL generado será 100% compatible con el gestor de base de datos que estemos utilizando. Si escribimos SQL en crudo, tendremos que adaptarlo al dialecto de nuestro gestor de base de datos. Y, si cambiamos de gestor, habrá que revisar todas las sentencias SQL para adaptarlas de nuevo. Todo esto lo evita QueryBuilder, puesto que hace esa adaptación por nosotros. 3. Es imposible que suframos un ataque por inyección de SQL, puesto que QueryBuilder no lo permitirá. ### 5.12.3. Relaciones entre tablas con QueryBuilder Las relaciones entre tablas se manejan con joins, como en SQL, solo que escritos al estilo QueryBuilder. Para hacer un INNER JOIN, puedes usar como referencia este ejemplo: ```php $users = DB::table('users') ->join('contacts', 'users.id', '=', 'contacts.user_id') ->join('orders', 'users.id', '=', 'orders.user_id') ->select('users.*', 'contacts.phone', 'orders.price') ->get(); ``` Por supuesto, también puedes hacer LEFT JOIN y RIGHT JOIN: ```php $resultado = DB::table('A')->leftJoin('B'...); $resultado = DB::table('A')->rightJoin('B'...); ``` ### 5.12.3. SQL crudo Por último, QueryBuilder también te permite escribir SQL crudo, si es que alguna vez lo necesitas. Eso sí, deberías valorar muy bien para qué narices quieres escribir SQL crudo. ¿Estás seguro de que eso que intentas hacer no se puede lograr más fácilmente con Eloquent o con QueryBuilder? Además, tendrás que extremar las precauciones ante un posible ataque por inyección de SQL. Si aún así no te he convencido, puedes ejecutar tu SQL así: ```php $resultado = DB::raw('escribe-aquí-tu-sentencia-SQL'); ``` ",
    "url": "/laravel/12",
    "relUrl": "/laravel/12"
  },"29": {
    "doc": "5.13 Sesiones con Laravel",
    "title": "5.13 Sesiones con Laravel",
    "content": "## 5.13. Sesiones con Laravel Como es lógico, Laravel también proporciona su propio sistema de manejo de variables de sesión, y este resulta mucho más seguro y poderoso que el estándar de PHP. En esta sección vamos a ver cómo funciona y qué posibilidades nos ofrece. ### 5.13.1. Drivers de sesión Las sesiones de configuran en /config/sessions.php, y una de las cosas que debes configurar ahí es el \"driver\", es decir, el tipo de manejador que quieres que manipule las sesiones. El driver por defecto es ***files***. Es el más sencillo y funcionará en casi cualquier servidor. En producción, Laravel recomienda usar otros drivers llamados ***memcached*** o ***redis*** porque son más rápidos. Ambos son daemons del sistema programados para esta tarea. Obviamente, el servidor debe soportarlos para que puedas usarlos. Si necesitas seguridad adicional, sin duda tu driver es ***database***. Esto almacenará dos copias de cada variable de sesión: una en un fichero y otra en una tabla especial de la base de datos. Si un atacante consiguiera manipular una de las dos variables, Laravel cerrará la sesión automáticamente y el atacante se quedará con un palmo de narices. Eso sí, este sistema es el más lento de todos porque requiere un acceso a la base de datos para cada petición al servidor. ### 5.13.2. Persistencia de las variables de sesión Laravel maneja dos tipos de variable según su persistencia: * Variables flash: solo duran una petición y luego se autodestruyen. * Variables de sesión convencionales: existen hasta que las destruimos expresamente. #### 5.13.2.1. Variables flash Son variables de sesión que solo duran una petición y luego se autodestruyen. Se usan típicamente para enviar feedback al usuario. Te lo muestro con un ejemplo. En el controlador: ```php return ('login/form')->with('mensaje', 'Usuario no reconocido'); ``` En la vista: ```php @if (session('mensaje')) {% raw %}{{ session('mensaje'); }}{% endraw %} @endif ``` #### 5.13.2.2. Variables de sesión convencionales Las variables de sesión convencionales se manejan con la clase Session, que tiene un montón de métodos estáticos para crear variables, destruirlas, consultarlas, etc. Los métodos más útiles son: * **put()** -> almacena una variable de sesión: ```php Session::put('nombre-variable', 'valor'); ``` * **push()** -> elimina una variable de sesión: ```php Session::push('nombre-variable'); ``` * **get()** -> devuelve el valor de una variable de sesión: ```php $v = Session::get('nombre-variable'); $v = Session::get('nombre-variable', 'valor-por-defecto'); ``` * **all()** devuelve todas las variables de sesión en un array: ```php $a = Session::all('nombre-variable', 'valor'); ``` * **flush()** elimina todas las variables de sesión: ```php Session::flush(); ``` * **flash()** crea manualmente una variable de sesión de tipo flash: ```php Session::flash('nombre-variable', 'valor'); ``` ### 5.13.3. Autenticación #### 5.13.3.1. Laravel Breeze Laravel proporciona un Starter Kit llamado ***Breeze*** que viene con todo el código necesario para crear un sistema de autenticación completo y seguro: * Login e inicio de sesión * Registro de usuarios * Recuperación de contraseña olvidada * Confirmación de registro mediante email * Etc. Para instalar Laravel Breeze: ``` $ composer require laravel/breeze --dev $ php artisan breeze:install $ npm install $ npm run dev ``` Laravel Breeze crea automáticamente varias rutas en /routes/auth.php, entre ellas: ```php Routes::get(\"/login\") → Para mostrar el formulario de login Routes::post(\"/login\") → Para procesar el formulario de login Routes::post(\"/logout\") → Para cerrar la sesión Routes::get(\"/register\") → Para mostrar el fomulario de registro Routes::post(\"/register\") → Para procesar el formulario de registro ``` También se crean varios controladores como LoginController y RegisterContoller: están en App/Http/Controllers/Auth. Y se crean varias vistas, como auth/login.blade.php, register.blade.php y layouts/app.blade.php (la plantilla que usarán login y register) Por último, se crea una vista HOME de ejemplo (dashboard.blade.php) a la que llegamos después de hacer login. Esa vista HOME la puedes cambiar en /app/providers/RouteServiceProvider.php ¡Y listo! Solo nos queda adaptar estas vistas y controladores a nuestras necesidades. #### 5.13.3.1. Autenticación y vistas: cómo generar código dependiendo del tipo de usuario En las vistas, tenemos un par de directivas de Blade muy útiles relacionadas con las sesiones. ```php @auth ... // Este código se ejecuta si existe un usuario logueado @endauth @guest ... // Este código se ejecuta si NO existe usuario logueado @endguest ``` Además, podemos acceder a los datos del usuario mediante la clase Auth: ```php Auth::user() → Devuelve el usuario actualmente logueado o null si no hay ninguna sesión abierta. Auth::check() → Devuelve true si el usuario actual está logueado. ``` (Más métodos de Auth en https://laravel.com/docs/8.x/authentication) #### 5.13.3.2. Autenticación y middlewares: cómo proteger los controladores Los middlewares son componentes software de Laravel que capturan y filtran todas las peticiones HTTP que llegan a la aplicación. Están ubicados en App/Http/Middleware. Hay dos middlewares relacionados con la autenticación en Laravel: Authenticate (alias \"auth\") y RedirectIfAuthenticated (alias \"guest\"). Los alias se definen en App/Http/Kernel.php. Podemos usar estos middlewares en el constructor de nuestros controladores para protegerlos en todo o en parte: ```php public function __construct() { // Solo usuarios logueados podrán acceder a este controlador: $this->middleware(\"auth\"); // Solo usuarios logueados podrán acceder a los métodos create() y edit(): $this->middleware(\"auth\")->only(\"create\", \"edit\"); // Solo usuarios logueados podrán acceder al controlador excepto a show(): $this->middleware(\"auth\")->except(\"show\"); } ``` El middleware auth también puede usarse en el enrutador, para proteger todo el controlador, así: ```php Route::get('/ruta-a-proteger', 'Controlador@metodo')->middleware('auth'); ``` ",
    "url": "/laravel/13",
    "relUrl": "/laravel/13"
  },"30": {
    "doc": "5.14 Helpers de Laravel",
    "title": "5.14 Helpers de Laravel",
    "content": "## 5.14. Helpers de Laravel ### 5.14.1. ¿Qué son los helpers? Un helper es un componente del framework diseñado para facilitar alguna tarea típica en el desarrollo de una aplicación web. Por ejemplo: el helper url('ruta') genera una ruta absoluta para referenciar cualquier componente de la aplicación: ```html Volver ``` Generará este código: ```html Volver ``` Eso permite que la ruta sea correcta en cualquier servidor, sin necesidad de modificar el código fuente. El uso de los helpers es optativo: el programador/a debe decidir si le resultan útiles o no. Los helpers van cambiando mucho de una versión a otra de Laravel, por lo que te recomiendo que eches un vistazo a la documentación oficial para saber qué helpers están disponibles en tu versión de Laravel. Puedes encontrar una lista completa de helpers en: https://laravel.com/docs/X.x/helpers (sustituye X.x por tu versión de Laravel) ### 5.14.2. Algunos helpers útiles de Laravel #### 5.14.2.1. url helper ```html Volver ``` Generará este código: ```html Volver ``` Eso permite que la ruta sea correcta en cualquier servidor, sin necesidad de modificar el código fuente. #### 5.14.2.2. route helper Es parecido a url(), pero sirve para routas con nombre en el enrutador. Por ejemplo, si en el enrutador tenemos una ruta como esta: ```php Route::get(\"mi-ruta\", \"metodo@mi-controlador\")->name(\"nombre-ruta\"); ``` ...podemos referirnos a ella como: ```html Texto ``` ...o como: ```html Texto ``` La segunda forma es la mejor: permite cambiar la dirección que ve el usuario sin modificar el código fuente. #### 5.14.2.3. request helper Proporciona acceso a información sobre la petición (GET, POST o la que sea) con la que se cargó la página: * **request()->url()** → Devuelve un string con la ruta actual (completa). * **request()->path()** → Devuelve un string con la ruta actual (solo desde la raíz de la aplicación, sin http ni el nombre del servidor). * **request()->is(\"ruta\")** → Devuelve true si \"ruta\" coincide con la ruta actual. Admite wildcards (símbolos * y ?). * **request()->input(\"campo\")** → Devuelve el valor de \"campo\" (enviado desde formulario). * **request()->all()** → Devuelve un array con todos los campos. * **request()->has(\"campo\")** → Devuelve true si en la petición existe un campo con el nombre indicado. * **request()->isMethod(\"método\")** → Devuelve true si la petición se hizo por el método indicado (POST, GET, PUT, etc). El helper Request puede usarse en las vistas (como request()->url(), por ejemplo) o inyectarse en las funciones del controlador como una variable, así: ```php public function mi-función(Request $request) ``` #### 5.14.2.4. redirect helper Muy útil cuando queremos redirigir al usuario hacia otra URL o acción (por ejemplo, para evitar que al pulsar F5 se reenvíen los datos de un formulario). Admite varias formas: ```php return redirect('user/login'); return redirect()->action('LoginController@login'); return back(); ``` #### 5.14.2.5. auth helper Como vimos en la sección de sesiones y autenticación, este helper permite saber si existe algún usuario autenticado en la aplicación. auth()->user() devuelve el usuario autenticado (como un objeto) o null si nadie ha hecho login. Con el objeto User podemos acceder a todos los datos del usuario: ```php $user = auth()->user(); Bienvenido/a, {% raw %}{{ $user->name }}{% endraw %}. Este es su emial: {% raw %}{{ $user->email }}{% endraw %} ``` #### 5.14.2.6. errors helper Se utiliza para conocer y mostrar los errores ocurridos en la validación de un formulario (v. apartado de validación de formularios). La variable $errors está disponible en todas las vistas gracias a que un Middleware (ShareErrorsFromSession) la inyecta automáticamente. Algunos métodos útiles son: * **$errors->all()** → devuelve un array con todos los errores detectados. * **$errors->any()** → devuelve true si se ha detectado algún error. * **$errors->first(\"campo\")** → devuelve el primer error de todos los que puedan afectar al campo indicado. ",
    "url": "/laravel/14",
    "relUrl": "/laravel/14"
  },"31": {
    "doc": "5.15 Flujo de trabajo típico con Laravel",
    "title": "5.15 Flujo de trabajo típico con Laravel",
    "content": "## 5.15. Flujo de trabajo típico con Laravel Lo que vas a encontrar aquí es solo un posible flujo de trabajo con Laravel, es decir, una propuesta del orden en el que debes hacer las cosas para desarrollar una aplicación con este framework. No es el único flujo de trabajo posible, y sin duda no es el mejor, pero puede resultarte útil en tus primeros desarrollos, como si alguien te llevara de la mano a lo largo de un camino sinuoso. Más adelante, cuando vayas adquiriendo experiencia, tú mismo/a crearás tu propio flujo de trabajo ideal. El flujo que te propongo tiene los siguientes pasos (los cuatro primeros son solo para aplicaciones nuevas): 1. Instalar y configurar nueva aplicación. 2. Crear modelos (se supone que ya tendrás la BD diseñada). 3. Crear migraciones y seeders. 4. Lanzar las migraciones y seeders para crear y poblar la BD. 5. Crear en el enrutador las entradas de la funcionalidad que vas a programar. 6. Crear el controlador (si no existe) para la funcionalidad que vas a programar. 7. Crear las funciones del controlador necesarias. 8. Crear las funciones del modelo necesarias (si no existen ya). 9. Crear las vistas necesarias. 10. Probar. 11. Repetir los pasos 5-10 para cada funcionalidad adicional. ",
    "url": "/laravel/15",
    "relUrl": "/laravel/15"
  },"32": {
    "doc": "5.16 Laravel y Vue.js",
    "title": "5.16 Laravel y Vue.js",
    "content": "## 5.16. Laravel y Vue.js ",
    "url": "/laravel/16",
    "relUrl": "/laravel/16"
  },"33": {
    "doc": "5.17 Aspectos avanzados de Laravel",
    "title": "5.17 Aspectos avanzados de Laravel",
    "content": "## 5.17. Aspectos avanzados de Laravel TODO ### 5.17.1. Traducciones TODO ### 5.17.2. Paginación de resultados TODO ### 5.17.3. Páginas de error personalizadas TODO ### 5.17.4. URLs amigables: Routes model bindings TODO ### 5.17.5. Validación avanzada de formularios con form requests TODO ### 5.17.6. Laravel Mix TODO ### 5.17.7. Crear helpers y middlewares TODO ### 5.17.8. Collections TODO ### 5.17.9. Eventos y Listeners TODO ### 5.17.10. Actualizar la versión de Laravel de una aplicación existente sin tirarse por la ventana en el intento TODO ### 5.17.11. Mejora del rendimiento. Caché. TODO ### 5.17.12. Decoradores e interfaces TODO ### 5.17.13. Pruebas con Mockery y Selenium TODO ",
    "url": "/laravel/17",
    "relUrl": "/laravel/17"
  },"34": {
    "doc": "5.2 Características de Laravel",
    "title": "5.2 Características de Laravel",
    "content": "## 5.2. Características de Laravel Laravel es un framework PHP MVC para desarrollo rápido de aplicaciones web. Automatiza muchos procesos habituales y tiene una curva de aprendizaje empinada, pero no tanto como otros frameworks (como Symfony). Desde hace algunos años, Laravel ha experimentado un crecimiento espectacular en el mercado de las aplicaciones web. ### 5.2.1. Ventajas de Laravel 1. Sintaxis simple y elegante. 2. Mapeo objeto-relacional (ORM): Eloquent. 3. Potente sistema de plantillas para vistas: Blade. 4. Reutiliza y moderniza componentes de Symfony. 5. Sencillo y potente. 6. Uso creciente en la industria: alternativa de futuro. 7. Comunidad de usuarios altamente especializada (buena relación señal/ruido… de momento) ### 5.2.2. Inconvenientes de Laravel 1. Instalación, configuración y despliegue complejos, incluso a través de VM. 2. Curva de aprendizaje elevada. 3. Se mueve según los intereses personales de su autor (es obra individual), con actualizaciones muy frecuentes y cambios caprichosos. 4. Inestabilidad de varios de sus componentes: a menudo hay que recurir a fixes. 5. Fuerte dependencia de la consola de comandos y de herramientas de terceros (composer, vagrant, npm...) (Esto solo es un inconveniente para algunas personas) ",
    "url": "/laravel/2",
    "relUrl": "/laravel/2"
  },"35": {
    "doc": "5.3 Instalación de Laravel",
    "title": "5.3 Instalación de Laravel",
    "content": "## 5.3. Instalación de Laravel ### 5.3.1. Instalación en servidor local No es recomendable instalar Laravel de forma nativa en tu servidor local porque requiere una fuerte configuración del servidor. Tendrás que instalar bastante librerías que consumirán recursos de tu máquina sin necesidad, tales como OpenSSL, Mbstring o Tokenizer. También necesitas instalar composer, la herramienta de resolución de dependencias de PHP. Por todo ello, es recomendable optar por la virtualización del servidor mediante Vagrant (Homestead) o Docker. Discutiremos estas dos opciones más adelante. Si, aún así, estás decidido a instalar Laravel de forma nativa en tu servidor local, sigue estos pasos: **Paso 1**. Descarga Laravel. ``` $ composer global require \"laravel/installer\" ``` **Paso 2**. Instala copia de Laravel limpia y lista para usar (hacerlo en un directorio accesible por Apache). Puede requerir añadir el comando laravel al PATH del sistema. ``` $ laravel new ``` Por ejemplo: ``` $ laravel new blog ``` No olvides dar los permisos necesarios a tus archivos y directorios. Los problemas que pueden surgir son múltiples e insospechados, dependiendo de la configuración de tu servidor. Puedes intentar seguir alguna de estas guías: * [Guía para instalar Laravel en localhost en Ubuntu Linux](https://www.howtoforge.com/tutorial/install-laravel-on-ubuntu-for-apache/) * [Guía para instalar Laravel en localhost con Windows y XAMPP:](https://weeklyhow.com/installing-laravel-8-with-xampp/) ### 5.3.2. Instalación de Laravel con máquina virtual Vagrant (Homestead) Vagrant es una herramienta para crear un entorno de desarrollo virtual sin necesidad de instalar componentes en nuestra máquina. Cada entorno de desarrollo se llama Box y hay cientos de ellos. **Homestead** es un Box de Vagrant con todo lo necesario para desarrollar con Laravel sin necesidad de configurar nuestro servidor local. Este Box, creado por los propios desarrolladores de Laravel, puede configurarse para equipararlo al servidor donde se vaya a desplegar la aplicación en el futuro. La instalación de Laravel en Homestead es la forma recomendada para desarrollar proyectos Laravel en un entorno local. La puesta en producción es otra historia, y dependerá de las posibilidades de configuración del servidor. Instalar Laravel con Homestead en tu entorno local puede parecer un proceso largo y complejo, pero no suele dar problemas y la fiabilidad de está solución está garantizada, por lo que es la manera más recomendable. Si deseas instalarlo, sigue estos pasos: **Paso 1**. Instala la última versión disponible de Virtual Box. **Paso 2**. Instala Vagrant y git **Paso 3**. Agrega a Vagrant el box de Homestead: ``` $ vagrant box add laravel/homestead ``` **Paso 4**. Consigue el último código fuente de Laravel: ``` $ git clone https://github.com/laravel/homestead.git ~/Homestead ``` **Paso 5**. Selecciona la rama \"release\" del repositorio de Laravel y lanza el script de inicialización: ``` $ cd Homestead $ git checkout release $ bash init.sh (o init.bat en Windows) ``` **Paso 6**. Edita el archivo Homestead.yaml para configurar tu máquina virtual. **Paso 7**. Edita el archivo hosts (/etc/hosts o C:\\Windows\\System32\\drivers\\etc\\hosts) para añadir esta línea: ``` 192.168.10.10 homestead.test ``` (Cámbiala por la IP que hayas configurado en el archivo .yaml) **Paso 8**. Levanta la máquina virtual Homestead: ``` $ vagrant up ``` (Este comando hay que ejecutarlo desde el directorio Homestead) La primera vez puede tardar un rato mientras crea y configura la VM. **Paso 9**. Prueba en el navegador la dirección: http://homestead.test. El servidor debería responder. **Paso 10**. Prueba a acceder a la VM mediante ssh con el comando: ``` $ vagrant ssh ``` **Paso 11**. En la máquina real, crea el directorio ~/code (o el que esté configurado en el archivo Homestead.yaml). **Paso 12**. En la máquina virtual, ve al mismo directorio ~/code (o el que esté configurado en Homestead.yaml) y actualiza las librerías PHP con composer: ``` $ composer create-project laravel/laravel code --prefer-dist $ composer install ``` ¡Y listo! Tú trabajarás en tu directorio local ~/code y cualquier cambio que hagas se mapeará automáticamente al directorio ~/code en la VM. Mantén una consola abierta en la VM para ejecutar comandos artisan. Ten en cuenta que MySQL estará escuchando en 127.0.0.1:33060 (user “Homestead”, password “secret”, salvo que hayas cambiado la configuración) (¡Ojo! Esto es para conexiones desde fuera de Homestead. Desde el punto de vista de la app, MySQL seguirá estando en localhost:3306) Es posible que necesites generar una clave SSH para conexiones seguras con tu servidor virtual. * [Cómo hacerlo en Linux](https://ekiketa.es/fallo-en-homestead-check-your-homestead-yaml-file-the-path-to-your-private-key-does-not-exist/) * [Cómo hacerlo en Windows 10](https://medium.com/@eaimanshoshi/i-am-going-to-write-down-step-by-step-procedure-to-setup-homestead-for-laravel-5-2-17491a423aa) Más info en [https://laravel.com/docs/8.X/homestead](https://laravel.com/docs/8.X/homestead) ### 5.3.3. Laravel con Docker Docker es una solución de virtualización aún más ligera que Vagrant. Con Docker, se virtualizan solo los componentes software que nuestra aplicación necesita para funcionar, y se ejecutan directamente en la máquina anfitrión. Los componentes se llaman ***images***. Cuando se instancian, pasan de denominarse ***containers***. Hay docker images para todo lo imaginable. Puedes encontrarlas en [https://hub.docker.com](https://hub.docker.com). Aunque Laravel recomienda la virtualización mediante Vagrant, muchos desarrolladores optan por Docker por su mayor simplicidad y eficiencia. Para instalar Laravel mediante Docker para un desarrollo local, sigue estos pasos: **Paso 1**. Instala docker (y, optativamente, docker-compose) en tu servidor. **Paso 2**. Busca una imagen de Laravel en https://hub.docker.com. Por ejemplo, Bitnami (una empresa propiedad de VMWare) tiene imágenes bastante fiables. **Paso 3**. Crea un directorio para tu aplicación web. No importa en qué parte del árbol de directorios local estés. **Paso 4**. En la consola, teclea el comando para crear una copia local de las imágenes necesarias. En el caso de la imagen Laravel de Bitnami, el comando es: ``` $ docker pull bitnami/laravel ``` **Paso 5**. Sigue las instrucciones para el despliegue del contenedor que el desarrollador ha debido colgar en hub.docker.com. En el caso de bitnami, hay que copiar un archivo remoto mediante el comando curl y levantar las imágenes docker con docker-compose. ¡Y listo! Nuestro Laravel estará funcionando con todas sus dependencias resueltas. ",
    "url": "/laravel/3",
    "relUrl": "/laravel/3"
  },"36": {
    "doc": "5.4 Arquitectura, convenciones y configuración de Laravel",
    "title": "5.4 Arquitectura, convenciones y configuración de Laravel",
    "content": "## 5.4. Arquitectura, convenciones y configuración de Laravel ### 5.4.1. Estructura de directorios Después de una instalación limpia de Laravel, nos encotraremos con una estructura típica de directorios. Los más importantes (al menos, para empezar) son estos: **composer.json**: información para composer. **/app**: el código de nuestra aplicación. Modelos. **/app/config**: configuración de la aplicación. **/app/http**: peticiones HTTP, incluyendo los controladores. **/database**: migraciones de la BD. **/plugins**: pues eso. **/public**: directorio de acceso público. Aquí se pueden colocar imágenes, scripts o archivos css. **/resources**: assets (imágenes, css, js), archivos de idioma y vistas. **/storage**: caché, sesiones, vistas compiladas... **/vendors**: librerías de terceros. ### 5.4.2. Convenciones en Laravel Laravel tiene un montón de convenciones que persiguen hacer más sencilla la configuración de la aplicación. Aunque la mayoría no son obligatorias, es recomendable respetarlas para evitar errores de configuración y conflictos con los identificadores. * **Modelos**: Nombres igual que el de la tabla, en singular, en CamelCase y con mayúscula. Ejemplo: RegisteredUser * **Controladores**: como el modelo, pero añadiendo la palabra \"controller\" o \"controlador\". Ejempo: RegisteredUserController * **Métodos**: en camelCase empezando con minúscula. Ejemplo: User::getAll() * **Atributos**: en snake_case empezando con minúscula. Ejemplo: User::first_name * **Variables**: en camelCase empezando con minúscula. Ejemplos: bannedUsers (colección, en plural), articleContent (variable simple, en singular) * **Tablas**: en plural y en snake_case. Ej: registered_users. * **Columnas**: en snake_case, sin referencia al nombre de la tabla. Ejemplo: first_name * **Clave primaria**: id (integer y auto-increment). * **Claves ajenas**: nombre tabla ajena en singlular + id. Ejemplo: article_id * **Timestamps**: created_at y updated_at * **Tablas pivote**: en snake_case, en plural y orden alfabético. Ejemplo: articles_users será el pivote entre articles y users. ### 5.4.3. Variables de entorno. El archivo .env Este archivo contiene todas las variables de entorno que configuran la aplicación, como: * APP_ENV: ¿estamos en desarrollo o en producción? * APP_DEBUG: ¿mostrar errores para depuración? * APP_URL: URL base de la aplicación * DB_CONNECTION, DB_HOST, DB_USERNAME, etc. El archivo example.env contiene una plantilla para que puedas construir tu archivo .env. Simplemente, renombra el archivo example.env y asigna los valores correctos a las variables de entorno. El archivo .env NO debe sincronizarse con git (o con el control de versiones que usemos) porque contiene información sensible. En los archivos de configuración haremos referencia a las variables de entorno. Por ejemplo: en /config/database.php usaremos una expresión así: ``` 'default' => env('DB_CONNECTION', 'mysql') ``` El primer parámetro de env() es la variable de entorno y el segundo es el valor por defecto en caso de que la variable no exista. ### 5.4.4. Archivos de configuración del directorio /config En este directorio encontraremos multitud de archivos que configuran el funcionamiento de Laravel. En principio, no es necesario modificar ninguno, porque las configuraciones básicas se manejan desde el archivo .env. Sin embargo, hay veces que sí necesitaremos acceder a estos archivos y tocar alguna configuración. Los archivos de configuración más importantes que puedes encontrar aquí son: **database.php**: configuración de la conexión a la base de datos. Toma sus valores principales de .env, pero desde aquí podemos cambiar otras cosas, como el controlador (por defecto es MySQL, pero podemos cambiarlo a PostgreSQL, SQLite, etc) **app.php**: nombre de la aplicación, estado (desarrollo, producción...) **session.php**: forma en la que se almacenarán las sesiones (por defecto, en fichero) ",
    "url": "/laravel/4",
    "relUrl": "/laravel/4"
  },"37": {
    "doc": "5.5 Artisan",
    "title": "5.5 Artisan",
    "content": "## 5.5. Artisan: la consola que mola ### 5.5.1. ¿Qué es Artisan y cómo se utiliza? Artisan es una herramienta de consola que automatiza las tareas habituales en Laravel como: * Generar esqueletos de controladores y modelos. * Crear migraciones de bases de datos (para manipular la estructura de las tablas) * Rellenar la BD con datos de prueba. * Hacer el enrutamiento. * Configurar la aplicación. * Crear baterías de pruebas. * Y otro montón de cosas. No te preocupes si aún no entiendes qué significan algunas de estas cosas. Lo iremos viendo todo poco a poco. Lo importante ahora es que comprendas la tremenda utilidad de Artisan en el trabajo cotidiano con Laravel y que aprendas lo básico de su sintaxis. Por ejemplo, para crear un controlador, existen dos maneras: 1. A mano. Nos vamos al directorio /app/Http/Controllers y creamos un archivo llamado, digamos, HolaController.php. Luego lo rellenamos con el esqueleto de un controlador vacío, copiando y pegando de otro controlador existente y eliminando todo lo que no nos haga falta. Este método, obviamente, es lento, farragoso y resulta fácil que comentamos algún error. 2. Con ayuda de artisan. Simplemente, tecleamos este comando en el directorio raíz de nuestra aplicación: ``` $ php artisan make:controller HolaController ``` Y listo. Artisan creará por nosotros el archivo /app/Http/Controllers/HolaController.php y lo rellenará con el esqueleto de un controlador vacío. ### 5.5.2. Artisan y máquinas virtuales Si utilizas Laravel con una máquina virtual (Homestead o Docker), tienes que hacer login en la máquina virtual para poder usar ejecutar los comandos de Artisan. Con Vagrant: ``` $ vagrant ssh ``` Con Docker: ``` $ docker exec -it bash ``` Una vez dentro de la máquina virtual, accede al directorio de tu aplicación y podrás ejecutar cualquier comando de Artisan. ### 5.5.3. Comandos principales de Artisan Si tecleas: ``` $ php artisan list ``` ...obtendrás una lista con todos los comandos de Artisan válidos en tu instalación de Laravel. Esto puede variar según tu versión de Laravel y los componentes que tengas instalados. En un primer momento, necesitarás conocer estos comandos: * php artisan db:migrate --> Para hacer migraciones (crear la estructura de nuestra base de datos). * php artisan db:seed --> Para llenar de datos predefinidos nuestra base de datos. * php artisan make:migration --> Crea una migración (para crear la estructura de la base de datos). * php artisan make:seeder --> Crea un seeder (para rellenar con datos las tablas). * php artisan make:controller --> Para crear un controlador. * php artisan make:model --> Para crear un modelo. * php artisan route:list --> Muestra todas las rutas definidas en el enrutador. ",
    "url": "/laravel/5",
    "relUrl": "/laravel/5"
  },"38": {
    "doc": "5.6 Primeros pasos con Laravel. Hola mundo",
    "title": "5.6 Primeros pasos con Laravel. Hola mundo",
    "content": "## 5.6. Primeros pasos con Laravel: Hola mundo En esta sección vamos a crear nuestra primera aplicación funcional con Laravel: el tradicional \"Hola mundo\". Nos servirá para aprender la dinámica de trabajo con Laravel y para construir un esqueleto de aplicación sobre la que montar algo más grande más adelante. **Crea una clave segura** Ejecuta el comando: ```php php artisan key:generate ``` Esto genera una clave aleatoria y la almacena en el archivo de configuración /.env Es necesaria para hacer conexiones seguras con la aplicación. En versiones recientes de Laravel es obligatorio crearla. **Probando el enrutador** Vamos a empezar probando algo sencillo: capturar una ruta. Edita el archivo /routes/web.php y añade esto: ```php Route::get('/hola', function() { return \"Hola, mundo\"; }); ``` Esto significa que, cuando escribas la ruta \"hola\" en la barra de direcciones del navegador, se ejecutará esta función anónima (también denominadas ***closures***) y, como resultado, se verá el texto \"Hola, mundo\" en la ventana del navegador. Pruébalo en el navegador la dirección: http:///index.php/hola **Enrutar al controlador** Ahora vamos a hacer que la misma ruta de antes provoque la ejecución de una función en un controlador. Edita el enrutador /routes/web.php, sustituye la ruta anterior por esto: ```php Route::get('/hola', 'HolaController@index'); ``` Esto indica al enrutador que, al recibir la ruta \"hola\", se debe ejecutar el método index() del controlador HolaController. Ahora tienes que crear ese controlador: ```php $ php artisan make:controller HolaController ``` Por último edita el controlador /app/Http/Controllers/HolaController.php: ```php public function index() { return \"Hola, mundo\"; } ``` Comprueba que funciona en el navegador: http:///index.php/hola (NOTA IMPORTANTE: desde Laravel 8, para que esto funcione es necesario descomentar la siguiente línea del archivo /app/Providers/RouteServiceProvider.php: // protected $namespace = 'App\\Http\\Controllers'; ) **Cargar una vista en el controlador** Vamos a variar el código anterior para que el método del controlador no produzca la salida HTML directamente, sino que invoque a una vista que genere el HTML. Además, vamos a inyectar en la URL una variable con el nombre del usuario para mostrar cómo se capturan esos valores y cómo se pasan a las vistas. Comenzamos modificando el enrutador /routes/web.php (observa cómo se indica la presencia de una variable en la URL): ```php Route::get('/hola/{nombre}', 'HolaController@show'); ``` Ahora creamos un método show() en el controlador /app/Http/Controllers/HolaController.php ```php public function show($nombre) { $data['nombre'] = $nombre; return view('hola', $data); } ``` Como ves, estamos invocando una vista llamada \"hola\" y le estamos pasando un array con los datos necesarios (el nombre del usuario, en este caso). Esa vista debe crearse en /resources/views/hola.blade.php y puede tener este aspecto: ```html Saludos, {% raw %}{{$nombre}}{% endraw %}. ¿Le apetece una partidita de ajedrez? ``` Puedes probar esta nueva ruta cargando en el navegador la ruta http:///index.php/hola/ProfesorFalken. La respuesta debería ser esta: ``` Saludos, ProfesorFalken. ¿Le apetece una partidita de ajedrez? ``` Recuerda que, desde Laravel 8, el funcionamiento del enrutador ha cambiado. Para conservar compatibilidad hacia atrás, hay que abrir el archivo /app/Providers/RouteServiceProvider.php y descomentar esta línea: ```php // protected $namespace = 'App\\Http\\Controllers'; ``` Hay otras soluciones que [se describen aquí](https://litvinjuan.medium.com/how-to-fix-target-class-does-not-exist-in-laravel-8-f9e28b79f8b4). ",
    "url": "/laravel/6",
    "relUrl": "/laravel/6"
  },"39": {
    "doc": "5.7 Enrutamiento",
    "title": "5.7 Enrutamiento",
    "content": "## 5.7. Enrutamiento Ya sabemos crear una aplicación Laravel simple (como \"Hola, mundo\") y hemos aprendido varias cosas sobre el enrutador. En esta sección, profundizaremos en este componente fundamental de cualquier aplicación web. ### 5.7.1. ¿Qué es el enrutador? El enrutador de Laravel es el componente que captura las URL solicitadas al servidor y las traduce a invocaciones a métodos de los controladores. El enrutador es capaz, además, de mapear fragmentos de la URL a variables PHP que serán inyectadas como parámetros a los métodos del controlador. También puede distinguir el verbo http empleado para solicitar una página al servidor. Es decir, para el enrutador no es lo mismo una solicitud enviada por GET que otra enviada por POST. Incluso admite verbos que aún no están soportados por http, como DELETE o PUT, y que teóricamente van a formar parte de futuras implementaciones del protocolo. ### 5.7.2. Enrutamiento básico Como vimos en el ejemplo del \"Hola, mundo\", hay varias formas de generar una salida HTML desde el enrutador (/routes/web.php). En este código de ejemplo vemos las más básicas: ```php // Forma 1: generar la salida con un closure (función sin nombre) Route::get('/hola', function() { return \"Hola, mundo\"; }); // Forma 2: llamar a un controlador sin pasarle parámetros Route::get('/hola', 'HolaController@show'); // Forma 3: llamar a un controlador pasándole parámetros Route::get('/hola/{nombre}', 'HolaController@show'); // Forma 4: llamar a un controlador con un parámetro optativo Route::get('/hola/{nombre?}', 'HolaController@show'); ``` ### 5.7.3. Rutas con nombre Es MUY recomendable asignar un nombre a las rutas en el enrutador. Esto hace que, más adelante, podamos cambiar la URL de los enlaces sin tener que modificar el código fuente de nuestras vistas. ```php Route::get('/contactame', 'Controlador@contacto')->name('contact'); ``` Internamente, esta ruta se direccionará con la expresión route('contact') (ya veremos exactamente cómo), pero el usuario verá la dirección http://servidor/contactame. En el futuro se puede cambiar la forma en la que lo ve el usuario, pero para el código fuente seguirá siendo route('contact') ### 5.7.4. Verbos http: GET, POST, PUT y DELETE Además de GET, en el enrutador se puede enrutar otras acciones: ```php Route::get(); // Solicitudes habituales Route::post(); // Recepción de datos de formulario (para insert) Route::put|patch(); // Recepción de datos para update Route::delete(); // Recepción de datos para delete Route::match(array('GET','POST'), 'ruta', acción) // Responderá tanto a GET como a POST ``` Los métodos de formulario PUT y DELETE no están soportados aún por http ni por HTML. Hay que emularlos en los formularios así: ```html @method('DELETE') ``` ### 5.7.5. Orden de las rutas El orden de las rutas es importante. Por ejemplo, si pedimos la dirección http:///usuario/crear, estas rutas fallarán: ```php Route::get('usuario/{nombre}', 'UsuarioController@show'); Route::get('usuario/crear', 'UsuarioController@create'); ``` El problema es que tratará de mostrar un contacto con nombre = \"crear\", porque la petición encaja con las dos rutas y el enrutador siempre elegirá la primera ruta que encuentre. La solución pasa por alterar el orden de las líneas en el enrutador: ```php Route::get('usuario/crear', 'UsuarioController@create'); Route::get('usuario/{nombre}', 'UsuarioController@show'); ``` ### 5.7.6. Servidor RESTful Un servidor RESTful es aquel que responde a la [arquitectura REST](https://juanda.gitbooks.io/webapps/content/api/arquitectura-api-rest.html). Típicamente, el enrutador de un servidor RESTful contendrá las 7 operaciones REST para cada recurso accesible desde la red. Por ejemplo, para un recurso llamado \"usuario\", el enrutador tendrá estas 7 entradas: ```php Route::get('user', 'UserController@index')->name('user.index'); Route::get('user/{user}', 'UserController@show')->name('user.show'); Route::get('user/crear', 'UserController@create')->name('user.create'); Route::post('user/{user}', 'UserController@store')->name('user.store'); Route::get('user/{user}/edit', 'UserController@edit')->name('user.edit'); Route::patch('user/{user}', 'UserController@update')->name('user.update'); Route::delete('user/{user}', 'UserController@destroy')->name('user.destroy'); ``` También se puede crear una entrada en el enrutador de este estilo: ```php Route::resource('user'); ``` Esa única ruta engloba a las siete rutas REST. ",
    "url": "/laravel/7",
    "relUrl": "/laravel/7"
  },"40": {
    "doc": "5.8 Vistas y plantillas. Blade",
    "title": "{% raw %}{{$name}}{% endraw %}",
    "content": "Este es el contenido de mi página. @endsection ``` ### 5.8.5. Condiciones en las vistas Blade admite expresiones condicionales para modificar el aspecto de una vista dependiendo del valor de una variable o del estado de la aplicación. En el siguiente ejemplo, el contenido de la vista depende de la variable $day. Controlador: ```php function show() { return view('page',array('name' => 'Manolo','day' => 'Viernes')); } ``` Vista /resources/views/page.blade.php: ```html @extends('layouts.master') @section('title', 'Page Title') @section('sidebar') Esto se añadirá al sidebar del master layout. @endsection @section('content') ",
    "url": "/laravel/8",
    "relUrl": "/laravel/8"
  },"41": {
    "doc": "5.8 Vistas y plantillas. Blade",
    "title": "{% raw %}{{$name}}{% endraw %}",
    "content": "Este es el contenido de mi página. @if ($day == 'Viernes') Hoy me roban el carro . @else Hoy me dedico a cantar . @endif @endsection ``` Observa que esto mismo podría hacerse abriendo y cerrando php (), pero de este modo el código queda mucho más limpio y resulta menos propenso a errores. ### 5.8.6. Bucles en las vistas Igual que existen condiciones, Blade también permite hacer bucles para simplificar la generación de visas. Por ejemplo, en la siguiente vista recorremos un array llamado $bebidas y mostramos su contenido. Controlador: ```php function show() { $bebidas = array('Cerveza','Agua','Zumo'); return view('page',array('name' => 'Manolo','day' => 'Lunes', 'bebidas' => $bebidas)); } ``` Vista /resources/views/page.blade.php: ```html @extends('layouts.master') @section('title', 'Page Title') @section('sidebar') Esto se añadirá al sidebar del master layout. @endsection @section('content') ",
    "url": "/laravel/8",
    "relUrl": "/laravel/8"
  },"42": {
    "doc": "5.8 Vistas y plantillas. Blade",
    "title": "{% raw %}{{$name}}{% endraw %}",
    "content": "Este es el contenido de mi página. @if ($day == 'Viernes') Hoy me roban el carro . @else Hoy me dedico a cantar . @endif ",
    "url": "/laravel/8",
    "relUrl": "/laravel/8"
  },"43": {
    "doc": "5.8 Vistas y plantillas. Blade",
    "title": "Estas son las bebidas disponibles:",
    "content": "@foreach ($bebidas as $bebida) {% raw %}{{$bebida}}{% endraw %} @endforeach @endsection ``` Observa que esto mismo podría hacerse abriendo y cerrando php (), pero de este modo el código queda mucho más limpio y resulta menos propenso a errores. ### 5.8.7. Invocación de funciones PHP Desde una vista Blade se puede invocar cualquier función de PHP sin necesidad de abrirlo y cerrarlo (). Por ejemplo, si necesitamos la función date(), la invocamos así: ```html ",
    "url": "/laravel/8",
    "relUrl": "/laravel/8"
  },"44": {
    "doc": "5.8 Vistas y plantillas. Blade",
    "title": "Ejemplo de llamada a función estándar de PHP",
    "content": "La fecha del servidor es: {% raw %}{{date(' D M, Y')}}{% endraw %} . ``` Esto es mucho más seguro que abrirlo y cerrarlo php () porque filtra posibles ataques XSS. Si alguna vez necesitamos saltarnos la protección contra XSS, debemos usar {% raw %}{!! ... !!}{% endraw %} en lugar de {% raw %}{{ ... }}{% endraw %}. ### 5.8.8. Otras directivas Blade Blade dispone de multitud de directivas para hacer prácticamente cualquier cosa en la vista sin tener que recurrir a PHP. En esta lista mostramos solo las directivas más habituales. - **@section** → Marca el inicio de una sección de contenido. - **@endsection** → Marca el final de una sección. - **@show** → Marca el final de una sección y la muestra. - **@yield('section')** → Muestra el contenido de una sección (si existe, claro). - **@extends('view')** → Hereda de una plantilla padre. - **@parent** → Muestra el contenido de la sección del mismo nombre en la plantilla padre. - **@include('view')** → Incluye una subvista. - **@if | @else | @endif** → Condicional. - **@for | @endfor** → Bucle for clásico. - **@foreach | @endforeach** → Buche foreach. - **@forelse | @empty | @endforelse** → Como foreach, pero con tratamiento de arrays que vienen vacíos. - **@break | @continue** → Para usar en los bucles. - **@switch | @case | @break** → Condicional múltiple. - **@isset($variable) | @endisset** → Comprueba si la variable existe. - **@auth | @endauth** → La sección solo se muestra si hay un usuario autenticado en la aplicación. - **@php | @endphp** → Para añadir código PHP plano. Usar con moderación. - **{% raw %}{{- Comment -}}{% endraw %}** → Comentarios (no serán renderizados). - **{% raw %}{{ $variable }}{% endraw %}** → Equivalente a echo $variable, pero no es necesario abrir y cerrar PHP, y nos protegemos contra inyección de JS. - **{% raw %}{{ $variable ?? texto-por-defecto }}{% endraw %}** → Como el anterior, pero chequea si la variable existe. Si existe, muestra su valor. Si no, muestra texto-por-defecto. - **$loop** → Es una variable muy útil para usar en y/o depurar un foreach. Nos dice si estamos en el primer elemento, en el último, cuántos loops llevamos, etc. ### 5.8.9. Tratamiento de formularios con Blade Blade también facilita el tratamiento de los formularios. En la vista, creamos el formulario (fíjate cómo indicamos la ruta en el action): ```html @csrf Enviar ``` (Recuerda que los métodos PUT y DELETE no existen aún en HTML y que Laravel los simula con un campo oculto en el formulario que se crea con la directiva @method('PUT') o @method('DELETE')) En el enrutador, definimos la ruta \"mi-ruta\" del action del formulario: ```php Route::post('mi-ruta', 'MiControlador@store'); ``` Y, en el controlador, creamos el método store(). Observa cómo recuperamos los datos del formulario a través de la variable $r: ```php public function store(Request $r) { $email = $r->get(\"email\"); $asunto = $r->get(\"asunto\"); ...etc... } ``` Esta es una forma alternativa para el controlador: ```php public function store() { $email = request(\"email\"); $asunto = request(\"asunto\"); ...etc... } ### 5.8.10. Validación de formularios con Blade Otra cosa que Blade facilita muchísimo es la validación de formularios en el lado del servidor. El formulario en nuestra vista quedaría así (observa cómo mostramos los errores -si los hay- con un bucle): ```html @if ($errors->any()) @foreach ($errors->all() as $error) {% raw %}{{ $error }}{% endraw %} @endforeach @endif ...resto del formulario igual... ``` El objeto $errors (disponible en todas las vistas) tiene muchos más métodos útiles que puedes consultar en la documentación de Laravel. Y el controlador quedaría así. Observa cómo definimos varias reglas de validación para campos del formulario: ```php public function store() { request->validate([ 'email' => 'required|email', 'asunto' => 'required' ]); // A partir de aquí, procesar el formulario igual que antes ``` Puedes consultar todas las reglas de validación admitidas en [https://laravel.com/docs/validation](https://laravel.com/docs/validation). Cuando vuelve a cargarse el formulario que contenía un error, suele ser apropiado volver a cargar los datos que el usuario ya había tecleado. A esto se le llama \"repopular\" el formulario, y con Blade se hace así: ```html @if ($errors->any()) @foreach ($errors->all() as $error) {% raw %}{{ $error }}{% endraw %} @endforeach @endif ...resto del formulario igual... ``` ### 5.8.11. Añadir CSS y Javascript a nuestras vistas Laravel ya trae dos archivos (app.css y app.js) basados en Boostrap 4 para empezar a trabajar. Para usarlos, basta con añadir esto a la cabecera de nuestras vistas: ```html | ``` Si queremos añadir reglas CSS, NO debemos editar /public/app.css, porque es un CSS compilado y minimizado con SASS. Lo correcto para añadir nuestro CSS a ese archivo es: 1. Editar /resources/sass/app.css 2. Recompilar este archivo con SASS (o con less o con stylus) ``` $ npm run dev (o también: $ yarn dev) ``` Y, por supuesto, siempre podemos crear nuestro propio CSS y nuestro JS en /public. En ese caso, los archivos no estarían optimizados (tendríamos que hacerlo a mano, si queremos) y serían accesibles de forma pública. El CSS y el JavaScript que vayamos a usar de este modo se pueden colocar en /public/css y /public/js ### 5.8.12. Vistas de error personalizadas Las vistas creadas en /resources/views/errors permiten personalizar fácilmente las pantallas de error HTTP. Por ejemplo, si creas un archivo /resources/views/errors/404.blade.php, esa vista se mostrará cada vez que ocurra un error 404 (página no encontrada) ",
    "url": "/laravel/8",
    "relUrl": "/laravel/8"
  },"45": {
    "doc": "5.8 Vistas y plantillas. Blade",
    "title": "5.8 Vistas y plantillas. Blade",
    "content": "## 5.8. Vistas y plantillas. Blade Blade es un poderoso y sencillo sub-lenguaje que nos permitirá generar plantillas para minimizar el código que necesitamos para nuestras vistas. Las plantillas Blade admiten condiciones y bucles para operar con las variables PHP, de modo que la misma plantilla se comporta de forma diferente con diferentes conjuntos de datos. ¡Y se acabó la pesadilla de abrir y cerrar comillas para concatenar variables a las salidas HTML! Con Blade, ya no será necesario abrir y cerrar php () para operar con las variables del servidor y generar la salida. El código no solo será más limpio y fácil de depurar, sino también más seguro, porque se impiden los ataques con XSS. Además, unas plantillas pueden heredar de otras para reutilizar mejor el código. ### 5.8.1. Master layout El layout es una forma genérica de referirse a un diseño de capas del interfaz de la aplicación. El master layout es el diseño maestro del que derivan todas las vistas. Ese master layout suele almacenarse en un archivo llamado /resources/views/layouts/master.blade.php. Y podría tener, por ejemplo, este aspecto: ```html @yield('Titulo') . @section('sidebar') Este es mi master sidebar. @show @yield('content') . ``` Aquí vemos varias directivas importantes de blade: * @yield('Titulo') --> Esto define una sección llamada 'Título', que en el master layout está vacía. Las vistas que hereden del master layout tendrán que definir cuál es el valor de 'Título', y ese valor aparecerá escrito aquí. * @section('sidebar') --> Esto define una sección llamada 'sidebar' que NO está vacía (contiene el texto \"Este es mi master sidebar\", pero podría contener cualquier otra cosa). Las vistas que hereden del master layout podrán AÑADIR contenido a esta sección. * @show --> Hace que el contenido de la sección se muestre en ese punto del documento. * @yield('content') --> De nuevo, una sección que está vacía en el master layout y cuyo contenido tendrá que definirse en las vistas que hereden de esta. ### 5.8.2. Vistas que heredan del master layout El aspecto de una plantilla que herede del master layout anterior debería ser este: ```html @extends('master') @section('title', 'Titulo de la página') @section('sidebar') Esto se añadirá al master sidebar. @endsection @section('content') Aquí va el contenido de mi página. @endsection ``` * @extends('master') --> Esto indica que esta vista hereda del master layout. * @section('title, 'Título de la página') --> Aquí se define el contenido de la sección 'Título' que en el master layout estaba vacía. * @section('sidebar') --> Aquí añade contenido a la sección 'sidebar', que en el master layout no estaba vacía. * @ensection --> Se emplea cuando el contenido de una sección ocupa varias líneas de código y no es posible escribirlo dentro de la propia directiva. ### 5.8.3. Cómo pasar variables a las vistas Las variables a las vistas deben enviarse empaquetadas en un array. Hay varias formas de lograr esto, todas ellas correctas. Puedes emplear la que te resulte más cómoda o más elegante: ```php return view('vista', array('variable1'=>'valor', 'variable2'=>'valor')); return view('vista', ['variable1'=>'valor', 'variable2'=>'valor']); return view('vista')->with(['variable1'=>'valor', 'variable2'=>'valor']); return view('vista', compact('variable1', 'variable2')); ``` ### 5.8.4. Cómo usar las variables en las vistas Supongamos que tenemos este método en un controlador: ```php function show() { return view('page',array('name' => 'Manolo Escobar')); } ``` La variable $name se puede usar en la vista /resources/views/page.blade.php de este modo: ```html @extends('layouts.master') @section('title', 'Page Title') @section('sidebar') Esto se añadirá al sidebar del master layout. @endsection @section('content') ",
    "url": "/laravel/8",
    "relUrl": "/laravel/8"
  },"46": {
    "doc": "5.9 Controladores",
    "title": "5.9 Controladores",
    "content": "## 5.9. Controladores ### 5.9.1. Cuatro cosas importantes sobre los controladores en Laravel Los controladores en Laravel heredan de la clase Controller. Su nombre debería escribirse en singular, CamelCase y terminando en la palabra Controller. Por ejemplo: UserController, LoginController, ArticleController Cada método del controlador debe terminar en un return. Lo que el método devuelva será convertido automáticamente en una HTTP response 200, excepto si es un array, en cuyo caso se convertirá automáticamente en JSON. Se puede actuar sobre la HTTP response devolviendo esto: ```php return response('contenido', 201) ->header('mi-cabecera', 'contenido') ->header('otra-cabecera', 'más-contenido') ->cookie('mi-cookie', 'valor'); (etc) ``` ### 5.9.2. Tres formas de crear un controlador **Forma 1. Crear un controlador vacío.** Por ejemplo, para crear un controlador para la tabla de usuarios: ``` $ php artisan make:controller UserController ``` **Forma 2. Crear un controlador de tipo resource.** Estos controladores se generan automáticamente con un andamiaje para construir recursos REST. Es decir, la clase ya llevará incorporados los métodos index(), create(), store(), show(), edit(), update() y destroy() del estándar REST. Para crear un controlador así: ``` $ php artisan make:controller UserController --resource ``` No te olvides de de añadir al enrutador (/routes/web.php) las rutas REST para este tipo controlador. Se pueden resumir las siete rutas en esta sola entrada del enrutador: ``` Route::resource('nombreRecurso', 'controlador'); ``` En nuestro ejemplo: ``` Route::resource('usuarios', 'UserController'); ``` **Forma 3. Crear un controlador tipo API.** El controlador tipo API es como un resource, pero sin create() ni edit(), porque una API no necesita mostrar los formularios de inserción/modificación. ``` $ php artisan make:controller UserController --api ``` De nuevo, no te olvides de las entradas en el enrutador. Puedes englobarlas todas en una sola entrada con este aspecto: ``` Route::apiResource('usuarios', 'UserController'); ``` ",
    "url": "/laravel/9",
    "relUrl": "/laravel/9"
  },"47": {
    "doc": "8.1 CGI",
    "title": "8.1 CGI",
    "content": "## 8.1. Common Gateway Interface (CGI) CGI es la solución más antigua para el desarrollo web en el lado del servidor. En la década de 1990, cuando se empezó a pensar en la posibilidad de crear página dinámicas generadas por el servidor a partir de los recursos del mismo (típicamente, una base de datos), los primeros intentos utilizaron las tecnologías presentes en ese momento en los servidores web. Todos los servidores tenían un compilador de C/C++, así que alguien pensó: ¿por qué no escribimos las aplicaciones web en C/C++, las compilamos y hacemos que el ejecutable se pueda invocar vía web? Para lograr esto último, se utilizó CGI (Common Gateway Interface). CGI es una interfaz entre los servidores web y las aplicaciones que se ejecutan en el servidor. Estas aplicaciones pueden estar construidas en cualquier lenguaje (no solo C/C++). A CGI, eso le da igual. Solo define la forma de transferir información en ambos sentidos. La figura siguiente muestra la forma en la que se ejecutan programas en el servidor a través de CGI. Si lo observas con atención, verás que no difiere demasiado de la forma en la que trabaja PHP, porque cualquier petición tiene 4 pasos: 1. Se recibe la petición de un cliente web. 2. El servidor web recibe la peticion y, a través del interfaz CGI, le pide al sistema operativo que ejecute el programa correspondiente. 3. La salida del programa se redirige al servidor web. De esto se encarga, nuevamente, el interfaz CGI. 4. El servidor devuelve al cliente el resultado de la ejecución del programa. XXX esquema ### 8.1.1. Entonces, ¿en qué se diferencia CGI de PHP? Lo primero, CGI no es un lenguaje de programación. Eso ya lo hemos dicho. Es un ***interfaz*** entre el servidor web y el sistema operativo para poder ejecutar cualquier programa escrito en cualquier lenguaje a través de la web. Puede parecer una solución perfecta, ¿verdad? Pero, si fuera así, ¿por qué no se sigue usando de forma masiva? ¿Por qué se abandonó en favor de PHP u otros de los lenguajes que vamos a ver más adelante? La respuesta breve es: CGI tiene un serio problema de rendimiento. Cada vez que se recibe una petición de un cliente, se crea un nuevo proceso en el servidor para ejecutar el programa en cuestión. Este proceso necesita un espacio de memoria para colocar su código fuente y sus datos, y esto recursos solo se liberan cuando el servidor termina de responder al cliente. Esta creación de procesos independientes implica una carga importante para el servidor, por lo cual esta modalidad de generación de contenido dinámico no es muy escalable. Por su parte, PHP (y otras soluciones que veremos más adelante) no crean un proceso independiente para cada petición recibida, sino que un mismo macro-proceso se encarga de gestionarlas todas. En términos de escalabilidad, esta opción es mucho mejor. Así que, cuando los servidores empezaron a recibir muchas visitas simultáneas, CGI comenzó a abandonarse. Sencillamente, ningún servidor podía soportar grandes volúmenes de peticiones. Existen algunas alternativas para solucionar este problema de CGI, como mantener un sólo proceso CGI en memoria que se encargue de procesar todas las peticiones (técnica conocida como FastCGI y que, de hecho, se sigue utilizando en la actualidad, incluso para ejecutar PHP en el servidor), pero resulta más complejo de configurar y operar, e implica algunos problemas de seguridad. En cualquier caso, estos detalles de configuración del servidor son cosas que competen más a los administradores de sistemas que a los desarrolladores. ",
    "url": "/otros/cgi",
    "relUrl": "/otros/cgi"
  },"48": {
    "doc": "8.2 Perl",
    "title": "8.2 Perl",
    "content": "## 8.2. Perl A partir de este punto, veremos varios lenguajes alternativos a PHP (es decir, su \"competencia\") siguiendo siempre el mismo esquema: * Primero, enumeraremos las características y filosofia del lenguaje. * Luego explicaremos a grandes rasgos cómo hay que configurar el servidor para poder usar ese lenguaje para desarrollo web. * Después mostraremos la sintaxis básica del lenguaje. * Por último, escribiremos dos ejemplos completos en cada lenguaje: un sencillo \"hola, mundo\" y un programa algo más complejo que lanza una validación de login mediante ajax. En este segundo caso, la parte del cliente será siempre la misma, y solo cambiaremos la parte del servidor. Eso te permitirá apreciar las diferencias entre unos lenguajes y otros. Enseguida te darás cuenta de que esas diferencias son mínimas. ### 8.2.1. Características del lenguaje Perl Fecha de aparición: 1987. Perspectivas: * Uso decreciente. * Apto para tareas pequeñas y rápidas. * Cuenta con desarrolladores muy fieles y experimentados. Documentación muy extensa. * Soporte amplio en cualquier servidor. Filosofía de Perl: * Versión mejorada del shell scripting de Unix. * Pensado para procesamiento rápido de archivos de texto y automatización de tareas de administración del sistema. * Favorece la programación ágil, rápida y sucia de scripts. * Énfasis en las expresiones regulares. * Multiparadigma. * En combinación con CGI, se popularizó para aplicaciones web antes de la aparición de PHP. ### 8.2.2. Configuración necesaria en el servidor Para utilizar Perl en un servidor Apache o similar, necesitaremos: 1. Instalar el intérprete Perl (usr/bin/perl). 2. Activar los módulos perl y/o cgi de Apache y configurar el handler para CGI. 3. Instalar módulos Perl adicionales para acceso a bases de datos, etc. Se puede ejecutar el intérprete Perl de forma nativa en Apache, o bien hacerlo a través de CGI. Lo primero es más difícil de configurar y raramente se encuentra en hostings web compartidos. ### 8.2.3. Sintaxis básica de Perl Las variables en Perl no se declaran, tienen tipado dinámico y son globales por defecto. ```perl $var = valor; print \"La variable var vale $variable\"; ``` Algunos operadores: * Comparación: lt, gt, le, ge, eq, ne... * Asignación: = Algunas estructuras de control: ```perl while (condicion) { Acciones } if (condicion) { Acciones-1 } else { Acciones-2 } ``` ### 8.2.4. Entrada / salida Entrada de datos estándar: ```perl chop ( $variable = ); ``` Lectura de datos desde un formulario HTML: ```perl use CGI; my $cgi = CGI->new; my $username = $cgi->param(\"username\"); ``` Salida: ```perl print \"cadena $variable cadena...\"; ``` ### 8.2.5. Bibliotecas, funciones y clases Para utilizar una biblioteca o ***package***, como se denominan en Perl, se emplea la palabra **use**: ```perl use nombre-biblioteca; ``` Las bibliotecas se empaquetan en archivos con extensión .pm (***Perl Modules***). Dentro de ellas, puede haber una colección de funciones o métodos que se declaran así: ```perl package nombre-biblioteca; Sub nombre-funcion (argumentos) { Acciones } ``` Estas funciones pueden usarse desde fuera de la biblioteca con esta sintaxis: ```perl use nombre-biblioteca; nombre-biblioteca::nombre-funcion(argumentos); ``` Los ***packages*** también pueden usarse para construir clases (o algo parecido) de las que luego se pueden instanciar objetos. Más o menos así: ```perl package nombre-de-la-clase; sub new { # Este es el método constructor my $self = {}; # Array para los atributos $self->{VAR1} = 0; # Un atributo $self->{VAR2} = 9; # Otro atributo } sub otro-método{ # Aquí van el resto de métodos de la clase } sub DESTROY { # Método destructor } 1 # Para que el intérprete Perl no se queje al interpretar este archivo ``` Como puedes observar, Perl está lleno de peculiaridades que muchos consideran anticuadas o, como mínimo, poco elegantes. Observa si no la forma que tiene de crear los atributos de instancia, los caprichosos nombres de los métodos (a veces en minúscula, a veces en mayúscula) o la necesidad de terminar el ***package*** con un 1 para que el intérprete Perl lo considere un script válido. Por último, para instanciar un objeto de esta clase: ```perl use nombre-de-la-clase; $objeto = nombre-de-la-clase->new(); ``` ### 8.2.6. Ejemplo 1 en Perl: Hola mundo ```perl #!/usr/bin/perl print \"Content-type: text/html\\n\\n\"; print \"Hola mundo\"; print \"Hola, mundo\"; print \" . \"; ``` ### 8.2.7. Ejemplo 2 en Perl: login con comprobación de email por Ajax Este segundo ejemplo, como hemos explicado más arriba, consistirá en un formulario de login que comprobará el nombre de usuario y la contraseña mediante una petición Ajax. #### Formulario HTML El formulario de login es un simple código HTML que será idéntico en todos los ejemplos que veremos en el resto de este capítulo, así que solo lo mostraremos aquí por primera vez. ```html Nombre de usuario . Contraseña . Login . ``` #### Script jQuery El script que lanza la petición Ajax (cuyo código puede ir en el mismo archivo que el formulario) será ***casi*** idéntico en todos los ejemplos: solo cambiará el nombre del script al que se lanza la petición. En nuestro caso actual, es script lo hemos llamado **login.pl** (la extensión .pl denota que se trata de un script escrito en lenguaje Perl). Como es lógico, en ejemplos posteriores, tendrías que cambiar el nombre de ese archivo por el que corresponda (login.py si estamos usando Python, login.rb si estamos usando Ruby, etc). Para no repetirnos innecesariamente, no volveremos a mostrar tampoco el código de este script en los ejemplos sucesivos. Observa que Javascript está esperando que el servidor responda con un JSON que puede llevar estos tres datos en su interior: * data.error: Un string con un texto de error en caso de que el usuario o la contraseña sean incorrectos. * data.success: Un string con un texto de éxito en caso de que el usuario y la contraseña sean correctos. * data.userId: Un entero con el ID del usuario logueado (solo en caso de éxito). ```javascript $(document).ready(function(){ $(\"form#loginForm\").submit(function() { var username = $('#username').attr('value'); // Obtenemos el username var password = $('#password').attr('value'); // Obtenemos la password if (username && password) { // Los valores de username y password no están vacíos $.ajax({ type: \"GET\", url: \"login.pl\", dataType: \"json\", data: \"username=\" + username + \"&password=\" + password, success: function(data){ if (data.error) { // El servidor ha devuelto un error de login $('div#loginResult').text(\"data.error: \" + data.error); $('div#loginResult').addClass(\"error\"); } else { // El servidor ha hecho el login correctamente $('form#loginForm').hide(); $('div#loginResult').text(\"data.success: \" + data.success + \", data.userid: \" + data.userid); $('div#loginResult').addClass(\"success\"); } } }); } else { $('div#loginResult').text(\"Debe escribir su nombre de usuario y su contraseña\"); $('div#loginResult').addClass(\"error\"); } $('div#loginResult').fadeIn(); return false; }); }); ``` #### Script Perl en el lado del servidor (login.pl) Este sería el script en Perl que respondería a la petición Ajax anterior. Observa que, a pesar de la peculiar sintaxis de Perl, la estructura del algoritmo es idéntica a la que usaríamos si lo escribiéramos en PHP: 1. Recuperamos los datos del formulario (username y password) 2. Conectamos con la base de datos 3. Lanzamos la consulta contra la tabla de usuarios 4. En función del resultado de la consulta, preparamos nuestro JSON de respuesta al cliente 5. Devolvemos el JSON al cliente ```perl #!/usr/bin/perl -T use CGI; use DBI; use strict; use warnings; # read the CGI params my $cgi = CGI->new; my $username = $cgi->param(\"username\"); my $password = $cgi->param(\"password\"); # connect to the database my $dbh = DBI->connect(\"DBI:mysql:database=mydb;host=localhost;port=2009\", \"mydbusername\", \"mydbpassword\") or die $DBI::errstr; # check the username and password in the database my $statement = qq{SELECT id FROM users WHERE username=? and password=?}; my $sth = $dbh->prepare($statement) or die $dbh->errstr; $sth->execute($username, $password) or die $sth->errstr; my ($userID) = $sth->fetchrow_array; # create a JSON string according to the database result my $json = ($userID) ? qq{{\"success\" : \"login is successful\", \"userid\" : \"$userID\"}} : qq{{\"error\" : \"username or password is wrong\"}}; # return JSON string print $cgi->header(-type => \"application/json\", -charset => \"utf-8\"); print $json; ``` ",
    "url": "/otros/perl",
    "relUrl": "/otros/perl"
  },"49": {
    "doc": "8.3 Python",
    "title": "Hola, mundo",
    "content": "\" print \" . \" ``` ### 8.3.7. Ejemplo 2 en Python: login con comprobación de email por Ajax Repetimos ahora el ejemplo del login con comprobación de usuario y contraseña mediante Ajax, pero no mostraremos de nuevo el código del formulario ni de la llamada Ajax. Para ver ese código, revisa la sección que dedicamos al lenguaje Perl. Allí solo tendrás que cambiar el nombre del script (login.pl) por login.py. El código de ese script sí que cambia, claro. Esta es la versión del mismo escrita en Python: ```python #!/usr/bin/python import cgi import MySQLdb # Capturamos los valores del formulario form = cgi.FieldStorage() usuario = form[\"username\"].value; password = form[\"password\"].value; print \"Usuario = \", usuario, \" Pass = \", password # Lanzamos la consulta contra la base de datos db=MySQLdb.connect(host='localhost', user='yo-que-sé', passwd='vete-a-saber', db='lo-que-sea') cursor=db.cursor() num_rows = cursor.execute(\"SELECT id FROM users WHERE username = '%s' AND password = '%s';\", (usuario, password)) userid = cursor.fetchone() # Devolvemos el resultado en JSON print \"Content-type: application/json\\n\" if num_rows == 0: print \"{'error': 'Usuario o contraseña incorrectos'}\" else: print \"{'success': 'El usuario y la contraseña son válidos', 'userid': '%d'\", userid ``` ",
    "url": "/otros/python",
    "relUrl": "/otros/python"
  },"50": {
    "doc": "8.3 Python",
    "title": "8.3 Python",
    "content": "## 8.3. Python ### 8.3.1. Características del lenguaje Python Fecha de aparición: 1991 Perspectivas: * Uso creciente. * Es el sustituto natural de Perl para el desarrollo rápido de scripts. * También usado en grandes proyectos como alternativa a PHP. * Menos extendido que PHP, pero comunidad con muchos desarrolladores profesionales (mejor relación señal/ruido) * Muchas bibliotecas de terceros → flexibilidad Filosofía: * Es la versión “limpia” de Perl. Pensado para escribir scripts de forma rápida y limpia. * Énfasis en la legibilidad: Python es casi pseudocódigo (código “pythonico” → v. “El Zen de Python”) * Interpretado. Tipado dinámico. Fuertemente tipado. * Expresiones regulares heredadas de Perl. * Multiparadigma: imperativo, O.O., funcional. ### 8.3.2. Configuración necesaria en el servidor Para hacer funcionar Python en un servidor Apache o similar, es necesario: 1. Instalar el intérprete Python (/usr/bin/python). El más extendido es CPhyton. 2. Activar los módulos python y/o cgi de Apache y configurar el handler de Apache para CGI. 3. Instalar módulos adicionales (p. ej: para acceso a bases de datos) si es necesario. Python puede funcionar de forma nativa integrado en Apache o a través de CGI. Lo primero es más rápido; lo segundo, más frecuente. ### 8.3.3. Sintaxis básica de Python Las variables en Python no se declaran obligatoriamente: tienen tipado dinámico y son locales por defecto. ```python varariable = valor; print \"La variable var vale %s\" (variable); ``` En Python hay muchos tipos de datos complejos predefinidos: listas, tuplas, diccionarios... Algunos operadores son: * Comparación: , =, ==, != * Asignación: = Y estas son algunas estructuras de control. **¡Cuidado! ¡El código debe indentarse OBLIGATORIAMENTE!** No existen las llaves ({ y }) en Python. ¡La indentación (o sangrado) marca los bloques! ```python while condicion: Acciones if condicion: Acciones-1 else: Acciones-2 ``` ### 8.3.4. Entrada / Salida La entrada de datos por teclado puede hacerse con raw_input(): ```python variable = raw_input(\"Texto\") ``` Pero a nosotros nos interesa hacer entrada de datos a través de un formulario HTML. Esto se hace así: ```python import cgi form = cgi.FieldStorage() campo = form[\"campo\"].value ``` En cuanto a la salida de datos, se usa ***print*** con cadenas de formato, seguida de una lista de variables. Cada elemento de la cadena de formato marcado con un % se sustituirá por una variable de la lista, en el mismo orden en el que estén escritas. Por ejemplo: ```python print \"cadena %s cadena %s ...\" (variable1, variable2) ``` El símbolo %s significa que en esa posición irá un String. Otras posibilidades son %d (enteros) o %f (float). Esta forma de especificar las cadenas de formato está directamente tomada del lenguaje C. En Python existen muchas otras formas de hacer una salida de datos, pero ***print*** es lo suficientemente potente como para que puedas utilizarla para cualquier cosa imaginable en una aplicación web. ### 8.3.5. Bibliotecas, funciones y clases En Python hay tres niveles de agrupación de bibliotecas: * Módulos: un módulo es un fichero con código Python en su interior. Puede ser una clase o un puñado de funciones sueltas, por ejemplo. * Paquetes (*packages*): un paquete es un directorio que contiene varios módulos. También puede contener subpaquetes. Los paquetes se instalan y desinstalan con un gestor de paquetes (como *pip*, que viene a ser como *composer* en PHP). * Bibliotecas (*libraries*): una biblioteca es cualquier fragmento de código reutilizable que se puede incluir en otros proyectos. Las bibliotecas pueden ser paquetes o no. Existe una *Python Standard Library* que contiene todas las funciones básicas de Python y viene preinstalada con el *core* del lenguaje. Podemos incluir una librería en nuestro proyecto Python usando la palabra *import*: ```python import mi-librería ``` Como hemos dicho, dentro de cada módulo puede haber clases o subrutinas sueltas. Una subrutina (procedimiento o función) se declara así en Python (observa de nuevo como la indentación o sangrado es fundamental porque marca el comienzo y final de los bloques de código): ```python def mi-funcion(param1, param2, etc): # Aquí va el código de la función [return valor1, varlor2...] ``` En cuanto a las clases, la sintaxis para declararlas y muy similar a PHP, Java o C++ (recordando que, en Python, no se usan las llaves sino la indentación): ```python class MyClass: un_atributo = valor otro_atributo = valor # Esto es un constructor def __init__(self): self.un_atributo = 0 def un_metodo(parámetros): return lo_que_sea ``` ### 8.3.6. Ejemplo 1 en Python: Hola mundo ```python #!/usr/bin/python print \"Content-type: text/html\\n\\n\" print \"\" print \" ",
    "url": "/otros/python",
    "relUrl": "/otros/python"
  },"51": {
    "doc": "8.4 .NET",
    "title": "Hola, mundo",
    "content": "\") response.write(\" . \") %> ``` ### 8.4.7. Ejemplo 2 en VBasic: login con comprobación de email por Ajax Como antes, no mostraremos el código del lado del cliente (formulario + solicitud Ajax). Si quieres repasar ese código, lo encontrarás en la sección correspondiente al lenguaje Perl. Lo que sí encontrarás aquí es el código de login.asp, el script escrito en VB.NET que realiza la consulta a la base de datos para comprobar si el login es correcto y devuelve el resultado formateado en JSON. ```asp ``` ",
    "url": "/otros/.net",
    "relUrl": "/otros/.net"
  },"52": {
    "doc": "8.4 .NET",
    "title": "8.4 .NET",
    "content": "## 8.4.NET ### 8.4.1. Características de .NET Fecha de aparición: 1996 (ASP) / 2002 (.NET) Perspectivas: * .NET es la alternativa de Microsoft a JSP para desarrollo de grandes proyectos, donde PHP, Python o Ruby se quedan (o eso dicen desde Microsoft) pequeños. * .NET no es un lenguaje de programación, sino el conjunto de toda la tecnología de servidor de Microsoft para desarrollar aplicaciones web. Esa tecnología se puede usar con varios lenguajes. Los más habituales con Visual Basic .NET (conocido como VB.NET) y C#. * Tiene componentes exclusivos en el servidor y altas prestaciones. * Su coste es más elevado. * Hay que sufrir los problemas de seguridad endémicos a los productos Microsoft. Filosofía: * Framework de código cerrado y propietario. * Tecnología multilenguaje. Suele correr con VB.NET o C#. * Puede funcionar como PHP, embebido dentro de HTML. * Incluye controles de servidor exclusivos de Microsoft (equivalentes a los ActiveX del lado del cliente) ### 8.4.2. Configuración necesaria en el servidor Para hacer funcionar una aplicación .NET es necesario tener un servidor con sistema operativo Windows Server, que tiene integrado Microsoft IIS (Internet Information Server). También puede ejecutarse con un módulo de apache (llamado *mono*), pero es mucho más lento. Cada solución requiere su propio servidor. Si quieres PHP, Python o Ruby, usa Apache. Si quieres JSP, usa Tomcat. Si quieres ASP, usa IIS. Así te evitarás problemas. ### 8.4.3. Sintaxis básica de .NET con VB.NET El código VB.NET (como el de C#) se puede embeber en HTML de este modo: ```html ... Este texto se ha generado desde HTML ``` No es necesario declarar las variables de tipo simple, pero puede hacerse: ```vb Dim i,j,k As Integer ``` Los operadores son los habituales, excepto el de asignación, que se escribe con un solo igual. Las posibles ambigüedades con el operador de comparación se resuelven por el contexto: * Operadores de comparación: , =, =, * Operadores de asignación: = Y estas son algunas estructuras de control: ```vb Do While (condicion) Acciones Loop For variable As Integer = 1 To 5 Acciones Next If (condicion) Then Acciones-1 Else Acciones-2 End If ``` ### 8.4.4. Entrada / Salida Para leer los datos procedentes de un formulario debemos recurrir al objeto predefinido *request*: ```vb // Leer datos de un formulario (GET): variable = request.QueryString(\"campo\"); // Leer datos de un formulario (POST): variable = request.Form(\"campo\"); ``` La salida de datos se hace con *response.write()*: ```vb response.write (\"cadena\" + variable + \"cadena2\"); ``` ### 8.4.5. Bibliotecas, funciones y clases Con VB.NET (o C#) se pueden crear bibliotecas de clases de forma visual desde el propio entorno de programación de .NET. Las clases en VB.NET se definen de forma muy parecida a Java o PHP: ```vb class MiClase Inherits ClaseMadre Dim int UnAtributo; Dim bool OtroAtributo; Function MiMetodo(parametros) As tipo // Aquí va el código del método return valor; End Function End Class ``` Para utilizar una librería (estándar o de terceros) se utiliza la directiva @Import: ```vb @Import Namespace=\"Biblioteca\" ``` Por último, se pueden definir subrutinas independientes (funciones o métodos) con esta sintaxis: ```vb Sub NombreMétodo(parametros) Acciones; End Sub ``` ### 8.4.6. Ejemplo 1 en VBasic: Hola mundo ```asp \") response.write(\" ",
    "url": "/otros/.net",
    "relUrl": "/otros/.net"
  },"53": {
    "doc": "8.5 JSP",
    "title": "Hola, mundo",
    "content": "\"); out.println(\" . \"); %> ### 8.5.7. Ejemplo 2 en JSP: login con comprobación de email por Ajax Nuevamente, mostraremos solo el script del lado del sevidor (login.jsp). El código del lado del cliente lo tienes disponible en la sección que dedicamos al lenguaje Perl, donde solo tendrás que cambiar la referencia a \"login.pl\" por \"login.jsp\". ```jsp ``` ",
    "url": "/otros/jsp",
    "relUrl": "/otros/jsp"
  },"54": {
    "doc": "8.5 JSP",
    "title": "8.5 JSP",
    "content": "## 8.5. JSP ### 8.5.1. Características del lenguaje JSP Fecha de aparición: 1995 Perspectivas: * Usado para proyectos grandes y complejos, donde PHP (y otros lenguajes de scripting) se quedan pequeños. O eso aseguran los chicos de Oracle, claro. * El lenguaje de programación es Java, es decir, lo conoce cualquier programador. * Velocidad de ejecución superior a la de otros lenguajes semi-interpretados. Filosofía: * Adaptación natural de Java al lado del servidor. * Orientado a objetos. Multiplataforma. Fuertemente tipado. * Puede embeberse dentro de HTML, como PHP. * El código Java se precompila en un Servlet y se deja cargado en la memoria del servidor. Las peticiones subsiguientes se ejecutan así de forma más rápida. Este enfoque está siendo adoptado por otras tecnologías del lado del servidor, como NodeJS o algunos frameworks basados en otros lenguajes, que *precompilan* las vistas para servirlas mucho más deprisa. ### 8.5.2. Configuración necesaria en el servidor Para ejecutar Java en el lado del servidor, lo más apropiado es instalar Tomcat. Es el servidor de referencia para la tecnología JSP. Apache Tomcat es un servidor web capaz de contener y servir los servlets de Java. Implementa todos los servicios necesarios para que JSP funcione correctamente. Existen otros servidores, como JBoss o Embarcadero, pero Tomcat continúa siendo el más extendido en la actualidad. Como se ejecuta sobre la máquina virtual de Java, es posible hacerlo funcionar en cualquier sistema operativo. Otras soluciones, como ejecutar JSP a través de CGI en un servidor web convencional, son técnicamente viables pero resultan mucho más lentas. ### 8.5.3. Sintaxis básica de JSP El código JSP se embebe en HTML de este modo: ```html ... Este texto se ha generado desde HTML . ``` Las variables se declaran como en cualquier programa Java. Por ejemplo: ```java int var = 5; out.print(\"La variable var vale \" + var); ``` Estos son los operadores más habituales: ```java Comparación: , =, ==, != Asignación: = ``` Y estas son algunas estructuras de control: ```java while (condicion) { Acciones; } if (condicion) { Acciones-1; } else { Acciones-2; } ``` ### 8.5.4. Entrada / Salida La entrada de datos a través de un formulario HTML se hace usando el objeto request, que estará precargado en cualquier Servlet. La salida se puede hacer con un simple System.out.println(): ```java // Leer datos de un formulario: variable = request.getParameter(\"campo\"); // Salida: System.out.println (\"cadena\" + variable + \"cadena2\"); ``` ### 8.5.5. Bibliotecas, clases y métodos La forma de escribir clases y métodos en JSP es la misma que en Java, como es lógico. No vamos a explicar aquí todas las peculiaridades del lenguaje, que son muchas y pintorescas. Solo recordaremos que, en Java, no pueden existir métodos fuera de las clases, porque es un lenguaje orientado a objetos bastante estricto. La sintaxis para declarar una clase, sus atributos y sus métodos es esta: ```java class MiClase extends ClaseMadre { public|private|protected tipo atributo; public|private|protected tipo nombre(params) { Acciones; } } ``` Cada clase debe ir en un archivo independiente con el mismo nombre que la clase que contiene. Las clases de Java pueden agruparse en paquetes (*packages*). La forma de importar un paquete para usar sus clases en nuestro programa es: ```java import paquete; // Esto importa el paquete completo import paquete.clase; // Esto importa solo una clase del paquete ``` Pero cuidado, cuando se trabaja con JSP existe una pequeña diferencia en la forma de importar paquetes: en lugar de la sentencia *import*, se debe emplear una directiva del precompilador. Las directivas son instrucciones para el precompilador de Java que modifican su modo de proceder durante la compilación. Todas las directivas empiezan por el símbolo \"@\". En el caso concreto de la importación de paquetes o clases en un script JSP, la directiva que debemos emplear es: ```jsp ``` ### 8.5.6. Ejemplo 1 en JSP: Hola mundo \"); out.println(\" ",
    "url": "/otros/jsp",
    "relUrl": "/otros/jsp"
  },"55": {
    "doc": "8.6 Ruby",
    "title": "Hola, mundo",
    "content": "\" print \" . \" ``` ### 8.6.7. Ejemplo 2 en Ruby: login con comprobación de email por Ajax Una vez más, solo mostraremos el script del lado del servidor (login.rb). Para revisar el código del lado del cliente, puedes acudir a la sección dedicada al lenguaje Perl, y sustituir la referencia al script login.pl por login.rb. El resto del código permanecerá idéntico. ```ruby #!/usr/bin/ruby require \"mysql\" require \"cgi\" begin # Conexión con la base de datos con = Mysql.new 'server', 'db-user', 'db-password', 'db-name' # Recuperamos la información del formulario HTML cgi = CGI.new name = cgi[\"username\"] pass = cgi[\"password\"] # Consultamos la base de datos res = con.query(\"SELECT id FROM users WHERE user = '#{name}' AND password = '#{pass}'\") # Generamos la salida JSON para el cliente print \"Content-type: application/json\\n\\n\" if res.num_rows == 0 print %Q!{\"error\": \"Username or password not valid\"}! else row = res.fetch_hash print %Q!{\"success\": \"Authentication is OK\", \"userid\": \"#{row['id']}\" }! end con.close if con end ``` ",
    "url": "/otros/ruby",
    "relUrl": "/otros/ruby"
  },"56": {
    "doc": "8.6 Ruby",
    "title": "8.6 Ruby",
    "content": "## 8.6. Ruby ### 8.6.1. Características del lenguaje Ruby Fecha de aparición: 1995 Perspectivas: * Uso y popularidad creciente. * Base de programadores fiel y especializada. * Excelente relación señal/ruido. * Aún tiene algunos problemas por resolver: El lenguaje todavía está en fase de importantes cambios, tiene peor rendimiento que Python o PHP y muchos módulos (gemas) están mal documentados. Filosofía: * Completa –y verdaderamente– orientado a objetos. Todo es un objeto. * Admite otros paradigmas ocultos bajo los objetos. * “Rápido y fácil”. Es un lenguaje divertido: de programadores para programadores. * Curva de aprendizaje larga pero nunca abrupta. * Potente sistema de expresiones regulares. * En combinación con Rails, ideal para desarrollo web MVC rápido y basado en prototipos. #### ¿Y Ruby on Rails? Rails, también conocido como *Ruby-on-rails*, es un framework para desarrollar aplicaciones web MVC con Ruby. Apareció en 2004 y gustó tanto que otros frameworks para otros lenguajes (como Laravel para PHP) se han inspirado en su forma de trabajar: abundantes capas de abstracción para evitar tareas de bajo nivel, *scaffolding*, integración con Ajax, *Convention over Configuration* (CoC) y *Don't Repeat Yourself* (DRY). Rails se hizo tan famoso que mucha gente, aún hoy en día, confunde el lenguaje (Ruby) con el framework (Ruby on Rails). ### 8.6.2. Configuración necesaria en el servidor Para poder ejecutar scripts en Ruby en un servidor web Apache o similar, necesitarás: * Instalar el intérprete Ruby en el sistema. * Instalar el módulo de Ruby (mod_ruby) y/o el módulo cgi (mod_cgi) para Apache. * Configurar el manejador de Apache para CGI. * Instalar módulos adicionales para Ruby (como cgi o mysql) si son necesarios. Como en el caso de Perl o Python, Ruby puede correr de forma nativa en Apache (más rápido pero menos frecuente) o como script CGI. ### 8.6.3. Sintaxis básica de Ruby En Ruby, no es necesario declarar las variables. El tipado es dinámico (tipo *duck*: si anda como un pato y parece un pato, es que es un pato). Todo es un objeto en este lenguaje, incluso números enteros o los valores constantes, lo cual conduce a expresiones chocantes como estas: ```ruby 5.isEven? \"cadena\".lenght variable_cadena.chop! ``` Ruby está lleno de convenciones para evitar tener que llenar la documentación de explicaciones innecesarias (a esto se le llama \"filosofía CoC\" = *Convention over Configuracion*). Por ejemplo: * Es una convención que todos los métodos cuyo nombre termine en una interrogación, deben devolver un booleano. En el ejemplo anterior, el método *isEven* es uno de ellos. * Otra convención es que todos los métodos cuyo nombre termine en una admiración, modificarán irreversiblemente el objeto con el que se invocan. En el ejemplo anterior, el método *chop!* troceará la cadena cada vez que encuentre un espacio en blanco en su interior, convirtiéndola en un array de cadenas. Los operadores de Ruby son los habituales: ```ruby Comparación: ==, , =, =, != Asignación: = ``` Las estructuras de control también te resultarán familiares. No se utilizan llaves ({...}) para marcar los bloques, sino que cada bloque finaliza con la palabra *end*. El sangrado es optativo pero, por supuesto, muy recomendable. ```ruby while condicion Acciones end if condicion Acciones-1 else Acciones-2 end ``` Sin embargo, el uso de bucles clásicos casi siempre puede sustituirse por iteradores sobre objetos, algo cada vez más frecuente en los lenguajes orientados a objetos: ```ruby variable_array.do_each ... end num_rows.times do ... end ``` ### 8.6.4. Entrada / Salida La entrada de datos a través de un formulario HTML se hace usando un objeto de la clase CGI. La salida, con una sencilla sentencia *print*: ```ruby // Leer datos de un formulario require \"cgi\" cgi = CGI.new variable = cgi[\"campo\"]; // Salida de datos print \"cadena\", variable, \"cadena2\", ... ``` ### 8.6.5. Bibliotecas, clases y métodos Las clases en Ruby se declaran de forma muy semejante a Python (observa cómo el símbolo \"\" print \" ",
    "url": "/otros/ruby",
    "relUrl": "/otros/ruby"
  },"57": {
    "doc": "8.7 NodeJS",
    "title": "8.7 NodeJS",
    "content": "## 8.7. NodeJS TODO ### 8.7.1. Características del lenguaje NodeJS Fecha de aparición: XXX Perspectivas: * TODO Filosofía: * TODO ### 8.7.2. Configuración necesaria en el servidor TODO ### 8.7.3. Sintaxis básica de NodeJS TODO ### 8.7.4. Entrada / Salida con NodeJS TODO ### 8.7.5. Bibliotecas, funciones y clases TODO ### 8.7.6. Ejemplo 1 en NodeJS: Hola mundo TODO ### 8.7.7. Ejemplo 2 en NodeJS: login con comprobación de email por Ajax TODO ",
    "url": "/otros/nodejs",
    "relUrl": "/otros/nodejs"
  },"58": {
    "doc": "8.8 Más tecnologías aún",
    "title": "8.8 Más tecnologías aún",
    "content": "## 8.8. Y otras tecnologías aún más extrañas Además de los lenguajes que hemos visto, existen otras alternativas a PHP para desarrollar aplicaciones web en el lado del servidor. A continuación mostramos una lista con alguna de estas alternativas (no están todas las que son, pero sí son todas las que están) para quien quiera profundizar aún más en el asunto: ### 8.2.1. ColdFusion ColdFusion es la alternativa de Adobe. ColdFusion es al mismo tiempo un servidor de aplicaciones y un lenguaje de programación. Utiliza elementos para insertar su código en la página web y, lógicamente, interacciona de manera óptima con otros productos de Adobe, como Flash. Los archivos tienen extensión .cfm. Se diseñó para tener un rendimiento muy elevado (por ejemplo, aprovecha bien la presencia de múltiples procesadores en el servidor) ### 8.2.2. WebDNA WebDNA es un lenguaje especialmente diseñado para hacer scripting del lado del servidor (no como PHP, Perl, Python o Ruby, que fueron pensados para otros propósitos). Especialmente rápido en la interacción con bases de datos. Utiliza etiquetas encerradas entre corchetes [...] para intercalar su código con HTML. ### 8.2.3. Erlang Se trata de un lenguaje para desarrollo de aplicaciones concurrentes (es decir, en las que varios procesos se ejecutan simultáneamente, cooperando en la resolución de un problema). Fue diseñado para sistemas en tiempo real. Se está empezando a usar en el lado del servidor cuando las aplicaciones tienen necesidades de procesamiento brutales. ### 8.2.4. Otros SSJS (SSJS = Server Side JavaScript): hace mucho tiempo que se especula con la posibilidad de programar scripts del lado del servidor en JavaScript. Al fin y al cabo, JS es un lenguaje dominado por cualquier desarrollador web. No existe por ahora ninguna solución estandarizada: a veces, el JS se traduce a Java para ejecutarlo como JSP, otras veces se compila a código nativo del servidor (como hace NodeJS), otras veces se instala un plugin en el servidor para ejecutarlo nativamente, o bien se reduce su uso sólo a generar y procesar información JSON, etc. JS en el lado del servidor necesita siempre de librerías adicionales para acceder a los recursos del servidor (p.ej: bases de datos) ",
    "url": "/otros/mas-tecnologias-aun",
    "relUrl": "/otros/mas-tecnologias-aun"
  },"59": {
    "doc": "Apéndice I. Sistemas de control de versiones. Git",
    "title": "Apéndice I. Sistemas de control de versiones. Git",
    "content": "# Apéndice 1. Sistemas de control de versiones. Git {: .no_toc } - TOC {:toc} # A1.1. Sistemas de control de versiones Es inconcebible que un desarrollador trabaje en la actualidad sin un sistema de control de versiones. Fíjate que en la frase anterior no tiene cabida tu opinión. Lo siento, pero es lo que hay. No importa si te gustan estos sistemas o no. No importa si estás los usas de forma habitual o siempre has huido de ellos como de la peste. No importa si ni siquiera sabes qué son o cómo funcionan. Si quieres dedicarte profesionalmente al desarrollo de software, tienes que conocerlos porque te los vas a encontrar vayas donde vayas. ## A1.1.1. ¿Qué es un sistema de control de versiones? Un sistema de control de versiones es un almacén en la nube pensado para equipos de desarrollo de software. Es decir, es como un Google Drive con esteroides. El sistema de control de versiones no solo sirve para que un puñado de usuarios (entre uno y miles) suban su código fuente a la nube para ponerlo a salvo de posibles problemas con las máquinas locales, sino que, además, permite: * Conservar absolutamente todo el historial de versiones previas. * Documentar cada cambio, de manera que siempre sea posible saber quién, cómo, dónde, cuándo y por qué escribió cada línea de código. * Revertir el estado del software a un estado anterior en cualquier momento. * Crear ramas o \"estados alternativos\" del software, que luego podrán fusionarse con otras ramas o abandonarse sin llegar a nada. * Crear \"forks\" o réplicas del sistema que luego podrán evolucionar de forma independiente (o volver a fusionarse con el contenido original). * Evitar conflictos cuando el mismo código fuente ha sido editado simultánemente por dos personas. Y, en caso de que estos conflictos ocurran, ayudar a resolverlos. Se trata de un buen puñado de funciones, ¿verdad? Ese es el motivo por el que absolutamente todas las organizaciones serias que se dedican a desarrollar software utilizan algún sistema de control de versiones. Pero es que incluso para un programador/a solitario, que trabaja de forma autónoma, las ventajas de usar uno de estos sistemas superan de lejos a los inconvenientes, porque... espera un momento... ¡Resulta que no tienen ningún inconveniente! Así que ya lo sabes: si aún no los usas, este es el momento de hacer un esfuerzo e incorporar un sistema de control de versiones a tu vida. ## A1.1.2. ¿Cómo funcionan los sistemas de control de versiones? Existen muchos sistemas de control de versiones, aunque el mercado está dominado por unos pocos de ellos (CVS, Subversion, Mercurial, Bazaar y, sobre todo, Git). Cada uno tiene sus propias peculiaridades, pero suelen compartir varias características comunes: * El código fuente del proyecto (y todas sus versiones previas) se guarda en un servidor. Esa colección de código fuente se denomina ***repositorio***. El servidor puede estar en Internet y pertenecer a una compañía externa, o puede estar en nuestra intranet, instalado en una de nuestras máquinas. * Los repositorios pueden ser remotos (si están en otra máquina distinta de la nuestra) o locales (si están en nuestra máquina). * Cuando trabajamos, lo hacemos sobre nuestro repositorio local. Cuando una funcionalidad del código se termina, el código fuente modificado se sube al repositorio remoto, para que el resto de miembros del equipo puedan disponer de él. * Si otra persona del equipo ha modificado los mismos archivos fuente que nosotros, el sistema de control de versiones no avisará durante la sincronización con el repositorio remoto y nos obligará a hacer manualmente una fusión de los archivos afectados, mostrándonos las diferentes versiones del mismo y las líneas de código que entran en conflicto, antes de completar la sincronización. La sincronización con el repositorio remoto, por lo tanto, no puede ser automática (como en Google Drive o Dropbox), sino que hemos de hacerla explícita, momento en el cual el sistema nos avisará de posibles conflictos. Esta es la única manera de resolver adecuadamente esos conflictos en proyectos donde haya mucha gente trabajando simultáneamente. # A1.2. Git básico Git es, en la actualidad, el sistema de control de versiones más utilizado del mundo con diferencia. También es uno de los más completos y complejos. Así que, si aprendes a utilizar Git, podrás apañártelas con cualquier otro sistema de control de versiones. En esta sección vamos a ver cómo se usa Git a nivel básico. El acceso a las funciones avanzadas irá viniendo solo, con el tiempo y el uso. ## A1.2.1. Poniendo en marcha Git Git es un sistema de control de versiones de código abierto. De hecho, se creó inicialmente (y se sigue usando para ello) para desarrollar el núcleo de Linux. Eso quiere decir que cualquiera puede coger el código, modificarlos, adaptalo y distribuirlo. Por eso encontrarás multitud de implementaciones de Git, así como muchos servidores y clientes que lo usan. Todos son compatibles entre sí. Git crea repositorios locales y remotos que hay que mantener sincronizados manualmente. Eso quiere decir que, para usar Git, necesitas al menos: * Instalar un cliente de Git en tu ordenador de trabajo. * Instalar un servidor de Git en el ordenador donde vayas a alojar el repositorio remoto. Para el servidor Git, mucha gente utiliza servidores gratuitos disponibles en Internet. Los más conocidos de ellos son GitHub y GitLab. Son sitios web donde te registras y ¡voilà!, ya tienes disponible un servidor Git en línea para que funcione de repositorio remoto. Además, estos sitios proporcionan características adicionales muy convenientes, como sistemas de gestión de *issues* o tareas pendientes, gestión de proyectos, estadísticas, evaluación de la calidad de software, etc. También funcionan como redes sociales para desarrolladores. En fin, que, salvo que seas un paranoico de la seguridad o estés desarrollando código ultrasecreto para la NSA o el CSIF, usar GitHub o GitLab como repositorio remoto es la opción más interesante. Así que ya puedes registrarte en alguno de los dos. Después de eso, solo te queda instalarte en tu ordenador un cliente Git. Clientes Git hay muchos, algunos más bonitos que otros. Yo te recomiendo el cliente básico en modo texto, con el que tendrás que salirte a la consola y teclear comandos. Teclear comandos incomprensibles de forma rápida y segura siempre mola mucho de cara a los demás. A parte de eso, aprenderse los comandos básicos de Git te salvará la vida en algún momento de tu futuro profesional con toda seguridad, te lo aseguro, así que es una buena inversión de tiempo. Puedes encontrar los clientes oficiales de Git en la web del proyecto: https://git-scm.com/ Cuando hayas aprendido a apañarte con los comandos, es posible que no quieras recurrir a los clientes gráficos, pero, por si acaso, te comento que existen mogollón de ellos que te permitirán sincronizar tus archivos con un solo clic y resolver conflictos de forma rápida y muy visual. Algunos de ellos son: GitHub Desktop (ofrecido por GitHub), GitKraken, Git Cola o Tortoise Git. Por último, ten en cuenta que todos los entornos de desarrollo medianamente potentes ofrecen una integración absoluta con Git. Es decir, que si usas Visual Studio Code, o Eclipse, o NetBeans, o muchos otros, no necesitarás ningún cliente git adicional, porque ya lo traen incorporado. Tan solo debes configurar la ruta el repositorio remoto y al local, y hala, a programar y a sincronizar como si no hubiera un mañana. ## A1.2.2. Creando un repositorio nuevo Vale, ya tenemos nuestra cuenta en GitHub o GitLab y hemos instalado un cliente Git en nuestra máquina. ¿Ahora qué? Podemos encontrarnos ante dos escenarios diferentes: 1. Voy a empezar un proyecto nuevo y quiero inicializar un repositorio en blanco. 2. Ya tengo mi código fuente (todo o una parte) escrito y quiero añadirlo a un repositorio git. Vamos a ver cómo proceder en cada caso. Lo haremos mostrando cómo se usa el cliente git de línea de comando. Desde los clientes gráficos, el proceso será parecido, pero tendrás que trastear con el cliente en cuestión o leerte su documentación para ver los detalles. #### Voy a empezar un proyecto nuevo y quiero inicializar un repositorio en blanco. 1. Abre un terminal de línea de comandos y muévete al directorio donde tienes pensado crear tu código fuente. Usa para ello los comandos *cd directorio* (para cambiar de directorio) o *mk directorio* (para crear un directorio nuevo). | 2. Para crear un repositorio git local en el directorio elegido, simplemente teclea este comando: | ``` $ git init ``` 3. Para conectar este repositorio local con un repositorio remoto en GitHub o GitLab, escribe a continuación este comando (sustituye URI por la dirección de tu repositorio que te habrá proporcionado GitHub o GitLab. Por ejemplo, en GitHub, una URI de repositorio tiene un aspecto como este: https://github.com/usuario/nombre-repositorio.git): ``` $ git remote add origin ``` Obviamente, el repositorio remoto deberías haberlo creado antes desde la web de GitHub o GitLab. Eso es todo. A partir de ahora, podrás empezar a desarrollar tu código en local y a sincronizar tus archivos con el repositorio remoto cada vez que lo necesites. El procedimiento para hacer esto último lo describimos un poco más adelante. #### Ya tengo mi código fuente y quiero añadirlo a un repositorio git Este caso es un poquito más complejo, pero tampoco mucho. Asegúrate de tener ya creado un repositorio (vacío) en GitHub o GitLab antes de seguir esta guía. 1. Abre un terminal de línea de comandos y muévete al directorio donde tengas tu código fuente. Usa para ello el comando cd . 2. Para crear un repositorio git local en ese directorio, simplemente teclea este comando: ``` $ git init ``` 3. Para conectar este repositorio local con un repositorio remoto en GitHub o GitLab, escribe a continuación este comando (sustituye por la dirección de tu repositorio que te habrá proporcionado GitHub o GitLab. Por ejemplo, en GitHub, una URI de repositorio tiene un aspecto como este: https://github.com/usuario/nombre-repositorio.git): ``` $ git remote add origin ``` 4. Edita el archivo .gitignore para incluir en él los archivos y directorios que no quieres incluir en el repositorio. Esto suele referirse a archivos de configuración, imágenes y otros recursos que no son parte intrínseca del código fuente o librerías de terceros. Más adelante hablaremos del archivo .gitignore con más detalle. 5. Haz tu primer commit para añadir todo el código fuente que ya tienes: ``` $ git add * $ git commit -m \"Primer commit con todo el código preexistente\" ``` 6. Sube el código de ese commit a tu repositorio remoto (te pedirá tu usuario y contraseña en GitHub o GitLab): ``` $ git push ``` Si ahora entras en tu perfil de GitHub o GitLab, verás que el repositorio remoto ya contiene todos los archivos que tenías en tu proyecto (excepto los que señalaste en .gitignore). Los repositorios local y remoto ya están creados y puedes empezar a trabajar con normalidad, escribiendo código y subiéndolo al repositorio remoto cuando lo necesites. Este proceso lo describiremos en detalle enseguida. Si no has entendido alguno de estos pasos, no te agobies. Enseguida te quedarán más claros. #### Más cosas sobre la inicialización de un repositorio Hay otro par de cosas que te interesa hacer al iniciarlizar un repositorio. Solo tendrás que hacerlo una vez y, después, tu repositorio lo recordará. Después del *git init*, puedes indicarle al repositorio qué usuario de GitHub o GitLab va a realizar los commits. Esto se hace así: ``` $ git --config user.name \"Mi-nombre-de-usuario\" $ git --config user.email \"Mi-email\" ``` Para comprobar que la información es correcta, simplemente teclea: ``` $ git --config list ``` #### ¡Antes de continuar! No te olvides de .gitignore Una última cosita antes de describir cómo es el trabajo cotidiano con git y qué significa todo eso de los commits. Esa cosita es sobre el archivo ***.gitignore***. Es un archivo muy importante que debería estar en el directorio raíz de tu proyecto. Si no existe, créalo. Ten en cuenta que en los sistemas GNU/Linux y Mac, los archivos cuyo nombre empiezan por un punto se consideran ocultos, por lo que es posible que el archivo esté ahí sin que lo veas. Ese archivo es muy importante porque contiene una lista de todas las cosas que no se deben subir al repositorio remoto. Esto incluye, entre otros: * **Los archivos de configuración**. Es habitual en una aplicación web tener un archivo de configuración (llamado config.php o algo parecido) con un puñado de variables donde se guarda el host de la base de datos, el usuario y la contraseña para ese host, el nombre de la base de datos, etc. Y, vamos a ver, ¿de verdad quieres que cualquiera que acceda a tu repositorio de GitHub o GitLab vea esa información? Además del problema de seguridad que puede suponerte (sobre todo si, como el 99% de los desarrolladores, usas el acceso root a tu servidor local de bases de datos mientras estás desarrollando un nuevo proyecto), es que no tiene sentido subir esa información al repositorio remoto, porque será diferente en cada servidor donde la aplicación se ponga en producción. Lo que sí suele hacerse es crear un archivo de configuración de ejemplo (algo como config-example.php), donde se muestre la estructur que debe tener config.php pero se dejen en blanco los valores de las variables. Ese archivo sí que puede sincronizarse con el resto del código y subirse a GitHub o GitLab. * **Archivos de recursos que no forman parte de la aplicación**. Imagina que estás programando una aplicación web para una biblioteca. Esa aplicación usa algunas imágenes para construir sus vistas (por ejemplo, una hermosa fotografía de un libro antiguo para el encabezamiento). Esas imágenes **sí** forman parte de la aplicación y **sí** deben subirse al repositorio remoto. Pero imagina que, como es lógico, para probar la aplicación has creado un montón de libros falsos en tu base de datos local. Cada vez que añades un libro falso, le asignas una imagen de la portada (falsa también), que la aplicación almacenará en algún directorio del servidor local. Esas imágenes forman parte de los datos de prueba, no de la propia aplicación, y, por tanto **no** deberían subirse a GitHub ni GitLab. El directorio completo donde almacenes esas imagenes debería incluirse en .gitignore. Si no lo haces así, llenarás el repositorio remoto de basurilla y, además, harás que ocupe mucho más espacio del necesario, hasta el extremo que una clonación del repositorio puede tardar varias horas y ocupar muchos gigabytes. Ten en cuenta que el repositorio no solo contiene el estado actual del proyecto, sino también *todos los estados anteriores*, lo que incluye todas las imágenes de libros falsos que hayas podido añadir alguna vez durante el desarrollo. Esto no solo es aplicable a imágenes, sino a cualquier otro recurso que use la aplicación y que no forme parte de la propia aplicación: sonidos, fuentes tipográficas, vídeos, etc. * **Bibliotecas de terceros**. A menudo, recurrimos a bibliotecas de terceros para usarlas en nuestra aplicación. Incluir ese código en nuestro repositorio nos puede meter en un embrollo legal (mírate bien la licencia de uso de *todas* las bibliotecas que vayas a utilizar) y, además, nos puede hacer engordar innecesariamente el repositorio. Tendrás que valorar una a una si es conveniente incluir determinada librería o no. Las librerías no incluidas deberán ser instaladas manualmente cuando la aplicación se despliegue en un servidor, lo cual deberás explicar muy bien en la documentación. Por ejemplo, en el caso de Laravel, se aconseja no incluir la carpeta \"vendor\" en el repositorio remoto. Es decir, hay que añadir la carpeta \"vendor\" a .gitignore antes de la primera sincronización. En \"vendor\" se encuentran todas las librerías de terceros que usa Laravel. Entonces, para desplegar esta aplicación en un servidor, ¿de dónde sacamos todas esas librerías? Fácil: cuando despleguemos el código en un servidor, solo tendremos que ejecutar \"composer update\" en el directorio raíz de la aplicacion, y el propio composer se encargará de instalar las librerías. # A1.3. Trabajo básico con Git Bueno, pues ya tenemos nuestros repositorios inicializados, conectados con el remoto y con el archivo .gitignore a punto. ¿Qué hacemos ahora? Muy fácil: ponernos a trabajar como si git no existiera. Y luego, cuando des por finalizada una parte de la aplicación (un método, una clase, una funcionalidad concreta: tú decides cada cuánto tiempo haces esto), pasarla a la ***Staging Area***. ## A1.3.1. Un momento... ¿Staging quéeee? La ***Staging Area*** es como la pista de despegue de Git. La idea es la siguiente: Git no quiere sincronizar tus archivos con el repositorio remoto de forma automática (como hacen las plataformas para el público general, como Google Drive o Dropbox), porque sabe que los programadores producimos mucha basura al cabo del día. Si cada vez que escribimos una basurilla, Git la sincronizara con el remoto, el resto de personas del proyecto estarían recibiendo nuestra basura de forma permanente. Y nosotros la de esas personas. Y esparcir basura no es una buena política. Así que Git quiere que seas muy consciente de cuándo quieres sincronizar algo, y de qué es lo que quieres sincronizar. Quiere que te tomes el trabajo (que tampoco es para tanto, la verdad) de tomarte medio minuto de tu tiempo para decirle: \"eh, Git, he estado trabajando en estos dos archivos esta mañana y creo que *ahora* ya no son una basura\". Para eso sirve la Staging Area. Tienes que pasar los archivos que ya no son una basura a la Staging Area. Y tienes que hacerlo tú, generalmente cuando hayas terminado una funcionalidad y la hayas probado adecuadamente. Lo bastante como para que no te avergüence que otras personas del equipo reciban tu código. Para añadir archivos a la Staging Area se usa el comando git add, así: ``` $ git add archivo1 archivo2 archivo3 ... ``` Se pueden añadir directorios completos: ``` $ git add directorio1 directorio2 ... ``` Y también se pueden usar símbolos comodín, como el asterisco. De modo que, si estás muy, pero que muy seguro/a de que todos los archivos que han andado tocando desde el último commit están en un estado aceptable, puedes hacer esto para que git se encargue de *añadir todos los archivos modificados recientemente a la Staging Area*: ``` $ git add * ``` Por fin, cuando tengas una o varias cosas preparadas en la Staging Area... Bueno, entonces llega el momento de hacer un **commit**. ## A1.3.2. Hacer commit Un **commit** (palabra que podríamos traducir por \"perpetrar\") consiste en empaquetar todos los cambios de la Staging Area para enviarlos a otro repositorio, normalmente el repositorio remoto. El decir, con el commit le decimos a Git: \"quiero que prepares todo el código que te he puesto en la Staging Area a para enviarlo a GitHub\" (o a dónde sea). Se puede hacer un commit por cada pequeña modificación que introducimos en la Staging Area, o se pueden preparar muchos archivos en la Staging Area y luego empaquetarlos en un único mega-commit. Eso lo decidís tú y tu equipo de desarrollo. Pero suele ser buena idea hacer commits de funcionalidades o tareas individuales. Es decir, si esta mañana he estado trabajando en dos funcionalidades, \"Añadir usuarios nuevos\" y \"Modificar la vista de edición de usuarios\", es mejor que haga dos commits separados para cada una de esas funcionalidades. Esto es así porque, a cada commit, le tengo que añadir ***obligatoriamente*** un texto descriptivo donde indique qué cambios estoy subiendo con ese commit. El comando para hacer un commit es: ``` $ git commit -m \"Mensaje\" ``` Ahora saco mi bola de cristal y te digo: no tardarás ni una semana en empezar a hacer commits cuyo texto descriptivo será algo como \"aslkdaslkjda\", \"aaa\", \"yoquésé\". Eso es una pésima idea. Antes o después, alguien del equipo meterá la pata, subirá un cambio indebido y todo el repositorio explotará. Entonces, intentaréis regresar a un estado en el que el código aún funcionaba, pero encontraréis un montón de commits con explicaciones incomprensibles como \"aslkdaslkjda\", \"aaa\" y \"yoquésé\". Y sudaréis tinta para descubrir cuál fue el commit explosivo. Los commits deben llevar textos descriptivos breves pero informativos. Por ejemplo: \"Arreglo el fallo del id de usuario inexistente al actualizar foto de perfil\" o \"Elimino el botón de modificar de la vista de libros\". Pero, ¡ojo!, hacer commit **no sube los archivos al repositorio remoto**. Todavía no. Recuerda que Git quiere que estés muy seguro/a de que subes lo que realmente tienes que subir, así que aún te falta un último paso: hacer ***push***. ## A1.3.3. Subir el commit: hacer push El último paso para enviar nuestros cambios locales al repositorio remoto (típicamente, GitHub o GitLab) consiste en hacer ***push***. Es decir, literalmente, \"empujar\" los cambios al repositorio remoto. La operación *push* enviará todos los commits que aún no se hayan enviado al repositorio remoto. A partir de ese momento, estarán disponibles para el resto de miembros del equipo. Pero solo a partir de ese momento. Para hacer push, basta con escribir: ``` $ git push ``` Lo normal es que el repositorio remoto te pida tu nombre de usuario y contraseña, pero eso dependerá de si el acceso a ese repositorio está autenticado o no. Por supuesto, tanto GitHub como GitLab te solicitarán que te identifiques. ## A1.3.4. Bajar la última versión del código Si podemos subir nuestros cambios al repositorio remoto, tendremos que tener una forma de bajar los cambios del resto de miembros del equipo, ¿verdad? Por supuesto, existe un comando para ello. Es este: ``` $ git pull ``` Es recomendable hacer pull antes de hacer push, por si alguien a tocado alguno de los archivos que nosotros pretendemos subir. En ese caso, Git nos avisará del conflicto y nos ayudará a resolverlo (más adelante veremos cómo). No podremos hacer push hasta resolver ese conflicto, para evitar pérdidas de código. ## A1.3.5. Resumiéndolo todo: flujo de trabajo habitual con git Si resumimos lo dicho hasta ahora, tenemos que, después de inicializar el repositorio (cosa que hay que hacer solo una vez), el trabajo cotidiano con Git consiste en: 1. Desarrollar nuestra aplicación con normalidad. 2. Cuando terminamos de hacer algo, añadirlo a la Staging Area (git add). 3. Cada cierto tiempo, o cuando acabamos una funcionalidad, empaquetar todos los cambios que esperan en la Staging Area en un commit (git commit). 4. Bajarnos los commits del resto de miembros del equipo (git pull) 5. Subir nuestros commits al repositorio remoto (git push) Podemos verlo gráficamente en el siguiente esquema. Las tres primeras columnas (workspace, Staging Area y Local Repo) están en nuestro ordenador de trabajo. El repositorio remoto (Remote Repo) está en un servidor. ``` Workspace Staging area (INDEX) Local repo (HEAD) Remote repo | | | git add → | | | git commit → | | | | ← ← ← ← ← | ← ← ← ← ← | ← git pull | | | | git push → | | | | | ``` Un último apunte: te voy a chivar un comando muy útil de git cuando no estás muy seguro de qué archivos has estado tocando últimamente (¿a quién no le ha pasado eso? ¿Eh?). Este comando te resumirá el estado de tu repositorio local, indicándote qué archivos han sido modificados (pero no están en la Staging Area), qué archivos están preparados en la Staging Area (pero no en un commit) y, por supuesto, qué commits están hechos pero aún sin subir. Todo eso, gratis y tecleando este humilde comando: ``` $ git status ``` ¿Es potente o no es potente este Git? Pues aún no has visto nada. # A1.4. Algunas cosillas avanzadas sobre git Solo con lo que hemos visto hasta ahora (add, commit, push y pull) ya tienes suficiente para empezar a funcionar con git. Luego, conforme te surjan otras necesidades, puedes ir curioseando por internet para profundizar en ciertos aspectos. Una de esas \"necesidades\" que te surgirán antes o después consiste en lo siguiente: Imagínate la escena: un día llegas a clase después de haberte acosatado a las tantas trabajando en tu proyecto. Antes de acostarte hiciste un push para subir todos tus cambios y puedes jurar que todo funcionaba perfectamente. Pero ahora, tú y el resto de miembros de tu equipo acabáis de hacer pull y... ¡BUM! El proyecto entero salta por los aires. El homepage no carga. Otras rutas que *estás seguro* de que funcionaban hace unas horas ahora no responden. ¿Qué narices ha pasado? Tranquilidad: ahí está Git para sacarte del embrollo. ## A1.4.1. Regreso al pasado: cómo revertir los cambios Las causas de un desastre como ese pueden ser tantas que, en la práctica, es como si fueran infinitas. Un problema con el proxy, un merge mal hecho, una desconfiguración de uno de los servidores locales que ha afectado a algún archivo clave, un error de algún miembro del equipo que ha sobreescrito cientos de archivos con versiones incorrectas... Causas infinitas, como te digo. No suele compensar el esfuerzo de buscar la razón última de lo que ha ocurrido, salvo que os pase esto con cierta regularidad: entonces sí que es cuestión de preocuparse. La mayoría de las veces es un problema puntual que puede resolverse de un modo muy simple: volviendo a la última versión estable. En primer lugar, si lo que quieres es revertir cambios de los que **aún no has hecho commit**, es tan fácil como: ``` $ git reset --hard ``` Pero, la mayor parte de las veces, el problema viene de cambios de los que no solo ya se ha hecho commit, sino que incluso se han subido al repositorio remoto. ¿Cómo descartamos esos cambios para volver a un estado anterior? En primer lugar, si aún no lo has hecho, ejecuta un **git pull** para traerte la última versión del código a tu repositorio local. Luego, utiliza el comando **git log**: ``` $ git log (muestra historial de cambios) $ git log --oneline (muestra historial de cambios simplificado) ``` Con esto obtendrás una lista, ordenada por cronología inversa (de más reciente a más antiguo), de todos los commits que has hecho en el repositorio. Observa que cada commit está identificado con un id único en hexadecimal. Cada id de commit está acompañado de su descripción. Si habéis sido cuidadosos con los commits y les habéis puesto descripciones representativas (y no \"asdfasdf\" o \"aaa\"), resutará fácil localizar en esa lista el commit causante del destrozo. A continuación, usa el comando **git revert** para regresar al commit *inmediatamente anterior* a aquel en el que se produjo el caos: ``` $ git revert HEAD [main id-de-commit] revert \"Mensaje del revert\" ``` Lo que hace este comando es devolver tu repositorio local (HEAD) al commit \"id-del-commit\". Pero, ojo, que no elimina todos los commits posteriores, sino que crea un nuevo commit (main) con el \"Mensaje del revert\" que le hayas indicado. En este nuevo commit habrá desaparecido todo el código conflictivo. El proyecto volverá a estar en un estado estable. Ahora bastará con hacer **git push** para subir el nuevo commit al repositorio remoto y que todos los miembros del equipo puedan replicarlo en sus máquinas. Es posible que, en el proceso, hayáis perdido algo de código valioso: todo depende de cuánto hayáis tenido que retroceder en el historial de commits hasta alcanzar un estado válido. Pero ese código en realidad no se ha perdido, porque los commits siguen ahí, en el historial de git. Existe una forma de poner el repositorio local en un commit concreto. Si lo haces y abres cualquier archivo fuente, lo encontrarás como estaba en ese commit, no como está en el último. ¿No es maravilloso? Así, podrás recuperar manualmente el código que pudiera haberse perdido al hacer el *git revert*. El comando que te permite saltar momentáneamente a cualquier commit es **git checkout**: ``` $ git checkout id-del-commit ``` Ahora puedes ver y rescatar el código fuente válido sin temor: nada de lo que hagas en este estado afectará al tu proyecto, porque los cambios se perderán cuando salgas de este \"viaje en el tiempo\" (salvo que crees una nueva rama del proyecto, pero esa es otra historia). Y, para regresar al presente, es decir, al último commit, basta con teclear: ``` $ git checkout main ``` ## A1.4.2. Cuando dos personas se encaprichan del mismo archivo Cuando ejecutas *git pull*, traes a tu repositorio local las versiones más recientes de todos los archivos del proyecto. Esto ya lo sabíamos. Si *git pull* se ejecuta sin contratiempos, aparecerá un mensaje informándote de ello. Pero los contratiempos existen, qué le vamos a hacer. La vida sería muy aburrida y predecible sin ellos. El contratiempo más habitual, con diferencia, al hacer *git pull* es el aviso de un conflicto el alguno de los archivos modificados en el repositorio remoto. Eso quiere decir que *tú* has estado tocando el código de un archivo *al mismo tiempo que otra persona de tu equipo*. Supongamos que, en un archivo A, tú has añadido las líneas A1, A2 y A3, mientras que otra persona ha añadido las líneas A4, A5 y A6. Si la otra persona ha subido el archivo A al repositorio remoto antes que tú, git se dará cuenta cuando intentes hacer *git pull* de que tu copia local del archivo y la que hay en el repositorio remoto no coinciden: no solo porque la tuya tiene las nuevas líneas A1, A2 y A3, sino porque a la tuya *le faltan* las líneas A4, A5 y A6. En ese caso, y para no perder ninguna de las nuevas líneas de código, git te mostrará un mensaje de advertencia y creará una versión nueva del archivo A en la que estarán **todas las líneas de código nuevas, tanto las tuyas como las de la otra persona**, rodeadas de unas marcas de texto como estas: ``` >>>>>> nueva-rama ``` Ahora, lo único que tienes que hacer es buscar manualmente esas líneas conflictivas y resolverlas a mano, es decir, quedarte con las líneas correctas y borrar las que no lo sean. Borra también todas las marcas que ha puesto ahi git para indicarte el conflicto. Si usas cualquier editor de texto medianamente potente, te mostrará esas líneas resaltadas e incluso te ayudará a encontrarlas. Una vez que hayas resuelto manualmente las líneas en conflicto, basta con guardar los cambios y hacer *git add* y *git commit -m \"Resolviendo el conflicto bla,bl,bla\"* para que el *git pull* y el *git push* vuelvan a funcionar a la perfección. ## A1.4.3. Proyectos que se complican: cómo crear ramas Imagina esta situación: tienes un proyecto ya en marcha, con una versión más o menos estable funcionando, y entonces surge la necesidad de desarrollar una nueva funcionalidad. Y esta nueva funcionalidad va a poner patas arriba una parte importante del código y va a dejar la aplicación hecha unos zorros durante un tiempo. Si trabajas con tu repositorio como hemos hecho hasta ahora, el resultado es que, durante ese tiempo, todo tu proyecto dejará de funcionar. No podrás hacer demos a los clientes (ni a tus profesores/as), no podrás probar la aplicación, no podrás cargarla con datos reales, etc. ¡Todo quedará paralizado hasta que la nueva funcionalidad esté en marcha! En un equipo de desarrollo grande, esta es una situación cotidiana que provocaría que gran parte de la gente se tuviera que quedar de brazos cruzados a la espera de la finalización de la nueva funcionalidad. Pero incluso en un equipo pequeño es un engorro llegar a este extremo. Para evitarlo, existen **las ramas** (*branches*) de Git. Una rama no es más que una copia del repositorio que puede evolucionar por su cuenta mientras la rama original permanece inalterada. Los desarrolladores/as que trabajen en esa rama pueden así trabajar en la nueva funcionalidad sin que el resto del equipo se vea afectado. Cuando la nueva funcionalidad se termine, lo único que hay que hacer es fusionar las dos ramas. Esto puede ser un trabajo ímprobo si se han estado modificando los mismos archivos en la rama principal y en la rama nueva, pero no se trata de un fallo de Git, que quede claro, sino de un fallo de organización del equipo. Y si la nueva funcionalidad nunca llega a terminarse (cosa que puede ocurrir por miles de razones), no pasa nada: la rama se elimina, o simplemente se abandona, y la rama principal sigue intacta. Crear una rama nueva es tan sencillo como usar este comando: ``` $ git branch nombre-nueva-rama ``` El comando *git branch* tiene muchas otras posibilidades. Aquí te pongo unas cuantas: ``` $ git branch --list (saca un listado de todas las ramas existentes) $ git branch -d nombre-rama (elimina una rama) $ git branch -D nombre-rama (elimina una rama a lo bestia, incluso si tiene cambios sin fusionar) $ git branch -m nuevo-nombre (cambia en nombre de la rama actual) ``` Ten en cuenta que, cuando creas una rama, *aún no estás trabajando en ella*. Si quieres cambiar a esa rama para empezar a trastear con ella sin tocar a la principal, debes hacer un *git checkout*: ``` $ git checkout nombre-rama ``` Por último, para fusionar una rama con otra (típicamente, con la rama principal o *main*), tienes que seguir estos pasos: 1. Asegúrate de estar situado en la rama que va a recibir la fusión. Si esa rama es *main*, tienes que hacer: ``` $ git checkout main ``` 2. Haz un *git pull* para tener disponible la última versión del código. 3. Realiza la fusión de las dos ramas con *git merge*: ``` $ git merge nombre-rama ``` En este punto, tendrás que resolver manualmente los conflictos que puedan surgir (si los hay), como hemos explicado más arriba. ## A1.4.4. ¿Aún quieres saber más? Git es un sistema de control de versiones increíblemente completo. Sus creadores parecen haber pensado en escenarios de lo más aberrante y han tenido en cuenta casi cada cosa que puede suceder en un proyecto complejo. Si no, no se explica la enorme cantidad de comandos y posibilidades que ofrece. Si necesitas saber más cosas sobre Git, internet está plagada de contenidos de calidad (y otros bastante penosos) sobre este sistema. Como siempre te recomiendo, acude en primer lugar a la referencia oficial: https://git-scm.com/docs Personalmente, a mí me gustan mucho los tutoriales de Atlassian. Aunque están orientados a BitBucket (un servicio competidor de GitHub o GitLab), casi todas sus recomendaciones son aplicables a cualquier servidor Git. Los puedes encontrar aquí: https://www.atlassian.com/es/git/tutorials ",
    "url": "/scv-git/",
    "relUrl": "/scv-git/"
  },"60": {
    "doc": "About",
    "title": "About",
    "content": "Estos apuntes han sido elaborados por [Alfredo Moreno Vozmediano](https://ensegundapersona.es) y se publican aquí con licencia [CC BY 4.0](https://creativecommons.org/licenses/by/4.0/), lo que quiere decir que eres libre de usar este material, copiarlo, distribuirlo y modificarlo siempre que el resultado de todo eso mantenga la misma licencia y cites la autoría original. Algunos fragmentos (pocos) están tomados y adaptados de otras fuentes. Cuando eso ocurre, lo indico claramente en el texto. Debes atenerte a la licencia de los sitios web de origen para esos fragmentos. ",
    "url": "/about/",
    "relUrl": "/about/"
  },"61": {
    "doc": "1.1 Algunas cosas que debes saber sobre los CMS",
    "title": "1.1 Algunas cosas que debes saber sobre los CMS",
    "content": "## 1.1. Algunas cosas que debes saber sobre los CMS {: .no_toc } - TOC {:toc} ### 1.1.1. Inconvenientes de desarrollar una web desde cero Desarrollar sitios web programándolos desde cero (o más o menos desde cero, porque la mayor parte de las veces se parte de librerías existentes) tiene varias **ventajas** como: * Nos permite sacar el máximo partido tanto del servidor como de los clientes. * Nos da un control absoluto sobre el sitio web que estamos desarrollando. * Nos posibilita ajustarnos al máximo a los requerimientos y crear aplicaciones a medida. Pero también tiene **inconvenientes**: * La creación de un sitio desde cero es un proceso muy largo. * Las ampliaciones y actualizaciones del sitio también resultan lentas y costosas. * Ambas tareas (creación y actualización) requieren personal altamente cualificado, con conocimientos de todas las tecnologías implicadas. Es decir, desarrolladores web. Y eso cuesta dinero. Cuando los inconvenientes superan a las ventajas, el equipo de desarrollo puede optará por **no desarrollar desde cero**. Esto ocurre en la inmensa mayoría de los proyectos. No es necesario inventar la rueda cada vez que tengamos que construir un coche, ¿verdad? Pues para construir una aplicación web pasa lo mismo. Ahora bien, ¿de qué base partimos? Podemos construir una biblioteca de clases que resuelvan las tareas más habituales de cualquier aplicación web, cosas como la autenticación de usuarios, la seguridad, el acceso a bases de datos, etc. Cosas que se repiten una y otra vez con muy pocas variaciones. Esa biblioteca de clases puede ser más grande o más pequeña, más elaborada o más simple, más configurable o más rígida. Pero, sea como sea, nos ahorrará tiempo y esfuerzo en el desarrollo de nuevos proyectos. A esas bibliotecas se las denomina ***frameworks*** y es rara la aplicación web que no se programa usando alguna de las muchas que hay por ahí pululando, bien se usa un framework propio creado por el propio equipo de desarrollo. Pero se puede ir un paso más allá y utilizar una biblioteca más grande, una que ya te lo dé casi todo hecho y a la que solo tengas que indicarle qué tipografía, qué colores y qué contenidos quieres mostrar en tu web, y ella solita se las apañe para generarte la web de forma casi automática. Esta solución casi mágica son los **sistemas gestores de contenido (CMS)** de los que estamos hablando. Sin programar una sola línea de código, puedes tener lista en unos minutos una web plenamente funcional y de aspecto profesional. Por suerte para nosotros, los desarrolladores/as web, la CMS no pueden hacerlo todo. Son soluciones extraordinariamente eficaces para montar sitios web convencionales, pero cuando quieres crear algo que se salga de los límites muy marcados del CMS, necesitas a un programador/a. Y entonces, ¿a quién vas a llamar? ### 1.1.2. Cómo funciona un CMS **Un CMS (Content Management System)** es una aplicación web que se ejecuta en un servidor y se controla desde un navegador (cliente), y que nos permite: * Crear a través del navegador un sitio web completamente nuevo en muy poco tiempo. * Administrar fácilmente todo lo relacionado con el sitio web: usuarios, privilegios, contenido, apariencia, menús, etc. * Y todo ello sin tener conocimientos de HTML, CSS, PHP ni el resto de tecnologías (ojo: no es necesario, pero sí conveniente) El CMS guarda el **contenido** del sitio web en una **base de datos**. Cuando se solicita una página, un programa escrito en PHP (o en otro lenguaje de servidor) busca el contenido de esa página en la BD y la genera dinámicamente, entregándola al navegador web (cliente). Además, otro conjunto de programas permiten agregar nuevo contenido, modificar el contenido existente, crear usuarios, gestionar privilegios, etc. Todo ello altera los datos existentes en la BD, que a su vez alteran la forma en la que el usuario percibe la página cuando la visita. Al sitio web en sí se le denomina a veces ***front-end***. El front-end, en este sentido, es lo que ve el visitante de la web. A las páginas de adminsitración del sitio se les llama a veces ***back-end*** o ***dashboard*** (panel de administración). El back-end sólo es accesible a algunos usuarios (administradores, editores, etc). El CMS siempre necesita, por ello, un control de acceso de usuarios o login. ¡Cuidado! Los términos front-end y back-end son confusos. En términos de programación, a menudo se denomina ***front-end*** a la parte de la aplicación que se ejecuta en el navegador web y ***back-end*** a la parte de la aplicación que se ejecuta en el servidor e interactúa con los recursos del mismo (como la base de datos). En este otro sentido, el front-end está escrito en HTML, CSS, JavaScript (y cualquiera de las múltiples librerías que existen para Javascript, como jQuery, React o Vue.js) y el back-end está escrito en PHP, Java, Python u otros lenguajes del lado del servidor. Si encuentras por ahí una oferta de trabajo para un \"desarrollador/a back-end\" o \"desarrollador/a front-end\", se refiere a esta última acepción de ambos términos. Es decir, están pidiendo un \"desarrollador/a HTML + CSS + Javascript (y librerías de Javascrit)\" o un \"desarrollador/a en PHP o similar\". ### 1.1.3. Tipos de CMS Hay un montón (¡pero un montón!) de CMS, y cada uno tiene sus propias características, puntos fuertes y puntos débiles. Como hay tantos, resulta útil clasificarlos. Algunos autores los clasifican según su **método de distribución**: * Código abierto y software libre. * Código propietario. Pero, personalmente, creo que tiene más sentido clasificarlos por su **funcionalidad**. Así, nos encontramos con CMS de estos tipos (entre otros): * CMS genéricos (para cualquier tipo de sitio web) * CMS para blogs. * CMS para foros. * CMS para wikis. * CMS para e-learning (aprendizaje por internet) * CMS para e-commerce (comercio electrónico) * CMS para publicaciones digitales (periódicos, revistas...) Algo tremendamente odioso de los CMS es que **son fuertemente incompatibles** entre sí. Cada uno utiliza un interfaz distinto, bases de datos completamente diferentes para almacenar la información, módulos incompatibles, etc. Existen algunas iniciativas para lograr que los servicios desarrollados en un CMS puedan utilizarse en otros, pero todavía están en un estadio muy inicial. Lo que sí existen son familias de CMS relacionados entre sí que pueden compartir algunas características, generalmente porque unos CMS han derivado de otros. ### 1.1.4. Algunos ejemplos de CMS importantes Los CMS propietarios no han podido competir con los CMS libres. Por ello, han evolucionado hacia soluciones cloud computing completas, como Microsoft Azure, Google Cloud o Amazon Web Services (AWS). Entre los verdaderos CMS abundan las soluciones opensource o software libre. Por ejemplo: * **Blogs**: WordPress, Jekyll, GetSimple, Umbraco... * **Wikis**: MediaWiki, XWiki, DokuWiki... * **Foros**: phpBB, MyBB, bbPress, Discourse... * **e-learning**: Moodle, WebCT, Mahara, etc. * **e-commerce**: PrestaShop, Magento, OsCommerce, OpenCart... Muchos de estos CMS desaparecerán, se fundirán con otros o se dividirán en varios proyectos desde que yo escriba estas líneas hasta que tú las leas. Lo mejor es que eches un vistazo a alguna lista actualizada de CMS, como [esta de Wikipedia](https://en.wikipedia.org/wiki/List_of_content_management_systems). ### 1.1.5. Instalación de un CMS IMPORTANTE: la instalación puede diferir de un CMS a otro, pero, más o menos, todos necesitan los mismos pasos. Hay que leer cuidadosamente las instrucciones de instalación, que encontrarás en la web del desarrollador. Los pasos que suelen ser habituales en casi todos los CMS son: 1. Descargar la última versión del programa de la web del desarrollador. 2. Asegurarse de que el servidor cumple los prerrequisitos para ejectuar el CMS (versión de Apache, PHP, MySQL u otro software necesario) 3. Subir el CMS por al servidor (por ftp, vía web o como tu proveedor de hosting te lo permita). 4. Crear la base de datos. 5. Lanzar la instalación del CMS. Esto suele hacerse cargando una dirección concreta en tu navegador. 6. Adapar el archivo de configuración (suele llamarse config.php, config.inc, o algo similar). En los CMS más elaborados este paso no es necesario, pues el programa de instalación se encarga de generar un archivo de configuración válido. 7. A veces, hay que modificar los permisos de algún directorio y/o archivo. 8. Instalar el paquete de idioma español (si está disponible) ### 1.1.6. Explotación de un CMS IMPORTANTE: la explotación puede diferir notablemente de un CMS a otro, pero, en general, todo tienen una serie de elementos en común. Hay que leer cuidadosamente las instrucciones de uso, que encontrarás en la web del desarrollador. Pasos que suelen ser habituales en casi todos los CMS, una vez realizada la instalación: 1. Asignar una password de alta seguridad al usuario administrador que se crea por defecto. 2. Crear otros usuarios y asignarles privilegios. 3. Editar la página de inicio del sitio web. 4. Cambiar la plantilla (apariencia) del sitio. 5. Instalar módulos de ampliación (si es necesario). 6. Crear el contenido y/o revisar el contenido creado por otros usuarios. En las siguientes secciones nos centraremos en la instalación y explotación de algunos de los CMS más populares del mercado. ",
    "url": "/cms/algunas-cosas-que-debes-saber",
    "relUrl": "/cms/algunas-cosas-que-debes-saber"
  },"62": {
    "doc": "Desarrollo Web en Entorno Servidor",
    "title": "Desarrollo Web en Entorno Servidor",
    "content": "Esta es la documentación (apuntes) del módulo de ***Desarrollo Web en Entorno Servidor*** del Ciclo Formativo de Grado Superior de Desarrollo de Aplicaciones Web impartido en el IES Celia Viñas de Almería (España). 1. TOC {:toc} ",
    "url": "/",
    "relUrl": "/"
  },"63": {
    "doc": "1.3 Moodle",
    "title": "1.3 Moodle",
    "content": "## 1.3. Moodle {: .no_toc } - TOC {:toc} ### 1.3.1. Características de Moodle XXX Moodle es un sistema de gestión de contenidos orientado a **crear comunidades de aprendizaje** en línea. Este tipo de plataformas tecnológicas también se conoce como **LMS (Learning Management System)**. Su licencia es GPL (es decir: es software libre). Está programado en lenguaje PHP y puede usar diferentes gestores de bases de datos para almacenar el contenido: MySQL o PostgreSQL son los más habituales, pero también es posible utilizar Oracle o SQL Server. Las características más destacables de Moodle son: * Su arquitectura y herramientas son apropiadas para la educación a distancia, así como también para complementar el aprendizaje presencial. * Tiene una interfaz de navegador de tecnología sencilla, ligera y compatible con todos los navegadores. Eso sí, es más complejo que otras soluciones como Google Classroom, aunque Moodle también es muchísimo más potente. * La instalación es sencilla (¡casi siempre!), requiriendo tan solo una plataforma que soporte PHP y la disponibilidad de una base de datos. * Da mucha importancia a la seguridad: todos los formularios son revisados, las cookies cifradas, etc. * Las áreas de introducción de texto pueden ser editadas usando un editor WYSIWYG. * Es fuertemente configurable, permitiendo la instalación de módulos adicionales (plugins) para incrementar sus posibilidades. * Es un sistema enorme que consume *muchos* recursos en el servidor. ### 1.3.2. Algunos módulos de Moodle En Moodle, los recursos se organizan en categorías llamadas **módulos**. Cada módulo tiene sus propias características y está orientado a un tipo de actividad distinta: cuestionarios en línea, lecciones, tareas para que los alumnos suban, encuestas y un largo etcétera. Aquí solo mencionaremos los módulos más populares. #### Módulo de archivos Los archivos son documentos que sube el profesor/a y que estarán accesibles al alumnado. * Los documentos pueden ser de cualquier tipo: Word, Libreoffice, Powerpoint, vídeo, audio, etc. #### Módulo de Tareas Este módulo sirve para que el alumnado envíe tareas al profesor/a. Estas tareas pueden constar de un texto en línea o uno o varios archivos subidos a la plataforma. * Puede especificarse la fecha final de entrega de una tarea y la calificación máxima que se le podrá asignar. * Los estudiantes pueden subir sus tareas (en cualquier formato de archivo) al servidor. Se registra la fecha en que se han subido. * Se permite enviar tareas fuera de tiempo, pero el profesor puede ver claramente el tiempo de retraso. * Para cada tarea en particular, puede evaluarse a cada estudiante (calificaciones y comentarios) en una única página con un único formulario. Incluso se puede corregir el documento escribiendo encima, como haríamos con una tarea hecha en papel. * Las observaciones del profesor se adjuntan a la página de la tarea de cada estudiante y se le envía un mensaje de notificación. * El profesor tiene la posibilidad de permitir el reenvío de una tarea tras su calificación (para volver a calificarla). #### Módulo de consultas Las consultas son votaciones. Puede usarse para votar sobre algo o para recibir una respuesta de cada estudiante (por ejemplo, para pedir su consentimiento para algo). * El profesor puede ver una tabla que presenta de forma intuitiva la información sobre quién ha elegido qué. * Se puede permitir que los estudiantes vean un gráfico actualizado de los resultados. #### Módulo de foro Hay diferentes tipos de foros disponibles: exclusivos para los profesores, de noticias del curso y abiertos a todos. * Todos los mensajes llevan adjunta la foto del autor. * Las discusiones pueden verse anidadas, por rama, o presentar los mensajes más antiguos o los más nuevos primero. * El profesor puede obligar la suscripción de todos a un foro o permitir que cada persona elija a qué foros suscribirse de manera que se le envíe una copia de los mensajes por correo electrónico. * El profesor puede elegir que no se permitan respuestas en un foro (por ejemplo, para crear un foro dedicado a anuncios). * El profesor puede mover fácilmente los temas de discusión entre distintos foros. #### Módulo de Cuestionarios Los cuestionarios son los típicos exámenes tipo test. Pueden utilizarse como exámenes, como ejercicios de autoevaluación, como pruebas de evaluación inicial, etc. * Los profesores pueden definir una base de datos de preguntas que podrán ser reutilizadas en diferentes cuestionarios. Esto requiere una gran inversión de tiempo al principio, pero luego pueden reutilizarse las preguntas toda la vida. Y existen bancos de preguntas disponibles en internet. * Las preguntas pueden ser almacenadas en categorías de fácil acceso, y estas categorías pueden ser \"publicadas\" para hacerlas accesibles desde cualquier curso del sitio. * Los cuestionarios se califican automáticamente, y pueden ser recalificados si se modifican las preguntas. * Los cuestionarios pueden tener un límite de tiempo a partir del cual no estarán disponibles. * El profesor puede determinar si los cuestionarios pueden ser resueltos varias veces y si se mostrarán o no las respuestas correctas y los comentarios * Las preguntas y las respuestas de los cuestionarios pueden ser mezcladas (aleatoriamente) para disminuir las copias entre los alumnos. * Las preguntas pueden crearse en HTML y con imágenes. * Las preguntas pueden importarse desde archivos de texto externos. * Las preguntas pueden tener diferentes métricas y tipos de captura. #### Módulo de encuestas * Se proporcionan encuestas ya preparadas (COLLES, ATTLS) y contrastadas como instrumentos para el análisis de las clases en línea. * Se pueden generar informes de las encuestas los cuales incluyen gráficos. Los datos pueden descargarse con formato de hoja de cálculo Excel o como archivo de texto CSV. * La interfaz de las encuestas impide la posibilidad de que sean respondidas sólo parcialmente. * A cada estudiante se le informa sobre sus resultados comparados con la media de la clase. #### Módulo de Wikis * El profesor puede crear este modulo para que los alumnos trabajen en grupo en un mismo documento. * Todos los alumnos podrán modificar el contenido incluido por el resto de compañeros. * De este modo cada alumno puede modificar el wiki del grupo al que pertenece, pero podrá consultar todos los wikis. ",
    "url": "/cms/moodle",
    "relUrl": "/cms/moodle"
  },"64": {
    "doc": "1.4 Prestashop",
    "title": "1.4 Prestashop",
    "content": "## 1.4. Prestashop {: .no_toc } - TOC {:toc} TODO ",
    "url": "/cms/prestashop",
    "relUrl": "/cms/prestashop"
  },"65": {
    "doc": "1.2 Wordpress",
    "title": "\">",
    "content": ". 'Main', 'container' => 'nav' )); ?> . ``` Echa un vistazo al código sin miedo. La mayor parte es HTML, y solo hay un toquecito de PHP aquí y allá. ¿Qué dices? ¿Qué aún no sabes PHP? Verás, no hay mucho que entender aquí, así que no te asustes a la primera de cambio. Vamos a analizar el código línea a línea para que entiendas lo que hace: * Observa que, después del *doctype*, hemos usado un poquito de PHP para indicar el idioma de la instalación de Wordpress, utilizando en PHP la función *language_attributes()*. Esa es una de las muchas funciones del API de Wordpress que podemos llamar desde PHP, pero no desde HTML. * Observa también que **todo el código PHP tiene que ir entre las etiquetas \"\" y \"?>\"**, aunque seguro que ya te habías dado cuenta de eso si realmente has intentado leer el código, ¿verdad? * En la siguiente línea, y con el objetivo de asignar el *charset*, también hemos recurrido a una función de Wordpress (*bloginfo()*), así como para el título de la página (función *wp_title()*). Todas esas funciones deben llamarse desde PHP, por lo que abrimos y cerramos las etiquetas \"\" y \"?>\" cada vez que lo necesitamos. * Más abajo especificaremos el *viewport*. Si tu tema no va a ser responsivo, puedes quitar esta línea de código. * Justo después, para mostrar la URL al *favicon.ico* le indicamos la ruta a la carpeta \"mi-tema\" de la instalación de Wordpress. Eso se consigue con la función de Wordpress *get_stylesheet_directory_uri()*. * Un poco más abajo se usa la función *bloginfo()* con el argumento 'stylesheet_directory', que tiene el mismo efecto que *get_stylesheet_directory_uri()*. * Finalmente, se usa la función *wp_head()* de Wordpress, necesaria para que los plugins y otras funcionalidades de Wordpress estén disponibles en las páginas cargadas con nuestro tema. A partir de aquí cerramos la etiqueta *head* de HTML y empezamos con los contenidos de *body*. Quizás en este punto te estés preguntando por qué incluir el body en header.php. La razón es sencilla: algunos contenidos de la cabecera del tema van a aparecer en todas las páginas del sitio web, por lo que, al incluirlo aquí, evitamos duplicar código y logramos que el mantenimiento del tema sea más sencillo. Así, dentro de la sección \"\" del *body* HTML, incluiremos nuestra cabecera. En este ejemplo, hemos puesto el nombre del sitio web con un enlace a la página de inicio: ```html ",
    "url": "/cms/wordpress",
    "relUrl": "/cms/wordpress"
  },"66": {
    "doc": "1.2 Wordpress",
    "title": "\">",
    "content": "``` Fíjate que dentro del \"\" hemos escrito esta línea: ```php 'Main', 'container' => 'nav' )); ?> ``` Sirve para crear el menú de navegación. Para que funcione correctamente, primero deberemos añadir al archivo ***functions.php*** (que contiene las funciones propias del tema, como dijimos antes) este código: ```php 'Main' ) ); } ?> ``` Este código crea un menú llamado \"Main\" que nos aparecerá en el panel de administración de Wordpress, en *Apariencia -> Menús*. Lo que este código dice es que si existe una función llamada *register_nav_menus*, entonces debe crearse un nuevo menú de navegación llamado *Main*. Además, la función de Wordpress *add_theme_support()* sirve para indicar que en este tema queremos poder crear menús dinámicos. A partir de aquí, simplemente habremos de ir a *Apariencia -> Menús* en el *Dashboard* de Wordpress, crear nuestro menú y guardarlo, como con cualquier otro *theme*. Con esto ya tenemos la cabecera del tema creada junto con su menú de navegación. #### Paso 4: Crear la barra lateral para widgets (sidebar.php) Si has trasteado un poco con Wordpress, te habrás dado cuenta de que la mayoría de los temas incluyen una barra lateral a la derecha o a la izquierda del contenido principal. Bueno, algunos incluyen varias barras laterales, pero vamos a centrarnos en una, que es lo más frecuente. Las barras laterales suelen utilizarse para contener los ***widgets***. Hay temas que admiten *widgets* (la mayoría) y otros que no. Lo primero que tendremos que hacer, entonces, es informar a Wordpress de que nuestro tema **sí admite *widgets***. Para ello, abriremos de nuevo el archivo ***functions.php*** e incluiremos esta función: ```php 'Main Sidebar', 'before_widget' => ' . ', 'after_widget' => '', 'before_title' => '', 'after_title' => ' . ', )); ?> ``` Si activamos este tema y vamos al *dashboard* de Wordpress, en el menú *Apariencia -> Widgets* veremos que nos aparece una nueva zona de *widgets* llamada *\"Main Sidebar\"*. Una vez creada la zona lista para *widgets*, vamos a llamarla dentro del archivo ***sidebar.php***, otro archivo típico de casi todas las plantillas. Creamos este archivo y escribimos: ```html ``` Hemos utilizado un id llamado *\"sidebar\"* porque en este tema sólo va a existir una barra lateral. Si quieres que tu tema tenga más barras laterales, quizás prefieras utilizar una clase *\"sidebar\"* en lugar de un id. Y listo, ya tenemos creada la barra lateral lista para contener *widgets*. #### Paso 5: Crear el pie de página (footer.php) Llega el momento de crear otro elemento común en casi todos los temas: el pie que aparecerá en todas las páginas del sitio web. Recuerda que Wordpress funciona por módulos, y que los módulos son como piezas de un puzle: hasta ahora hemos ido creando esas piezas (*header*, *sidebar*, y ahora el *footer*) para luego montarlas todas en *index.php*. Pero eso será un poco más adelante. Ahora centrémonos en el *footer*. El *footer* se crea, oh sorpresa, en un archivo llamado ***footer.php*** que puede quedarnos así: ```html &amp;amp;amp;copy; , . Mi primer tema. ``` Fíjate en que la capa id=\"wrapper\" empezó en el *header* y la terminamos ahora, en el *footer*. Esto es lo más habitual, pero si queremos un *header* o un *footer* que se extienda por toda la pantalla, podemos mover las posiciones de los *div* que abren y cierran la capa \"wrapper\". Aquí aparece una llamada a la función de Wordpress *wp_footer()*, que es semejante a *wp_header()*. Estas funciones son lo que se llaman **hooks de Wordpress** y hacen funcionar los plugins que instalemos. Si no la incluyes, tu tema funcionará, pero la mayor parte de los plugins, no. #### Paso 6: Crear la página principal (index.php) La página principal se diseña en el archivo ***index.php***. Nuestro index tendrá inicialmente este aspecto: ```html ``` Observa estas tres funciones clave del API de Wordpress: * ***get_header()*** inserta los contenidos del archivo header.php en ese punto. * ***get_sidebar()*** hace lo mismo con la barra lateral. * ***get_footer()*** hace... bueno, ya te imaginas lo que hace, ¿verdad? Así montamos nuestro puzle de tres piezas. Fácil, ¿no? Sí, sí, un puzle muy sencillo, pero con la estructura básica de muchos temas de Wordpress. Y, en cualquier caso, podemos complicarlo añadiendo más cosas. Que es justo lo que vamos a hacer ahora... #### Paso 7. El loop de Wordpress (otra vez index.php) En el ***loop*** reside toda la magia de Wordpress. ¿Qué es el *loop*? Es un bucle (claro) en el que se muestran las entradas almacenadas en la base de datos de Wordpress. Y nosotros podemos decidir cómo se muestran esas entradas. Este código de ejemplo de *loop* debe añadirse a continuación del anterior en ***index.php***: ```html ",
    "url": "/cms/wordpress",
    "relUrl": "/cms/wordpress"
  },"67": {
    "doc": "1.2 Wordpress",
    "title": "\">",
    "content": "Publicado el por . ``` La primera línea constituye el auténtico ***loop***: ```html ``` Wordpress mirará si hay alguna entrada disponible (*if(have_posts())*). Si es así, entramos en un bucle que se repite para todos los posts (*while(have_posts())*). Y, para cada post, se recupera su contenido de la base de datos (*the_post()*). Una vez seleccionado el post, se muestra su información: la fecha de publicación (*the_time()*), los autores (*the_author_posts_link())*, el extracto (*the_excerpt()*)... Si no hay posts, se muestra el mensaje de \"No hay entradas\". #### Paso 8. Añadir thumbnails al loop (seguimos en index.php) Si queremos **añadir *thumbnails*** (imágenes destacadas) a cada publicación como sucede en muchos sitios web, lo que haremos es lo siguiente: vamos al archivo ***functions.php*** y añadimos este código: ```html ``` Con este código hemos habilitado los *thumbnails* de nuestras entradas y hemos establecido un tamaño para los mismos de 200x150 píxeles. Una vez hecho esto, modificaremos el *loop* de ***index.php*** como sigue: ```html ",
    "url": "/cms/wordpress",
    "relUrl": "/cms/wordpress"
  },"68": {
    "doc": "1.2 Wordpress",
    "title": "\">",
    "content": "Publicado el por . ``` Observa que hemos añadido un par de líneas en las que se comprueba si el post tiene *thumbnail* y, en caso afirmativo, lo recuperamos de la base de datos y lo mostramos (función *the_post_thumbnail()*). La forma concreta en la que queremos que se visualice todo esto debe establecerse mediante CSS, por supuesto, en el archivo *style.css*. Vamos a dejar de añadir cosas *loop* en este punto, pero podríamos seguir ìncorporando elementos. Por ejemplo, **una paginación** de las entradas. Encontrarás en la red mucha información sobre el tema, aunque lo más práctico es bajarse una plantilla sencillita ya hecha que incluya lo que sea que queremos hacer y curiosear en su código fuente. #### Paso 9. Resultados de la búsqueda (search.php) Los resultados de la búsqueda se especifican en el archivo ***search.php***. He aquí un ejemplo: ```html ",
    "url": "/cms/wordpress",
    "relUrl": "/cms/wordpress"
  },"69": {
    "doc": "1.2 Wordpress",
    "title": "Resultados de la búsqueda",
    "content": " ",
    "url": "/cms/wordpress",
    "relUrl": "/cms/wordpress"
  },"70": {
    "doc": "1.2 Wordpress",
    "title": "\">",
    "content": "Publicado el por max_num_pages); } ?> ``` Fíjate qué curioso: se parece mucho a *index.php*. Tiene sentido, puesto que el resultado de una búsqueda no es otra cosa que una lista de *posts*. Esta página es la que va a mostrar los resultados de una búsqueda, así que vamos a necesitar habilitar el buscador en nuestro *theme*. Un buen sitio para colocarlo puede ser el *sidebar*. Iremos a nuestro archivo *sidebar.php* y, justo antes de la función que habilita la zona de *widgets* en la barra lateral, incluiremos este código: ```html /\"> \" name=\"s\" id=\"s\" /> ``` Con esto tenemos un campo de búsqueda en nuestra barra lateral. No olvides que en el archivo *style.css* debes dar formato a todas las clases e ids para que la plantilla se visualice como tú quieras. #### Paso 10. Configurar la vista de las entradas (single.php) La página de cada entrada o post individual es aquella donde solo se ve una entrada con todo su contenido. El archivo donde se define esto es ***single.php***, y puede ser más o menos así: ```html ",
    "url": "/cms/wordpress",
    "relUrl": "/cms/wordpress"
  },"71": {
    "doc": "1.2 Wordpress",
    "title": "\" rel=\"bookmark\" title=\"Enlace permanente a \">. ",
    "content": "Publicado por el . Categoría: ``` Si has llegado hasta aquí, te resultará fácil comprender este código. Si en el *loop* principal (en *index.php*) utilizamos *the_excerpt()* para mostrar el extracto de la entrada, aquí utilizamos la función *the_content()* para recuperar el contenido completo de la entrada. Por supuesto, esto se puede complicar hasta el infinito. A modo de ejemplo, observa cómo podríamos mostrar las entradas relacionadas: ```html ID); if ($tags) { $tag_ids = array(); foreach($tags as $individual_tag) $tag_ids[] = $individual_tag->term_id; $args=array( 'tag__in' => $tag_ids, 'post__not_in' => array($post->ID), 'showposts'=>5, // Number of related posts that will be shown. 'caller_get_posts'=>1 ); $my_query = new wp_query($args); if( $my_query->have_posts() ) { echo 'Artículos relacionados . '; while ($my_query->have_posts()) { $my_query->the_post(); ?> | \" rel=\"bookmark\" title=\"Permanent Link to \"> | '; } wp_reset_query(); } ?> ``` #### Paso 11: Habilitar y mostrar los comentarios Para permitir los comentarios en una entrada, añadiremos este código a nuestro archivo ***functions.php***: ```php // Permitir comentarios encadenados function enable_threaded_comments(){ if (is_singular() AND comments_open() AND (get_option('thread_comments') == 1)) { wp_enqueue_script('comment-reply'); } } add_action('get_header', 'enable_threaded_comments'); ``` Y en ***single.php***, justo antes de la línea del *endwhile*, escribiremos: ```html ``` Nuevamente, será el CSS, como es lógico, el que determine cómo se verán los comentarios. #### Paso 12: Crear la página de categorías y etiquetas Los archivos ***category.php*** y ***tags.php*** muestran, en ambos casos, una lista de entradas: * *category.php* muestra las entradas que pertenecen a una categoría. * *tags.php* muestra las entradas que contienen una etiqueta concreta. Eso significa que, de cara a la creación de la plantilla, los dos archivos son prácticamente iguales entre sí, y que los dos archivos contienen un *loop* muy semejante al de *index.php*. Para nuestra plantilla de ejemplo, te sugerimos que, en lugar de crear esos dos archivos, añadas esto antes del *loop* de *index.php*: ```html ",
    "url": "/cms/wordpress",
    "relUrl": "/cms/wordpress"
  },"72": {
    "doc": "1.2 Wordpress",
    "title": "Categoría: ",
    "content": " ",
    "url": "/cms/wordpress",
    "relUrl": "/cms/wordpress"
  },"73": {
    "doc": "1.2 Wordpress",
    "title": "Etiqueta: ",
    "content": "``` Cuando Wordpress vaya a mostrar, por ejemplo, la lista de artículos de una categoría, buscará el archivo *category.php* en la plantilla pero, como no lo encontrará, recurrirá a *index.php*. Y nuestro archivo *index.php* detectará que está mostrando los artículos de una categoría (*if (is_category()*) y mostrará el nombre de esa categoría antes del listado. #### ¿Y ahora qué? Ya tienes una plantilla sencilla y funcional creada desde cero. La creación de plantillas no termina aquí, claro. Solo hemos sentado las bases, pero son unas bases sólidas. La API de Wordpress es muy amplia, a menudo confusa y casi siempre redundante. Especializarse en el desarrollo para Wordpress es una tarea de largo recorrido que no puede aprenderse en unas cuantas horas. Pero si has llegado hasta aquí, ya has hecho, probablemente, lo más difícil. La mayoría de las plantillas tienen más archivos que la nuestra. Por ejemplo: * ***page.php***, para mostrar páginas estáticas. * ***author.php***, para mostrar la página de \"acerca de\". * ***404.php***, para crear nuestra propia página de error \"not found\". Por último, aquí tienes un diagrama de las relaciones que existen entre los archivos típicos de una plantilla Wordpress. Recuerda que el único obligatorio (además de styles.css) es index.php, y que una plantilla compleja puede tener otros archivos adicionales a los que aquí se muestran. ![Jerarquía de archivos de un tema de Wordpress](/assets/images/01-wordpress-jerarquia-archivos-tema.png) [Fuente: Wikimedia Commons](https://commons.wikimedia.org/wiki/File:Wordpress_Template_Hierarchy.png) Cuando Wordpress busque alguno de estos archivos y no le encuentre, recurrirá al siguiente en la jerarquía, y si no existe, al siguiente, y así hasta llegar a *index.php*, que sí debe existir. Eso es lo que nos ocurría en el Paso 12, cuando creábamos la plantilla para categorías dentro de *îndex.php* y no en *category.php*. ### 1.2.5. Plugins de Wordpress Los plugins de Wordpress, como cualquier plugin, son **añadidos que incrementan las funcionalidades del sistema base**. La arquitectura flexible de Wordpress permite realizar esa ampliación en casi cualquier sentido y es una de las razones del éxito de este CMS: con los plugins adecuados, un CMS originalmente pensado para hacer *blogging* puede convertirse casi en cualquier cosa. Los plugins, como ya hemos visto, se gestionan desde el menú \"Plugins\" del *dashboard*. Al instalar y activar un plugin, lo más habitual es que aparezca una nueva entrada de menú en algún sitio del *dashboard*. Cada plugin es virtualmente un programa nuevo acoplado a Wordpress, por lo que debes remitirte a la documentación de ese plugin para saber cómo utilizarlo. Hay muchos plugins gratuitos, otros muchos de pago y una gran mayoría que tienen una versión limitada gratuita y otra de pago con funciones adicionales. El desarrollo de plugins para Wordpress es una industria que proporciona muchos puestos de trabajo a programadores/as en la actualidad. Como hicimos con los *themes*, **vamos a ilustrar con un ejemplo el proceso de creación de plugins**. Haremos algo muy sencillo pero bien construido, de manera que pueda servirte para desarrollos posteriores más realistas. El plugin se llamará **\"Chiste\"** y se encargará de imprimir un chiste aleatorio cada vez que lo llamemos desde nuestra plantilla. El chiste aleatorio se extraerá de una tabla con chistes que almacenaremos en la base de datos. Lo puedes usar para imprimir un chiste en tu web de cuando en cuando, o para mostrar un chiste diferente cada vez que se carga la página, o yo qué sé para qué. Construiremos el plugin paso a paso, desde una versión muy simple que siempre contará el mismo chiste hasta la versión definitiva. De este modo, comprenderás muy bien el funcionamiento del sistema de plugins de Wordpress. #### **Crear un plugin nuevo** Para crear el plugin \"Chiste\" basta con crear un archivo llamado ***chiste.php*** en una carpeta llamada también *chiste* y ubicada a su vez en *wp-content/plugins/* Dentro del archivo *chiste.php*, escribiremos el comentario de cabecera para que Wordpress lo reconozca como un plugin válido (igual que sucede con las plantillas). Es muy importante respetar la sintaxis. ```php ``` #### **Añadir funciones al plugin** Vamos a crear nuestra primera función dentro del plugin. Abre el archivo ***chiste.php*** y añade esto: ```php function chiste(){ echo \"Van dos por tres calles y se cae el de enmedio\"; } ``` Supongo que este código no requiere demasiada explicación, ¿no? Pues ahí lo dejamos. #### **Instalar y desinstalar el plugin** Para poder instalar y desinstalar un plugin desde el panel de administracion de Wordpress, es necesario crear dos funciones más en ***chiste.php***: una para instalar y otra para desinstalar. Estas funciones, por ahora, las dejaremos vacías. Además, al final del archivo ***chiste.php*** hay que usar la funcion del API de Wordpress add_action() para indicar las funciones que activan y desactivan el plugin. Es más fácil hacerlo que explicarlo. Ahí va: ```php function chiste_instala(){ // Por ahora, la dejamos vacía } function chiste_desinstala(){ // Por ahora, la dejamos vacía } add_action('activate_chiste/chiste.php','chiste_instala'); add_action('deactivate_chiste/chiste.php', 'chiste_desinstala'); ``` #### **Cómo usar las funciones del plugin** Ahora ya puedes usar este plugin tan chistoso. Solo debes colocar en alguna sección de tu plantilla la siguiente línea: ```php ``` Por ejemplo, si colocas esa función en el archivo *header.php* de tu plantilla, cada vez que se cargue el header (es decir, en todas las páginas), la función *chiste()* será invocada y, hala, un chiste impreso en tu pantalla. #### **Configurar el plugin desde el panel de administración** Ahora vamos a crear una entrada dentro de los menús del *dashboard* que nos permita modificar las opciones de este plugin. La entrada de menú la integraremos en el menú \"opciones\". Para lograrlo, necesitamos dos funciones más en nuestro archivo ***chiste.php***: * *chiste_panel()*: aquí incluiremos el html necesario para la pantalla de configuración de nuestro plugin. Para no mezclar html dentro del código, usaremos la función include() de PHP, de manera que podamos colocar el HTML en otro archivo a parte. * *chiste_add_menu()*: aquí usaremos la función del API de Wordpress *add_options_page()*, que sirve para añadir una entrada al menó \"Opciones\". Además, llamaremos a otra función del API, *add_action()*, para provocar la invocación de *chiste_add_menu()* cada vez que Wordpress vaya a crear su menú de administración. ```php ``` Quizá la línea de *add_options_page()* requiera alguna explicación adicional, ¿verdad? Lo único que hacemos ahí es añadir una entrada al menú de opciones del *dashboard*, indicándole en los parámetros: * El título de la pantalla de administración de nuestro plugin (\"chiste\"). * El texto de la entrada de menú (también \"chiste\"). * El permiso necesario del usuario que podrá ver este elemento de menú. Hemos elegido \"manage_options\", que es un permiso típico de los administradores del sitio. Otros usuarios de menor nivel no podrán acceder a este menú. Tienes una lista completa de los permisos (o *capabilities*, en jerga de Wordpress) en https://wordpress.org/support/article/roles-and-capabilities/) * La URI amigable para esta opción de menú. Puede ser cualquier cosa, siempre que no esté ya en uso. Hemos usado el propio nombre del archivo (*basename(__FILE__)*) para evitar conflictos con otras opciones de menú. * El nombre de la función que se invocará cuando se haga clic en ese elemento de menú (es decir, *chiste_panel()*). El archivo *panel.html* será un simple formulario html que mostrará la configuración del plugin. Crearemos algo muy sencillo. Por supuesto, se puede mejorar con un poco de HTML y CSS. Lo guardaremos en ***template/panel.html***: ```html Inserte su chiste ``` Por último, modificaremos la función *chiste_panel()* para poder visualizar nuestros avances: ```php <?php function chiste_panel(){ include('template/panel.html'); } echo \" ",
    "url": "/cms/wordpress",
    "relUrl": "/cms/wordpress"
  },"74": {
    "doc": "1.2 Wordpress",
    "title": "{$_POST['chiste']}",
    "content": "\"; ?> ``` Podemos probar que todo funciona escribiendo algo en el formulario (pulsando \"Enviar\"). #### **Acceder a la BD desde nuestro plugin** También se puede acceder a la base de datos de Wordpress desde un plugin. Esto es práctico para, por ejemplo, crear nuestra propia tabla adicional con la que gestionar el contenido del plugin, que es justo lo que nosotros queremos. Para ello, antes debemos desinstalar el plugin desde el panel de control. Solo así podremos modificar la función de instalación y ejecutarla más adelante de nuevo. Las funciones de Wordpress que manejan la BD se invocan con una variable global ***$wpdb***: ```php prefix . \"chistes\"; $sql = \" CREATE TABLE $table_name( id INTEGER NOT NULL AUTO_INCREMENT , chiste TEXT NOT NULL , PRIMARY KEY ( `id` ) ) ;\"; $wpdb->query($sql); $sql = \"INSERT INTO $table_name (chiste) VALUES ('Van dos por tres calles y se cae el de enmedio');\"; $wpdb->query($sql); } function chiste_desinstala(){ global $wpdb; $tabla_nombre = $wpdb->prefix . \"chistes\"; $sql = \"DROP TABLE $tabla_nombre\"; $wpdb->query($sql); } ?> ``` Por supuesto, hay que agregar los datos a la BD desde nuestro panel de configuración del plugin, para lo cual modificaremos la función *chiste_panel()*: ```php function chiste_panel(){ include('template/panel.html'); global $wpdb; $table_name = $wpdb->prefix . \"chistes\"; if(isset($_POST['chiste_inserta'])){ $sql = \"INSERT INTO $table_name (chiste) VALUES ('{$_POST['chiste_inserta']}');\"; $wpdb->query($sql); } } ``` ¡Ahora que ya podemos insertar chistes en nuestra BD desde el *dashboard* de Wordpress! Solo nos queda poder mostrarlos en nuestra función *chiste()*. Para esto, extraeremos un chiste de manera aleatoria de nuestra BD modificando la función *chiste()*: ```php function chiste(){ global $wpdb; $table_name = $wpdb->prefix . \"chistes\"; $chiste = $wpdb->get_var(\"SELECT chiste FROM $table_name ORDER BY RAND() LIMIT 0, 1; \" ); include('template/chiste.html'); } ``` Ahora modifiquemos nuestro ***template/chiste.html*** para que imprima la variable $chiste: ```html ",
    "url": "/cms/wordpress",
    "relUrl": "/cms/wordpress"
  },"75": {
    "doc": "1.2 Wordpress",
    "title": "",
    "content": "``` Para terminar, vamos modificar el html de nuestro panel de opciones para que se adapte al html del administrador de Wordpress y no quede tan feo. Esto es solo una cuestión estética, por supuesto. Pero, ya que hacemos algo, vamos a hacerlo bien: ```html Introduce un nuevo chiste Escriba el chiste ``` ",
    "url": "/cms/wordpress",
    "relUrl": "/cms/wordpress"
  },"76": {
    "doc": "1.2 Wordpress",
    "title": "1.2 Wordpress",
    "content": "## 1.2. Wordpress {: .no_toc } - TOC {:toc} Wordpress es sin duda el campeón actual de los CMS. Algunas estadísticas afirman que el 90% de los sitios web de internet está hecho con Wordpress. Probablemente son estadísticas un poco infladas, pero la importancia de este CMS es innegable y cualquier desarrollador web debe conocerlo, aunque sea para odiarlo. Wordpress es un CMS enfocado a la creación de blogs, pero, en su estadio actual, permite crear casi cualquier tipo de sitio web: tiendas online, portales, revistas digitales, álbumes de imágenes o recursos de cualquier tipo... Está desarrollado en PHP bajo licencia GPL y se ha convertido en una auténtica plataforma de desarrollo web por sí mismo. Tiene detrás una enorme comunidad de desarrolladores y diseñadores, que se encargan de actualizarlo y de crear plugins y temas para la comunidad. ### 1.2.1. Características principales de Wordpress Las características principales de Wordpress son: * Separación entre el contenido y el diseño. El contenido se almacena en una base de datos. El diseño, en una plantilla, que es un conjunto de archivos CSS y PHP. * Apuesta decidida por la apariencia atractiva del resultado final (aunque esto depende mucho de la plantilla, claro) . * La estructura y diseño visual del sitio depende de un sistema de plantillas. Es decir: cambias la plantilla y todo el sitio web cambia de aspecto, conservando el mismo contenido. * La visualización final del contenido también depende de los plugins y widgets que se hayan instalado, y que pueden modificar sustancialmente en funcionamiento tanto del front-end como del back-end. * Código claro, bien estructurado y con una API bien documentada (alrededor del 50% de los programadores querrán internarme en un psiquiátrico por haber escrito esto). * Apuesta decidida por respetar las recomendaciones del W3C, aunque, desde luego, hay plugins y plantillas que no lo hacen. * Las entradas publicadas se ordenan por fecha, aunque esto se puede modificar. Wordpress se diseñó para hacer *blogging* y esa intención inicial aún permanece intacta, pero con un poco de manipulación puede emplearse para cualquier cosa. #### Funcionalidades de Wordpress Wordpress hace magia. Así de sencillo. Si te vas a convertir en desarrollador/a web, Wordpress es tu peor enemigo, porque permite que cualquier usuario medio, sin tener ni idea de programación, pueda crear un sitio web solvente y de aspecto profesional en un rato. No te voy a engañar: *a ti te llevaría meses programar algo parecido desde cero*. Pero **Wordpress también tiene sus limitaciones**, y cuando sus usuarios las descubren, necesitan a un programador que sepa meterse en las tripas del sistema para retorcérselas. Ahí es donde entrarás tú. De modo que sí: **Wordpress es tu peor enemigo, pero puede convertirse en tu mejor aliado**. Para eso, tienes que conocer qué es capaz de hacer y qué no. Entre sus asombrosas funciones podemos contar estas: * Fácil instalación, actualización y personalización. * Actualizaciones automáticas. * Múltiples usuarios con diferentes roles. * Capacidad de crear páginas estáticas además de entradas de blog. * Organización de las publicaciones por categorías y etiquetas (\"tags\"). * Buscador integrado de contenido. * Editor WYSIWYG (\"What You See Is What You Get\") por bloques. * Guardado automático de los artículos mientras se escriben. * Moderación de comentarios. * Personalización de las URIs de cada publicación. * Distribución de los artículos y comentarios mediante RSS y otros mecanismos estandarizados. * Gestión intuitiva de la biblioteca multimedia. * Admite plugins para aumentar y/o modificar la fucionalidad del sistema, a riesgo de convertirlo en una \"monstruo de Frankenstein\" hecho a pegotes. * Admite plantillas que cambian de forma radical la apariencia del sitio. * Admite widgets o pequeñas utilidades adicionales que pueden ubicarse en los lugares que la plantilla permita. #### Plantillas de Wordpress Las plantillas (o *themes*) de Wordpress son **diseños CSS que sirven para establecer la apariencia y estructura del sitio web**. Algunas también modifican parte del panel de administración. Hay una gran comunidad dedicada al diseño de estas plantillas. Puedes encontrarlas tanto en el sitio de Wordpress (comprobadas y aprobadas oficialmente) como en sitios web de terceros. Muchas son gratuitas, otras de pago y, la mayoría, tienen una versión gratuita con funciones adicionales de pago. Las posibilidades de las plantillas, tanto a nivel de diseño, estructura o gestión, son tan grandes que te permiten tener desde un simple blog hasta un sitio web completamente personalizable de forma intuitiva desde el panel de administración. Hay un gran campo de trabajo en las plantillas de Wordpress para un desarrollador web. Más adelante veremos como crear plantillas nuevas, algo que también te servirá para modificar las plantillas existentes. #### Widgets Los widgets son **pequeñas aplicaciones** que proporcionan nuevas funcionalidades a un programa o que permiten un acceso rápido a funcionalidades usadas con frecuencia. Pueden ser vistosos como, por ejemplo, relojes en pantalla, calculadoras, calendarios o nubes de tags; o pueden ser discretos pero útiles como, por ejemplo, un cuadro con enlaces de interés o un contador del número de visitas. Wordpress incorpora un sistema de widgets para sus plantillas que ofrece numerosas posibilidades y flexibilidad para el diseño y estructura de sus blogs. Cada plantilla puede soportar un número diferente de Widgets en distintas posiciones de la pantalla. #### Plugins Hay una monstruosa cantidad de plugins que **potencian el uso de Wordpress y que lo convierten en un CMS prácticamente de propósito general**. Encontrarás un plugin para casi cualquier cosa que se te ocurra. Bueno, no: encontrarás decenas de plugins para casi cualquier cosa que se te ocurra. Pero (¡siempre hay un pero!) con los plugins se corre el riesgo de empezar a parchear Wordpress hasta convertirlo en un amasijo informe de código puesto a pegotes. Muchos sitios web montados con Wordpress se vuelven ingobernables (y extraordinariamente lentos y pesados en la carga) por la gran cantidad de plugins que tienen activados. Otro problema de los plugins es que pueden provocar incontables problemas con las actualizaciones del sistema. En el ámbito de los plugins también hay mucho trabajo potencial para un futuro desarrollador/a web como tú: tanto para crear plugins nuevos y adaptados a las necesidades del cliente como para optimizar y racionalizar el uso de plugins existentes en los sitios que ya están en funcionamiento. Por último, y al igual que ocurría con las plantillas, tienes que saber que muchos plugins son gratuitos, otros son de pago, y otros tienen versiones gratuitas que se vuelven de pago cuando queremos utilizar sus características más atractivas. #### Fallos de seguridad de Wordpress Las críticas más contundentes contra Wordpress siempre se han centrado en sus problemas de seguridad. En mayo de 2007, por ejemplo, un estudio reveló que el 98% de los blogs basados en Wordpress eran vulnerables a ataques. Todos los sistemas que se vuelven muy populares se vuelven inseguros por el simple hecho de que se multiplican los ataques contra ellos. La receta para minimizar los posibles problemas de seguridad es sencilla: **mantener Wordpress actualizado**. No podemos hacer mucho más allá de eso. ### 1.2.2. Instalación y explotación de Wordpress #### Instalación de Wordpress Wordpress es un CMS increíblemente sencillo de instalar y poner en marcha. El proceso de instalación se ha depurado tanto, que cualquier usuario medio sin especiales conocimientos técnicos puede llevarlo a cabo. Como tú no eres un usuario/a medio, no vamos a detenernos mucho en ello, porque es realmente sencillo. A continuación, resumimos los pasos: 1. Necesitas, obviamente, ciertos prerrequisitos: acceso a un servidor web con soporte para PHP y un servidor de bases de datos MariaDB o similar. 2. Crea una base de datos vacía. Puedes llamarla como quieras (siempre que recuerdes el nombre, claro). 3. Descarga el código fuente de Wordpress (¡solo del sitio oficial, por favor! Es decir, de wordpress.org) y súbelo a una carpeta en tu servidor. La carpeta debe ser accesible vía web. Puedes usar FTP para ello. Muchos servidores tienen un navegador de archivos vía web que también te permitirá subir el código fuente. Otros servidores incluso te ofrecen la posibilidad de instalar Wordpress desde el propio panel de control de servidor. Consulta con tu proveedor o trastea con el panel de control para ver si es tu caso. 4. Lanza el programa de instalación. Esto se logra, simplemente, escribiendo la URI de tu wordpress. Algo como https://tu-servidor/tu-carpeta, donde \"tu-servidor\" es el nombre de dominio de tu servidor y \"tu-carpeta\" es la carpeta donde subiste el código fuente de Wordpress. 5. Aparecerá una pantalla como esta. A partir de aquí, solo tienes que seguir las instrucciones. ![Pantalla de instalación de Wordpress](/assets/images/01-wordpress-instalacion.png) #### Explotación de Wordpress Una vez que tienes instalado tu Wordpress en el servidor, ya dispones de un sitio en línea que puedes visitar en la URI https://tu-servidor/tu-carpeta. El sitio es por completo funcional pero, obviamente, está vacío de contenido. Su aspecto será más o menos como este: ![Wordpress recién instalado](/assets/images/01-wordpress-recien-instalado.jpg) Lo que estás viendo aquí es la plantilla (*theme*) por defecto de Wordpress. Dependiendo de la versión que instales, tendrá un aspecto algo diferente. Una instalación nueva también incorpora una publicación (*post*) de ejemplo (con un comentario también de ejemplo), así como una página estática. Lo siguiente que tienes que hacer es acceder al panel de administración, que estará hubicado en https://tu-servidor/tu-carpeta/wp-admin. Verás una pantalla de login donde tendrás que introducir el usuario y la contraseña de administración de Wordpress. Estas credenciales las seleccionaste durante el proceso de instalación. Una vez traspasada la puerta del login, encontrarás una pantalla con la que debes familiarizarte: el **panel de administración** o ***dashboard*** de Wordpress. ![Panel de administración de Wordpress](/assets/images/01-wordpress-panel-administracion.png) El resto de tu trabajo consistirá en familiarizarte con este panel de administración. Es una aplicación web muy completa e intuitiva, y a cualquier usuario/a un poco avezado no le costará trabajo hacerse con ella, e incluso le resultará divertido. No hay que decir que no necesitas saber nada de programación para manejar este panel. Solo a modo de introducción, te resumo las secciones principales que puedes encontrar en el *dashboard* de Wordpress, accesibles mediante el menú de la izquierda: * **Post**. Son las publicaciones de Wordpress (recuerda que, originalmente, era una herramienta para hacer *blogging*). Los artículos se crean con un sencillo editor WYSIWYG al que se le pueden ir añadiendo bloques. Hay multitud de opciones de configuración de cada artículo: a qué categoría pertenecen, qué etiquetas tienen, si se permiten o no los comentarios, la fecha de la publicación, la autoría, etc. * **Media**. Es la biblioteca multimedia. Desde aquí se organizan todos los recursos multimedia: imágenes, vídeos, audios, documentos... Cualquiera de esos recursos puede incrustarse en cualquier post. * **Pages**. Son las páginas estáticas de Wordpress. A diferencia de los posts, no se organizan cronológicamente ni se pueden asignar a categorías. Se utilizan para las páginas cuyo contenido debe estar siempre accesible y cambia poco con el tiempo: \"Acerca de\", \"Contacto\" y cosas así. * **Comments**. Desde aquí se moderan los comentarios que los visitantes hayan hecho a los posts. Aquí termina la parte del *dashboard* dedicada a gestionar el **contenido** del sitio. El resto de menús se dedican a gestionar la **apariencia y configuración** del sitio: * **Appearance**: Aquí se manipulan las plantillas (themes), los widgets, los menús... Pasarás incontables horas de diversión (y desesperación) en esta sección. * **Plugins**: No te desvelo nada nuevo si te digo que desde aquí gestionas los plugins, ¿verdad? * **Users**: Puedes dar acceso a otros usuarios a tu Wordpress. Hay varios niveles o roles de acceso: administrador, editor, publicador... Cada rol verá un menú de administración diferente. * **Tools**: Diferentes herramientas útiles. Importar y exportar contenido son las principales. Muchos plugins añadirán opciones a este menú (otros las añadirán en otra parte). * **Settings**: Opciones de configuración del sitio. Aquí se pueden cambiar muchas cosas muy importantes: el nombre del sitio, el formato de las URIs, si se permiten o no comentarios por defecto, si los comentarios se publican inmediatamente o tiene que moderarlos un administrador. Conviene que te pases un rato curioseando y probando cosas. ### 1.2.3. Breve tour por Wordpress para novatos Todo esto puede parecer complicadísimo, pero Wordpress (a nivel de usuario) es muy secillo de usar cuando has pasado un poco de tiempo con él. Si es tu primera vez con Wordpress, te recomiendo que te prepares un café (o tu infusión favorita), te sientes sin prisa ante el ordenador en algún momento en el que no te vayan a interrumpir durante varias horas y dediques una sesión intensiva a hacer lo siguiente: 1. **Instala un Wordpress** de prueba en tu servidor local o en un servidor remoto si aún no lo has hecho. 2. Accede al **panel de administración**. 3. **Crea dos o tres categorías**. Antes deberás decidir qué temática tendrá tu sitio. Utiliza algún tema de tu interés: un deporte, la tecnología, la programación, el cine, la literatura... Si usas algo que te interese, la experiencia será mucho más fructífera. Por ejemplo, si tu temática es \"programación\", podrías crear las categorías \"Java\", \"PHP\" y \"Python\", por decir algo. 4. **Crea un par de entradas** por cada categoría. No tienen que ser nada especial: solo estamos jugueteando. Copia y pega texto de alguna otra publicación de internet. O redáctalas tú, como prefieras. Asegúrate de incluir alguna imagen y otros elementos multimedia. 5. **Crea alguna página** (\"Acerca de\", \"Sobre mí\", \"Contacto\" o algo así). 6. **Cambia de plantilla**. Prueba varias que te gusten y, cuando te decidas por una, métete en sus opciones de configuración y trastea un rato. Algunas plantillas son configurables hasta límites enfermizos. Otras, en cambio, son muy limitadas. No olvides ir observando cómo estos cambios afectan a la forma en la que los visitantes verían en blog. 7. **Instala algunos plugins** de prueba que te parezcan interesantes. Por ejemplo, galerías de imágenes o formularios de contacto. 8. **Crea algunos usuarios** adicionales con distintos roles. Accede con ellos al panel de administración para ver las diferencias entre unos roles y otros. 9. **Juguetea sin miedo con las opciones** del menu \"Settings\". Algunas de ellas podrían dejar tu Wordpress totalmente inoperativo. ¡Bienvenido a la vida real! Trata de resolver el problema bicheando en internet. Antes o después, eso mismo te ocurrirá con sitios reales. Cuando termines esta experiencia inmersiva (que puede llevarte varios días), estarás en condiciones de montar un sitio web con Wordpress real. ### 1.2.4. Cómo crear y modificar una plantilla de Wordpress Wordpress dispone de una API de funciones útiles para desarrollar nuestras propias plantillas (*themes*) y plugins. Como vamos a hacer a lo largo de todo el texto, veremos este asunto de forma práctica: **creando nuestra propia plantilla desde cero**. Por cierto, que a lo largo de toda la sección nos referiremos indistintamente a las plantillas de Wordpress como *plantillas*, *temas* o *themes*, pues así lo encontrarás en toda la documentación que consultes. ¿Estás preparado/a? ¡Vamos allá! #### Las plantillas o temas de Wordpress Como ya hemos dicho, existen muchos sitios web donde adquirir plantillas (*themes*), empezando por el propio sitio oficial de Wordpress. Algunas son gratuitas, otras de pago, y otras tienen versiones gratuitas incompletas o parcialmente desactivadas, y versiones de pago que permiten usar todas las funcionalidades. Pero, a veces, queremos ir un paso más allá y desarrollar nuestra propia plantilla. Para ello, tenemos dos opciones: 1. **Utilizar una plantilla base**. Existen muchas plantillas básicas diseñadas para ser usadas como base para desarrollar nuevas plantillas. Contienen todos los elementos mínimos necesarios de una plantilla de Wordpress, además de otras características, de modo que el trabajo de creación de la nueva plantilla se minimiza. Estas plantillas a veces también se llaman *frameworks* Algun plantillas básicas muy conocidas son *Bones*, *Basic* o *Divi*. Los desarrolladores profesionales pueden acabar creando su propia plantilla base a partir de la cual crear el resto de plantillas a su gusto. 2. **Desarrollar la plantilla desde cero**. Este proceso es más costoso en tiempo, pero conseguiremos aproximarnos más a lo que estamos buscando, evitando estar atados a un *framework* que no hemos programado nosotros y conservando el control absoluto sobre los archivos y contenidos de la plantilla. En este texto vamos a decantarnos por la segunda opción, no porque sea mejor ni peor, sino porque es lo más didáctico si pretendemos aprender cómo se organizan las plantillas de Wordpress. #### Dónde localizar las plantillas instaladas Puedes encontrar los temas instalados a través del panel de administración (*dashboard*) de tu Wordpress, en el menú Appearance -> Themes. Pero, para nuestros propósitos, es mejor hacerlo navegando directamente entre las carpetas del servidor, en la ruta *carpeta-de-wordpress -> wp-content -> themes*. Ahí encontrarás una carpeta por cada plantilla de Wordpress instalada en tu sistema. Bastará, entonces, con crear una carpeta nueva para iniciar la construcción de nuestra plantilla. A partir de ahora supondremos que estamos creando un nuevo tema llamado ***mi-tema***. Es decir, dentro de la carpeta *themes*, habremos creado un directorio llamado *mi-tema*. #### Archivos mínimos de un tema de Wordpress Wordpress funciona mediante **módulos**. Por ejemplo, para insertar el pie de una página habremos de llamar al archivo *footer.php*, en caso de que exista. Y lo mismo con la cabecera, la barra de navegación, etc. Cada uno de esos elementos es un módulo. Una plantilla de Wordpress puede estar formada por muchos archivos, pero **para que un tema de Wordpress funcione sólo necesita dos archivos: index.php y style.css**. Está claro que con sólo estos dos archivos tendremos un tema muy básico, pero será considerado por Wordpress un tema válido si estos dos archivos están bien configurados. A continuación vamos a desarrollar una plantilla completa que nos sirva de base para otros proyectos. Contendrá una cabecera, un pie y una barra lateral. No pretendemos desarrollar una plantilla supercompleja con funciones avanzadas, claro, pero sí una bastante completa que podamos usar por sí misma o como base para proyectos más complejos. Nuestro tema va a tener la mayor parte de los archivos habituales en los temas \"profesionales\". ¿Qué cuáles son esos archivos? Aquí tienes una lista con una breve explicación de cada uno: * **/images**. Carpeta con las imágenes de la plantilla. * **/js**. Carpeta con los archivos de JavaScript. * **style.css**. Hoja de estilos de la plantilla. *Obligatoria para que la plantilla funcione.* * **index.php**. Página principal. *Obligatoria para que la plantilla funcione.* * **screenshot.png**. Imagen en miniatura. Se verá en el dashboard de Wordpress (menú Apariencia -> Temas). * **favicon.ico**. La imagen que se verá en el navegador (o al guardar el sitio como un marcador). * **header.php**. Cabecera de la plantilla. * **sidebar.php**. Barra lateral de la plantilla. * **footer.php**. Pie de página de la plantilla. * **single.php**. Una entrada (post) individual. * **page.php**. Una página estática individual. * **category.php**. Página de resultados de una categoría. * **tag.php**. Página de resultados de una etiqueta. * **search.php**. Página de resultados de búsqueda. * **functions.php**. Funciones genéricas de nuestra plantilla (accesibles desde todos los archivos de la misma). Como es lógico, para crear una buena plantilla es fundamental que poseas un buen dominio de HTML y CSS. Si no, mejor dedícate a otra cosa (por ejemplo, a aprender HTML y CSS). En el resto de esta sección, vamos a construir nuestra plantilla en 11 sencillos pasos. Bueno, o no tan sencillos, eso ya lo decides tú... #### Paso 1: La hoja de estilos (style.css) El primer paso para construir una plantilla de Wordpress siempre es el archivo ***style.css*** (dentro de la carpeta \"mi-tema\"). Ese archivo debe abrirse con estas líneas de comentario para que Wordpress lo reconozca como la hoja de estilos de la plantilla y la información aparezca en *Apariencia -> Temas*: ```css /* Theme Name: Mitema Theme URI: el lugar donde vayas a alojar el tema para ponerlo a disposición de la comunidad Description: La descripción del tema Author: Tu nombre y apellidos Author URI: la web profesional del creador del tema Version: 1.0 */ ``` A partir de aquí, puedes escribir tu propio código de CSS como harías con cualquier otra página web. De momento, puedes dejarlo así e ir añadiendo reglas CSS más adelante. #### Paso 2: Imágenes y JavaScript (subdirectorios /images y /js) Para este *theme* vamos a utilizar dos pequeñas librerías Javascript: * ***Modernizr***, que sirve para detectar las capacidades de HTML5 y CSS3 del navegador (por si nos topamos con un navegador anticuado, cosa que es, lamentablemente, más frecuente de lo que pueda parecer). * ***Respond***, que sirve para que las versiones jurásicas de Internet Explorer sepa interpretar los media queries de CSS3. Te lo confieso: podríamos crear nuestra plantilla sin estas librerías, pero las usaremos de excusa para que veas cómo se integra una librería Javascript en una plantilla de Wordpress. Para alojar ese tipo de contenido adicionarl, vamos a **crear las carpetas *\"images\"* y *\"js\"*** dentro de la carpeta *\"mi-tema\"*. * En la carpeta *\"js\"* colocaremos una copia de las librerías Modernizr y Respond (¡siempre bajadas de la web del desarrollador, por favor!). * En la carpeta *\"images\"* colocaremos más adelante las imágenes que vayamos necesitando para nuestro CSS. ¡Ojo! Hay dos archivos de imagen obligatorios para todas las plantillas Wordpres, ***screenshot.png*** y el ***favicon.ico***, pero estos se deben ubicar en el directorio raíz del tema y no dentro de la carpeta *\"images\"*. Recuerda que Wordpress utiliza estos dos archivos para la previsualización del tema y para el icono de la página una vez que el tema se active. #### Paso 3: Crear la cabecera del tema y el menú de navegación (header.php) El archivo ***header.php*** contiene la cabecera de todas las páginas que se carguen con nuestro tema. Es el lugar donde suele ponerse el logo, el menú principal, un banner con imágenes o cualquier otra cosa que queramos que aparezca en la parte superior de todas las páginas del sitio web. Este es un código sencillito para empezar con header.php: ```html > \"> | /favicon.ico\" /> | \" /> | \" /> . ",
    "url": "/cms/wordpress",
    "relUrl": "/cms/wordpress"
  }
}
